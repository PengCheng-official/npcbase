
// Generated from D:/Pengcheng/University/Year3/DBMS/NpcBase/grammar/SQLiteParser.g4 by ANTLR 4.13.2


#include "SQLiteParserListener.h"
#include "SQLiteParserVisitor.h"

#include "SQLiteParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct SQLiteParserStaticData final {
  SQLiteParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  SQLiteParserStaticData(const SQLiteParserStaticData&) = delete;
  SQLiteParserStaticData(SQLiteParserStaticData&&) = delete;
  SQLiteParserStaticData& operator=(const SQLiteParserStaticData&) = delete;
  SQLiteParserStaticData& operator=(SQLiteParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag sqliteparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<SQLiteParserStaticData> sqliteparserParserStaticData = nullptr;

void sqliteparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (sqliteparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(sqliteparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<SQLiteParserStaticData>(
    std::vector<std::string>{
      "parse", "sql_stmt_list", "sql_stmt", "alter_table_stmt", "analyze_stmt", 
      "attach_stmt", "begin_stmt", "commit_stmt", "rollback_stmt", "savepoint_stmt", 
      "release_stmt", "create_index_stmt", "indexed_column", "create_table_stmt", 
      "table_options", "column_def", "type_name", "column_constraint", "signed_number", 
      "table_constraint", "foreign_key_clause", "conflict_clause", "create_trigger_stmt", 
      "create_view_stmt", "create_virtual_table_stmt", "with_clause", "common_table_expression", 
      "cte_table_name", "delete_stmt", "delete_stmt_limited", "detach_stmt", 
      "drop_stmt", "expr", "raise_function", "literal_value", "value_row", 
      "values_clause", "insert_stmt", "returning_clause", "upsert_clause", 
      "pragma_stmt", "pragma_value", "reindex_stmt", "select_stmt", "join_clause", 
      "select_core", "table_or_subquery", "result_column", "join_operator", 
      "join_constraint", "compound_operator", "update_stmt", "column_name_list", 
      "update_stmt_limited", "qualified_table_name", "vacuum_stmt", "filter_clause", 
      "window_defn", "over_clause", "frame_spec", "frame_clause", "order_clause", 
      "limit_clause", "ordering_term", "asc_desc", "frame_left", "frame_right", 
      "frame_single", "error_message", "filename", "module_argument", "keyword", 
      "name", "function_name", "schema_name", "table_name", "table_or_index_name", 
      "column_name", "column_alias", "collation_name", "foreign_table", 
      "index_name", "trigger_name", "view_name", "module_name", "pragma_name", 
      "savepoint_name", "table_alias", "window_name", "alias", "base_window_name", 
      "table_function_name", "factored_select_stmt", "simple_select_stmt", 
      "compound_select_stmt", "recursive_cte", "initial_select", "recursive_select", 
      "simple_function_invocation", "aggregate_function_invocation", "window_function_invocation", 
      "simple_func", "aggregate_func", "window_func", "any_name"
    },
    std::vector<std::string>{
      "", "';'", "'.'", "'('", "')'", "','", "'='", "'*'", "'+'", "'-'", 
      "'~'", "'||'", "'/'", "'%'", "'<<'", "'>>'", "'&'", "'|'", "'<'", 
      "'<='", "'>'", "'>='", "'=='", "'!='", "'<>'", "'->'", "'->>'", "'ABORT'", 
      "'ACTION'", "'ADD'", "'AFTER'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", 
      "'AS'", "'ASC'", "'ATTACH'", "'AUTOINCREMENT'", "'BEFORE'", "'BEGIN'", 
      "'BETWEEN'", "'BY'", "'CASCADE'", "'CASE'", "'CAST'", "'CHECK'", "'COLLATE'", 
      "'COLUMN'", "'COMMIT'", "'CONFLICT'", "'CONSTRAINT'", "'CREATE'", 
      "'CROSS'", "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", 
      "'DATABASE'", "'DEFAULT'", "'DEFERRABLE'", "'DEFERRED'", "'DELETE'", 
      "'DESC'", "'DETACH'", "'DISTINCT'", "'DROP'", "'EACH'", "'ELSE'", 
      "'END'", "'ESCAPE'", "'EXCEPT'", "'EXCLUSIVE'", "'EXISTS'", "'EXPLAIN'", 
      "'FAIL'", "'FOR'", "'FOREIGN'", "'FROM'", "'FULL'", "'GLOB'", "'GROUP'", 
      "'HAVING'", "'IF'", "'IGNORE'", "'IMMEDIATE'", "'IN'", "'INDEX'", 
      "'INDEXED'", "'INITIALLY'", "'INNER'", "'INSERT'", "'INSTEAD'", "'INTERSECT'", 
      "'INTO'", "'IS'", "'ISNULL'", "'JOIN'", "'KEY'", "'LEFT'", "'LIKE'", 
      "'LIMIT'", "'MATCH'", "'MATERIALIZED'", "'NATURAL'", "'NO'", "'NOT'", 
      "'NOTNULL'", "'NULL'", "'OF'", "'OFFSET'", "'ON'", "'OR'", "'ORDER'", 
      "'OUTER'", "'PLAN'", "'PRAGMA'", "'PRIMARY'", "'QUERY'", "'RAISE'", 
      "'RECURSIVE'", "'REFERENCES'", "'REGEXP'", "'REINDEX'", "'RELEASE'", 
      "'RENAME'", "'REPLACE'", "'RESTRICT'", "'RETURNING'", "'RIGHT'", "'ROLLBACK'", 
      "'ROW'", "'ROWS'", "'ROWID'", "'SAVEPOINT'", "'SELECT'", "'SET'", 
      "'STRICT'", "'TABLE'", "'TEMP'", "'TEMPORARY'", "'THEN'", "'TO'", 
      "'TRANSACTION'", "'TRIGGER'", "'UNION'", "'UNIQUE'", "'UPDATE'", "'USING'", 
      "'VACUUM'", "'VALUES'", "'VIEW'", "'VIRTUAL'", "'WHEN'", "'WHERE'", 
      "'WITH'", "'WITHOUT'", "'OVER'", "'PARTITION'", "'RANGE'", "'PRECEDING'", 
      "'UNBOUNDED'", "'CURRENT'", "'FOLLOWING'", "'RANK'", "'GENERATED'", 
      "'ALWAYS'", "'STORED'", "'TRUE'", "'FALSE'", "'WINDOW'", "'NULLS'", 
      "'FIRST'", "'LAST'", "'FILTER'", "'GROUPS'", "'EXCLUDE'", "'TIES'", 
      "'OTHERS'", "'DO'", "'NOTHING'"
    },
    std::vector<std::string>{
      "", "SCOL", "DOT", "OPEN_PAR", "CLOSE_PAR", "COMMA", "ASSIGN", "STAR", 
      "PLUS", "MINUS", "TILDE", "PIPE2", "DIV", "MOD", "LT2", "GT2", "AMP", 
      "PIPE", "LT", "LT_EQ", "GT", "GT_EQ", "EQ", "NOT_EQ1", "NOT_EQ2", 
      "JPTR", "JPTR2", "ABORT_", "ACTION_", "ADD_", "AFTER_", "ALL_", "ALTER_", 
      "ANALYZE_", "AND_", "AS_", "ASC_", "ATTACH_", "AUTOINCREMENT_", "BEFORE_", 
      "BEGIN_", "BETWEEN_", "BY_", "CASCADE_", "CASE_", "CAST_", "CHECK_", 
      "COLLATE_", "COLUMN_", "COMMIT_", "CONFLICT_", "CONSTRAINT_", "CREATE_", 
      "CROSS_", "CURRENT_DATE_", "CURRENT_TIME_", "CURRENT_TIMESTAMP_", 
      "DATABASE_", "DEFAULT_", "DEFERRABLE_", "DEFERRED_", "DELETE_", "DESC_", 
      "DETACH_", "DISTINCT_", "DROP_", "EACH_", "ELSE_", "END_", "ESCAPE_", 
      "EXCEPT_", "EXCLUSIVE_", "EXISTS_", "EXPLAIN_", "FAIL_", "FOR_", "FOREIGN_", 
      "FROM_", "FULL_", "GLOB_", "GROUP_", "HAVING_", "IF_", "IGNORE_", 
      "IMMEDIATE_", "IN_", "INDEX_", "INDEXED_", "INITIALLY_", "INNER_", 
      "INSERT_", "INSTEAD_", "INTERSECT_", "INTO_", "IS_", "ISNULL_", "JOIN_", 
      "KEY_", "LEFT_", "LIKE_", "LIMIT_", "MATCH_", "MATERIALIZED_", "NATURAL_", 
      "NO_", "NOT_", "NOTNULL_", "NULL_", "OF_", "OFFSET_", "ON_", "OR_", 
      "ORDER_", "OUTER_", "PLAN_", "PRAGMA_", "PRIMARY_", "QUERY_", "RAISE_", 
      "RECURSIVE_", "REFERENCES_", "REGEXP_", "REINDEX_", "RELEASE_", "RENAME_", 
      "REPLACE_", "RESTRICT_", "RETURNING_", "RIGHT_", "ROLLBACK_", "ROW_", 
      "ROWS_", "ROWID_", "SAVEPOINT_", "SELECT_", "SET_", "STRICT_", "TABLE_", 
      "TEMP_", "TEMPORARY_", "THEN_", "TO_", "TRANSACTION_", "TRIGGER_", 
      "UNION_", "UNIQUE_", "UPDATE_", "USING_", "VACUUM_", "VALUES_", "VIEW_", 
      "VIRTUAL_", "WHEN_", "WHERE_", "WITH_", "WITHOUT_", "OVER_", "PARTITION_", 
      "RANGE_", "PRECEDING_", "UNBOUNDED_", "CURRENT_", "FOLLOWING_", "RANK_", 
      "GENERATED_", "ALWAYS_", "STORED_", "TRUE_", "FALSE_", "WINDOW_", 
      "NULLS_", "FIRST_", "LAST_", "FILTER_", "GROUPS_", "EXCLUDE_", "TIES_", 
      "OTHERS_", "DO_", "NOTHING_", "IDENTIFIER", "NUMERIC_LITERAL", "BIND_PARAMETER", 
      "STRING_LITERAL", "BLOB_LITERAL", "SINGLE_LINE_COMMENT", "MULTILINE_COMMENT", 
      "SPACES", "UNEXPECTED_CHAR"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,188,1906,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,1,0,1,0,1,0,1,1,3,1,215,8,1,1,1,1,1,3,1,219,8,1,5,1,221,8,1,10,
  	1,12,1,224,9,1,1,2,1,2,1,2,3,2,229,8,2,3,2,231,8,2,1,2,1,2,1,2,1,2,1,
  	2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
  	1,2,1,2,3,2,257,8,2,1,3,1,3,1,3,1,3,1,3,3,3,264,8,3,1,3,1,3,1,3,1,3,1,
  	3,3,3,271,8,3,1,3,1,3,1,3,1,3,3,3,277,8,3,1,3,1,3,3,3,281,8,3,1,3,1,3,
  	1,3,3,3,286,8,3,1,3,3,3,289,8,3,1,4,1,4,1,4,1,4,1,4,3,4,296,8,4,1,4,3,
  	4,299,8,4,1,5,1,5,3,5,303,8,5,1,5,1,5,1,5,1,5,1,6,1,6,3,6,311,8,6,1,6,
  	3,6,314,8,6,1,7,1,7,3,7,318,8,7,1,8,1,8,3,8,322,8,8,1,8,1,8,3,8,326,8,
  	8,1,8,3,8,329,8,8,1,9,1,9,1,9,1,10,1,10,3,10,336,8,10,1,10,1,10,1,11,
  	1,11,3,11,342,8,11,1,11,1,11,1,11,1,11,3,11,348,8,11,1,11,1,11,1,11,3,
  	11,353,8,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,5,11,362,8,11,10,11,12,
  	11,365,9,11,1,11,1,11,1,11,3,11,370,8,11,1,12,1,12,3,12,374,8,12,1,12,
  	1,12,3,12,378,8,12,1,12,3,12,381,8,12,1,13,1,13,3,13,385,8,13,1,13,1,
  	13,1,13,1,13,3,13,391,8,13,1,13,1,13,1,13,3,13,396,8,13,1,13,1,13,1,13,
  	1,13,1,13,5,13,403,8,13,10,13,12,13,406,9,13,1,13,1,13,5,13,410,8,13,
  	10,13,12,13,413,9,13,1,13,1,13,3,13,417,8,13,1,13,1,13,3,13,421,8,13,
  	1,14,1,14,1,14,3,14,426,8,14,1,14,1,14,1,14,1,14,3,14,432,8,14,5,14,434,
  	8,14,10,14,12,14,437,9,14,1,15,1,15,3,15,441,8,15,1,15,5,15,444,8,15,
  	10,15,12,15,447,9,15,1,16,4,16,450,8,16,11,16,12,16,451,1,16,1,16,1,16,
  	1,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,464,8,16,1,17,1,17,3,17,468,8,
  	17,1,17,1,17,1,17,3,17,473,8,17,1,17,3,17,476,8,17,1,17,3,17,479,8,17,
  	1,17,3,17,482,8,17,1,17,1,17,3,17,486,8,17,1,17,3,17,489,8,17,1,17,1,
  	17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,3,17,503,8,17,1,
  	17,1,17,1,17,1,17,1,17,3,17,510,8,17,1,17,1,17,1,17,1,17,1,17,3,17,517,
  	8,17,3,17,519,8,17,1,18,3,18,522,8,18,1,18,1,18,1,19,1,19,3,19,528,8,
  	19,1,19,1,19,1,19,3,19,533,8,19,1,19,1,19,1,19,1,19,5,19,539,8,19,10,
  	19,12,19,542,9,19,1,19,1,19,3,19,546,8,19,1,19,1,19,1,19,1,19,1,19,1,
  	19,1,19,1,19,1,19,1,19,1,19,5,19,559,8,19,10,19,12,19,562,9,19,1,19,1,
  	19,1,19,3,19,567,8,19,1,20,1,20,1,20,1,20,1,20,1,20,5,20,575,8,20,10,
  	20,12,20,578,9,20,1,20,1,20,3,20,582,8,20,1,20,1,20,1,20,1,20,1,20,1,
  	20,1,20,1,20,3,20,592,8,20,1,20,1,20,5,20,596,8,20,10,20,12,20,599,9,
  	20,1,20,3,20,602,8,20,1,20,1,20,1,20,3,20,607,8,20,3,20,609,8,20,1,21,
  	1,21,1,21,1,21,1,22,1,22,3,22,617,8,22,1,22,1,22,1,22,1,22,3,22,623,8,
  	22,1,22,1,22,1,22,3,22,628,8,22,1,22,1,22,1,22,1,22,1,22,3,22,635,8,22,
  	1,22,1,22,1,22,1,22,1,22,1,22,1,22,5,22,644,8,22,10,22,12,22,647,9,22,
  	3,22,649,8,22,3,22,651,8,22,1,22,1,22,1,22,1,22,1,22,3,22,658,8,22,1,
  	22,1,22,3,22,662,8,22,1,22,1,22,1,22,1,22,1,22,3,22,669,8,22,1,22,1,22,
  	4,22,673,8,22,11,22,12,22,674,1,22,1,22,1,23,1,23,3,23,681,8,23,1,23,
  	1,23,1,23,1,23,3,23,687,8,23,1,23,1,23,1,23,3,23,692,8,23,1,23,1,23,1,
  	23,1,23,1,23,5,23,699,8,23,10,23,12,23,702,9,23,1,23,1,23,3,23,706,8,
  	23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,1,24,1,24,3,24,717,8,24,1,24,1,
  	24,1,24,3,24,722,8,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,5,24,731,8,24,
  	10,24,12,24,734,9,24,1,24,1,24,3,24,738,8,24,1,25,1,25,3,25,742,8,25,
  	1,25,1,25,1,25,5,25,747,8,25,10,25,12,25,750,9,25,1,26,1,26,1,26,3,26,
  	755,8,26,1,26,3,26,758,8,26,1,26,1,26,1,26,1,26,1,27,1,27,1,27,1,27,1,
  	27,5,27,769,8,27,10,27,12,27,772,9,27,1,27,1,27,3,27,776,8,27,1,28,3,
  	28,779,8,28,1,28,1,28,1,28,1,28,1,28,3,28,786,8,28,1,28,3,28,789,8,28,
  	1,29,3,29,792,8,29,1,29,1,29,1,29,1,29,1,29,3,29,799,8,29,1,29,3,29,802,
  	8,29,1,29,3,29,805,8,29,1,29,3,29,808,8,29,1,30,1,30,3,30,812,8,30,1,
  	30,1,30,1,31,1,31,1,31,1,31,3,31,820,8,31,1,31,1,31,1,31,3,31,825,8,31,
  	1,31,1,31,1,32,1,32,1,32,1,32,1,32,1,32,3,32,835,8,32,1,32,1,32,1,32,
  	3,32,840,8,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,850,8,32,1,
  	32,1,32,1,32,5,32,855,8,32,10,32,12,32,858,9,32,1,32,3,32,861,8,32,1,
  	32,3,32,864,8,32,1,32,1,32,3,32,868,8,32,1,32,3,32,871,8,32,1,32,1,32,
  	1,32,1,32,5,32,877,8,32,10,32,12,32,880,9,32,1,32,1,32,1,32,1,32,1,32,
  	1,32,1,32,1,32,1,32,1,32,3,32,892,8,32,1,32,3,32,895,8,32,1,32,1,32,1,
  	32,1,32,1,32,1,32,3,32,903,8,32,1,32,1,32,1,32,1,32,1,32,4,32,910,8,32,
  	11,32,12,32,911,1,32,1,32,3,32,916,8,32,1,32,1,32,1,32,3,32,921,8,32,
  	1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,
  	1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,944,8,32,1,32,1,32,3,32,948,8,
  	32,1,32,1,32,1,32,3,32,953,8,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,
  	32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,971,8,32,1,32,1,32,1,
  	32,1,32,1,32,1,32,5,32,979,8,32,10,32,12,32,982,9,32,3,32,984,8,32,1,
  	32,1,32,1,32,1,32,3,32,990,8,32,1,32,1,32,1,32,1,32,3,32,996,8,32,1,32,
  	1,32,1,32,1,32,1,32,5,32,1003,8,32,10,32,12,32,1006,9,32,3,32,1008,8,
  	32,1,32,1,32,3,32,1012,8,32,1,32,1,32,3,32,1016,8,32,1,32,1,32,1,32,1,
  	32,3,32,1022,8,32,1,32,1,32,3,32,1026,8,32,1,32,1,32,1,32,1,32,1,32,3,
  	32,1033,8,32,5,32,1035,8,32,10,32,12,32,1038,9,32,1,33,1,33,1,33,1,33,
  	1,33,1,33,3,33,1046,8,33,1,33,1,33,1,34,1,34,1,35,1,35,1,35,1,35,5,35,
  	1056,8,35,10,35,12,35,1059,9,35,1,35,1,35,1,36,1,36,1,36,1,36,5,36,1067,
  	8,36,10,36,12,36,1070,9,36,1,37,3,37,1073,8,37,1,37,1,37,1,37,1,37,1,
  	37,3,37,1080,8,37,1,37,1,37,1,37,1,37,3,37,1086,8,37,1,37,1,37,1,37,3,
  	37,1091,8,37,1,37,1,37,1,37,1,37,5,37,1097,8,37,10,37,12,37,1100,9,37,
  	1,37,1,37,3,37,1104,8,37,1,37,1,37,3,37,1108,8,37,1,37,5,37,1111,8,37,
  	10,37,12,37,1114,9,37,1,37,1,37,3,37,1118,8,37,1,37,3,37,1121,8,37,1,
  	38,1,38,1,38,1,38,3,38,1127,8,38,1,38,3,38,1130,8,38,3,38,1132,8,38,1,
  	38,1,38,1,38,1,38,3,38,1138,8,38,1,38,3,38,1141,8,38,3,38,1143,8,38,5,
  	38,1145,8,38,10,38,12,38,1148,9,38,1,39,1,39,1,39,1,39,1,39,1,39,5,39,
  	1156,8,39,10,39,12,39,1159,9,39,1,39,1,39,1,39,3,39,1164,8,39,3,39,1166,
  	8,39,1,39,1,39,1,39,1,39,1,39,1,39,3,39,1174,8,39,1,39,1,39,1,39,1,39,
  	1,39,3,39,1181,8,39,1,39,1,39,1,39,5,39,1186,8,39,10,39,12,39,1189,9,
  	39,1,39,1,39,3,39,1193,8,39,3,39,1195,8,39,1,40,1,40,1,40,1,40,3,40,1201,
  	8,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,3,40,1210,8,40,1,41,1,41,1,41,
  	3,41,1215,8,41,1,42,1,42,1,42,1,42,1,42,3,42,1222,8,42,1,42,1,42,3,42,
  	1226,8,42,3,42,1228,8,42,1,43,3,43,1231,8,43,1,43,1,43,1,43,1,43,5,43,
  	1237,8,43,10,43,12,43,1240,9,43,1,43,3,43,1243,8,43,1,43,3,43,1246,8,
  	43,1,44,1,44,1,44,1,44,3,44,1252,8,44,5,44,1254,8,44,10,44,12,44,1257,
  	9,44,1,45,1,45,3,45,1261,8,45,1,45,1,45,1,45,5,45,1266,8,45,10,45,12,
  	45,1269,9,45,1,45,1,45,1,45,1,45,5,45,1275,8,45,10,45,12,45,1278,9,45,
  	1,45,3,45,1281,8,45,3,45,1283,8,45,1,45,1,45,3,45,1287,8,45,1,45,1,45,
  	1,45,1,45,1,45,5,45,1294,8,45,10,45,12,45,1297,9,45,1,45,1,45,3,45,1301,
  	8,45,3,45,1303,8,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,5,45,
  	1314,8,45,10,45,12,45,1317,9,45,3,45,1319,8,45,1,45,3,45,1322,8,45,1,
  	46,1,46,1,46,3,46,1327,8,46,1,46,1,46,3,46,1331,8,46,1,46,3,46,1334,8,
  	46,1,46,1,46,1,46,1,46,1,46,3,46,1341,8,46,1,46,1,46,1,46,3,46,1346,8,
  	46,1,46,1,46,1,46,1,46,1,46,5,46,1353,8,46,10,46,12,46,1356,9,46,1,46,
  	1,46,3,46,1360,8,46,1,46,3,46,1363,8,46,1,46,1,46,1,46,1,46,5,46,1369,
  	8,46,10,46,12,46,1372,9,46,1,46,3,46,1375,8,46,1,46,1,46,1,46,1,46,1,
  	46,1,46,3,46,1383,8,46,1,46,3,46,1386,8,46,3,46,1388,8,46,1,47,1,47,1,
  	47,1,47,1,47,1,47,1,47,3,47,1397,8,47,1,47,3,47,1400,8,47,3,47,1402,8,
  	47,1,48,1,48,3,48,1406,8,48,1,48,1,48,3,48,1410,8,48,1,48,1,48,3,48,1414,
  	8,48,1,48,3,48,1417,8,48,1,49,1,49,1,49,1,49,1,49,1,49,1,49,5,49,1426,
  	8,49,10,49,12,49,1429,9,49,1,49,1,49,3,49,1433,8,49,1,50,1,50,3,50,1437,
  	8,50,1,50,1,50,3,50,1441,8,50,1,51,3,51,1444,8,51,1,51,1,51,1,51,3,51,
  	1449,8,51,1,51,1,51,1,51,1,51,3,51,1455,8,51,1,51,1,51,1,51,1,51,1,51,
  	3,51,1462,8,51,1,51,1,51,1,51,5,51,1467,8,51,10,51,12,51,1470,9,51,1,
  	51,1,51,1,51,1,51,5,51,1476,8,51,10,51,12,51,1479,9,51,1,51,3,51,1482,
  	8,51,3,51,1484,8,51,1,51,1,51,3,51,1488,8,51,1,51,3,51,1491,8,51,1,52,
  	1,52,1,52,1,52,5,52,1497,8,52,10,52,12,52,1500,9,52,1,52,1,52,1,53,3,
  	53,1505,8,53,1,53,1,53,1,53,3,53,1510,8,53,1,53,1,53,1,53,1,53,3,53,1516,
  	8,53,1,53,1,53,1,53,1,53,1,53,3,53,1523,8,53,1,53,1,53,1,53,5,53,1528,
  	8,53,10,53,12,53,1531,9,53,1,53,1,53,1,53,1,53,5,53,1537,8,53,10,53,12,
  	53,1540,9,53,1,53,3,53,1543,8,53,3,53,1545,8,53,1,53,1,53,3,53,1549,8,
  	53,1,53,3,53,1552,8,53,1,53,3,53,1555,8,53,1,53,3,53,1558,8,53,1,54,1,
  	54,1,54,3,54,1563,8,54,1,54,1,54,1,54,3,54,1568,8,54,1,54,1,54,1,54,1,
  	54,1,54,3,54,1575,8,54,1,55,1,55,3,55,1579,8,55,1,55,1,55,3,55,1583,8,
  	55,1,56,1,56,1,56,1,56,1,56,1,56,1,57,1,57,3,57,1593,8,57,1,57,1,57,1,
  	57,1,57,1,57,5,57,1600,8,57,10,57,12,57,1603,9,57,3,57,1605,8,57,1,57,
  	3,57,1608,8,57,1,57,3,57,1611,8,57,1,57,1,57,1,58,1,58,1,58,1,58,3,58,
  	1619,8,58,1,58,1,58,1,58,1,58,1,58,5,58,1626,8,58,10,58,12,58,1629,9,
  	58,3,58,1631,8,58,1,58,3,58,1634,8,58,1,58,3,58,1637,8,58,1,58,3,58,1640,
  	8,58,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,3,59,1650,8,59,3,59,1652,
  	8,59,1,60,1,60,1,60,1,60,1,60,1,60,1,60,3,60,1661,8,60,1,61,1,61,1,61,
  	1,61,1,61,5,61,1668,8,61,10,61,12,61,1671,9,61,1,62,1,62,1,62,1,62,3,
  	62,1677,8,62,1,63,1,63,1,63,3,63,1682,8,63,1,63,3,63,1685,8,63,1,63,1,
  	63,3,63,1689,8,63,1,64,1,64,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
  	65,1,65,3,65,1703,8,65,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,
  	66,3,66,1715,8,66,1,67,1,67,1,67,1,67,1,67,1,67,1,67,3,67,1724,8,67,1,
  	68,1,68,1,69,1,69,1,70,1,70,1,70,5,70,1733,8,70,10,70,12,70,1736,9,70,
  	1,70,4,70,1739,8,70,11,70,12,70,1740,1,71,1,71,1,72,1,72,1,73,1,73,1,
  	74,1,74,1,75,1,75,1,76,1,76,1,77,1,77,1,78,1,78,1,79,1,79,1,80,1,80,1,
  	81,1,81,1,82,1,82,1,83,1,83,1,84,1,84,1,85,1,85,1,86,1,86,1,87,1,87,1,
  	88,1,88,1,89,1,89,1,90,1,90,1,91,1,91,1,92,1,92,1,93,3,93,1788,8,93,1,
  	93,1,93,3,93,1792,8,93,1,93,3,93,1795,8,93,1,94,3,94,1798,8,94,1,94,1,
  	94,1,94,3,94,1803,8,94,1,94,1,94,3,94,1807,8,94,1,94,4,94,1810,8,94,11,
  	94,12,94,1811,1,94,3,94,1815,8,94,1,94,3,94,1818,8,94,1,95,1,95,1,95,
  	1,95,1,95,1,95,3,95,1826,8,95,1,95,1,95,1,95,1,96,1,96,1,97,1,97,1,98,
  	1,98,1,98,1,98,1,98,5,98,1840,8,98,10,98,12,98,1843,9,98,1,98,3,98,1846,
  	8,98,1,98,1,98,1,99,1,99,1,99,3,99,1853,8,99,1,99,1,99,1,99,5,99,1858,
  	8,99,10,99,12,99,1861,9,99,1,99,3,99,1864,8,99,1,99,3,99,1867,8,99,1,
  	99,1,99,3,99,1871,8,99,1,100,1,100,1,100,1,100,1,100,5,100,1878,8,100,
  	10,100,12,100,1881,9,100,1,100,3,100,1884,8,100,1,100,1,100,3,100,1888,
  	8,100,1,100,1,100,1,100,3,100,1893,8,100,1,101,1,101,1,102,1,102,1,103,
  	1,103,1,104,1,104,1,104,3,104,1904,8,104,1,104,4,404,440,451,1740,1,64,
  	105,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,
  	48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,
  	94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,
  	130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,
  	166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,
  	202,204,206,208,0,27,3,0,60,60,71,71,84,84,2,0,49,49,68,68,1,0,138,139,
  	2,0,151,151,166,166,1,0,8,9,2,0,61,61,146,146,2,0,58,58,107,107,2,0,60,
  	60,84,84,5,0,27,27,74,74,83,83,125,125,129,129,4,0,86,86,137,137,143,
  	143,150,150,1,0,8,10,2,0,11,11,25,26,2,0,7,7,12,13,1,0,14,17,1,0,18,21,
  	2,0,6,6,22,24,3,0,79,79,101,101,121,121,3,0,27,27,74,74,129,129,5,0,54,
  	56,107,107,167,168,181,181,183,184,2,0,31,31,64,64,3,0,78,78,98,98,128,
  	128,3,0,131,131,158,158,174,174,2,0,5,5,109,109,1,0,171,172,2,0,36,36,
  	62,62,1,0,3,4,1,0,27,179,2177,0,210,1,0,0,0,2,214,1,0,0,0,4,230,1,0,0,
  	0,6,258,1,0,0,0,8,290,1,0,0,0,10,300,1,0,0,0,12,308,1,0,0,0,14,315,1,
  	0,0,0,16,319,1,0,0,0,18,330,1,0,0,0,20,333,1,0,0,0,22,339,1,0,0,0,24,
  	373,1,0,0,0,26,382,1,0,0,0,28,425,1,0,0,0,30,438,1,0,0,0,32,449,1,0,0,
  	0,34,467,1,0,0,0,36,521,1,0,0,0,38,527,1,0,0,0,40,568,1,0,0,0,42,610,
  	1,0,0,0,44,614,1,0,0,0,46,678,1,0,0,0,48,710,1,0,0,0,50,739,1,0,0,0,52,
  	751,1,0,0,0,54,763,1,0,0,0,56,778,1,0,0,0,58,791,1,0,0,0,60,809,1,0,0,
  	0,62,815,1,0,0,0,64,920,1,0,0,0,66,1039,1,0,0,0,68,1049,1,0,0,0,70,1051,
  	1,0,0,0,72,1062,1,0,0,0,74,1072,1,0,0,0,76,1122,1,0,0,0,78,1149,1,0,0,
  	0,80,1196,1,0,0,0,82,1214,1,0,0,0,84,1216,1,0,0,0,86,1230,1,0,0,0,88,
  	1247,1,0,0,0,90,1321,1,0,0,0,92,1387,1,0,0,0,94,1401,1,0,0,0,96,1416,
  	1,0,0,0,98,1432,1,0,0,0,100,1440,1,0,0,0,102,1443,1,0,0,0,104,1492,1,
  	0,0,0,106,1504,1,0,0,0,108,1562,1,0,0,0,110,1576,1,0,0,0,112,1584,1,0,
  	0,0,114,1590,1,0,0,0,116,1614,1,0,0,0,118,1641,1,0,0,0,120,1653,1,0,0,
  	0,122,1662,1,0,0,0,124,1672,1,0,0,0,126,1678,1,0,0,0,128,1690,1,0,0,0,
  	130,1702,1,0,0,0,132,1714,1,0,0,0,134,1723,1,0,0,0,136,1725,1,0,0,0,138,
  	1727,1,0,0,0,140,1738,1,0,0,0,142,1742,1,0,0,0,144,1744,1,0,0,0,146,1746,
  	1,0,0,0,148,1748,1,0,0,0,150,1750,1,0,0,0,152,1752,1,0,0,0,154,1754,1,
  	0,0,0,156,1756,1,0,0,0,158,1758,1,0,0,0,160,1760,1,0,0,0,162,1762,1,0,
  	0,0,164,1764,1,0,0,0,166,1766,1,0,0,0,168,1768,1,0,0,0,170,1770,1,0,0,
  	0,172,1772,1,0,0,0,174,1774,1,0,0,0,176,1776,1,0,0,0,178,1778,1,0,0,0,
  	180,1780,1,0,0,0,182,1782,1,0,0,0,184,1784,1,0,0,0,186,1787,1,0,0,0,188,
  	1797,1,0,0,0,190,1819,1,0,0,0,192,1830,1,0,0,0,194,1832,1,0,0,0,196,1834,
  	1,0,0,0,198,1849,1,0,0,0,200,1872,1,0,0,0,202,1894,1,0,0,0,204,1896,1,
  	0,0,0,206,1898,1,0,0,0,208,1903,1,0,0,0,210,211,3,2,1,0,211,212,5,0,0,
  	1,212,1,1,0,0,0,213,215,3,4,2,0,214,213,1,0,0,0,214,215,1,0,0,0,215,222,
  	1,0,0,0,216,218,5,1,0,0,217,219,3,4,2,0,218,217,1,0,0,0,218,219,1,0,0,
  	0,219,221,1,0,0,0,220,216,1,0,0,0,221,224,1,0,0,0,222,220,1,0,0,0,222,
  	223,1,0,0,0,223,3,1,0,0,0,224,222,1,0,0,0,225,228,5,73,0,0,226,227,5,
  	117,0,0,227,229,5,114,0,0,228,226,1,0,0,0,228,229,1,0,0,0,229,231,1,0,
  	0,0,230,225,1,0,0,0,230,231,1,0,0,0,231,256,1,0,0,0,232,257,3,6,3,0,233,
  	257,3,8,4,0,234,257,3,10,5,0,235,257,3,12,6,0,236,257,3,14,7,0,237,257,
  	3,22,11,0,238,257,3,26,13,0,239,257,3,44,22,0,240,257,3,46,23,0,241,257,
  	3,48,24,0,242,257,3,56,28,0,243,257,3,58,29,0,244,257,3,60,30,0,245,257,
  	3,62,31,0,246,257,3,74,37,0,247,257,3,80,40,0,248,257,3,84,42,0,249,257,
  	3,20,10,0,250,257,3,16,8,0,251,257,3,18,9,0,252,257,3,86,43,0,253,257,
  	3,102,51,0,254,257,3,106,53,0,255,257,3,110,55,0,256,232,1,0,0,0,256,
  	233,1,0,0,0,256,234,1,0,0,0,256,235,1,0,0,0,256,236,1,0,0,0,256,237,1,
  	0,0,0,256,238,1,0,0,0,256,239,1,0,0,0,256,240,1,0,0,0,256,241,1,0,0,0,
  	256,242,1,0,0,0,256,243,1,0,0,0,256,244,1,0,0,0,256,245,1,0,0,0,256,246,
  	1,0,0,0,256,247,1,0,0,0,256,248,1,0,0,0,256,249,1,0,0,0,256,250,1,0,0,
  	0,256,251,1,0,0,0,256,252,1,0,0,0,256,253,1,0,0,0,256,254,1,0,0,0,256,
  	255,1,0,0,0,257,5,1,0,0,0,258,259,5,32,0,0,259,263,5,137,0,0,260,261,
  	3,148,74,0,261,262,5,2,0,0,262,264,1,0,0,0,263,260,1,0,0,0,263,264,1,
  	0,0,0,264,265,1,0,0,0,265,288,3,150,75,0,266,276,5,124,0,0,267,268,5,
  	141,0,0,268,277,3,150,75,0,269,271,5,48,0,0,270,269,1,0,0,0,270,271,1,
  	0,0,0,271,272,1,0,0,0,272,273,3,154,77,0,273,274,5,141,0,0,274,275,3,
  	154,77,0,275,277,1,0,0,0,276,267,1,0,0,0,276,270,1,0,0,0,277,289,1,0,
  	0,0,278,280,5,29,0,0,279,281,5,48,0,0,280,279,1,0,0,0,280,281,1,0,0,0,
  	281,282,1,0,0,0,282,289,3,30,15,0,283,285,5,65,0,0,284,286,5,48,0,0,285,
  	284,1,0,0,0,285,286,1,0,0,0,286,287,1,0,0,0,287,289,3,154,77,0,288,266,
  	1,0,0,0,288,278,1,0,0,0,288,283,1,0,0,0,289,7,1,0,0,0,290,298,5,33,0,
  	0,291,299,3,148,74,0,292,293,3,148,74,0,293,294,5,2,0,0,294,296,1,0,0,
  	0,295,292,1,0,0,0,295,296,1,0,0,0,296,297,1,0,0,0,297,299,3,152,76,0,
  	298,291,1,0,0,0,298,295,1,0,0,0,298,299,1,0,0,0,299,9,1,0,0,0,300,302,
  	5,37,0,0,301,303,5,57,0,0,302,301,1,0,0,0,302,303,1,0,0,0,303,304,1,0,
  	0,0,304,305,3,64,32,0,305,306,5,35,0,0,306,307,3,148,74,0,307,11,1,0,
  	0,0,308,310,5,40,0,0,309,311,7,0,0,0,310,309,1,0,0,0,310,311,1,0,0,0,
  	311,313,1,0,0,0,312,314,5,142,0,0,313,312,1,0,0,0,313,314,1,0,0,0,314,
  	13,1,0,0,0,315,317,7,1,0,0,316,318,5,142,0,0,317,316,1,0,0,0,317,318,
  	1,0,0,0,318,15,1,0,0,0,319,321,5,129,0,0,320,322,5,142,0,0,321,320,1,
  	0,0,0,321,322,1,0,0,0,322,328,1,0,0,0,323,325,5,141,0,0,324,326,5,133,
  	0,0,325,324,1,0,0,0,325,326,1,0,0,0,326,327,1,0,0,0,327,329,3,172,86,
  	0,328,323,1,0,0,0,328,329,1,0,0,0,329,17,1,0,0,0,330,331,5,133,0,0,331,
  	332,3,172,86,0,332,19,1,0,0,0,333,335,5,123,0,0,334,336,5,133,0,0,335,
  	334,1,0,0,0,335,336,1,0,0,0,336,337,1,0,0,0,337,338,3,172,86,0,338,21,
  	1,0,0,0,339,341,5,52,0,0,340,342,5,145,0,0,341,340,1,0,0,0,341,342,1,
  	0,0,0,342,343,1,0,0,0,343,347,5,86,0,0,344,345,5,82,0,0,345,346,5,105,
  	0,0,346,348,5,72,0,0,347,344,1,0,0,0,347,348,1,0,0,0,348,352,1,0,0,0,
  	349,350,3,148,74,0,350,351,5,2,0,0,351,353,1,0,0,0,352,349,1,0,0,0,352,
  	353,1,0,0,0,353,354,1,0,0,0,354,355,3,162,81,0,355,356,5,110,0,0,356,
  	357,3,150,75,0,357,358,5,3,0,0,358,363,3,24,12,0,359,360,5,5,0,0,360,
  	362,3,24,12,0,361,359,1,0,0,0,362,365,1,0,0,0,363,361,1,0,0,0,363,364,
  	1,0,0,0,364,366,1,0,0,0,365,363,1,0,0,0,366,369,5,4,0,0,367,368,5,153,
  	0,0,368,370,3,64,32,0,369,367,1,0,0,0,369,370,1,0,0,0,370,23,1,0,0,0,
  	371,374,3,154,77,0,372,374,3,64,32,0,373,371,1,0,0,0,373,372,1,0,0,0,
  	374,377,1,0,0,0,375,376,5,47,0,0,376,378,3,158,79,0,377,375,1,0,0,0,377,
  	378,1,0,0,0,378,380,1,0,0,0,379,381,3,128,64,0,380,379,1,0,0,0,380,381,
  	1,0,0,0,381,25,1,0,0,0,382,384,5,52,0,0,383,385,7,2,0,0,384,383,1,0,0,
  	0,384,385,1,0,0,0,385,386,1,0,0,0,386,390,5,137,0,0,387,388,5,82,0,0,
  	388,389,5,105,0,0,389,391,5,72,0,0,390,387,1,0,0,0,390,391,1,0,0,0,391,
  	395,1,0,0,0,392,393,3,148,74,0,393,394,5,2,0,0,394,396,1,0,0,0,395,392,
  	1,0,0,0,395,396,1,0,0,0,396,397,1,0,0,0,397,420,3,150,75,0,398,399,5,
  	3,0,0,399,404,3,30,15,0,400,401,5,5,0,0,401,403,3,30,15,0,402,400,1,0,
  	0,0,403,406,1,0,0,0,404,405,1,0,0,0,404,402,1,0,0,0,405,411,1,0,0,0,406,
  	404,1,0,0,0,407,408,5,5,0,0,408,410,3,38,19,0,409,407,1,0,0,0,410,413,
  	1,0,0,0,411,409,1,0,0,0,411,412,1,0,0,0,412,414,1,0,0,0,413,411,1,0,0,
  	0,414,416,5,4,0,0,415,417,3,28,14,0,416,415,1,0,0,0,416,417,1,0,0,0,417,
  	421,1,0,0,0,418,419,5,35,0,0,419,421,3,86,43,0,420,398,1,0,0,0,420,418,
  	1,0,0,0,421,27,1,0,0,0,422,423,5,155,0,0,423,426,5,132,0,0,424,426,5,
  	136,0,0,425,422,1,0,0,0,425,424,1,0,0,0,426,435,1,0,0,0,427,431,5,5,0,
  	0,428,429,5,155,0,0,429,432,5,132,0,0,430,432,5,136,0,0,431,428,1,0,0,
  	0,431,430,1,0,0,0,432,434,1,0,0,0,433,427,1,0,0,0,434,437,1,0,0,0,435,
  	433,1,0,0,0,435,436,1,0,0,0,436,29,1,0,0,0,437,435,1,0,0,0,438,440,3,
  	154,77,0,439,441,3,32,16,0,440,441,1,0,0,0,440,439,1,0,0,0,441,445,1,
  	0,0,0,442,444,3,34,17,0,443,442,1,0,0,0,444,447,1,0,0,0,445,443,1,0,0,
  	0,445,446,1,0,0,0,446,31,1,0,0,0,447,445,1,0,0,0,448,450,3,144,72,0,449,
  	448,1,0,0,0,450,451,1,0,0,0,451,452,1,0,0,0,451,449,1,0,0,0,452,463,1,
  	0,0,0,453,454,5,3,0,0,454,455,3,36,18,0,455,456,5,4,0,0,456,464,1,0,0,
  	0,457,458,5,3,0,0,458,459,3,36,18,0,459,460,5,5,0,0,460,461,3,36,18,0,
  	461,462,5,4,0,0,462,464,1,0,0,0,463,453,1,0,0,0,463,457,1,0,0,0,463,464,
  	1,0,0,0,464,33,1,0,0,0,465,466,5,51,0,0,466,468,3,144,72,0,467,465,1,
  	0,0,0,467,468,1,0,0,0,468,518,1,0,0,0,469,470,5,116,0,0,470,472,5,97,
  	0,0,471,473,3,128,64,0,472,471,1,0,0,0,472,473,1,0,0,0,473,475,1,0,0,
  	0,474,476,3,42,21,0,475,474,1,0,0,0,475,476,1,0,0,0,476,478,1,0,0,0,477,
  	479,5,38,0,0,478,477,1,0,0,0,478,479,1,0,0,0,479,519,1,0,0,0,480,482,
  	5,105,0,0,481,480,1,0,0,0,481,482,1,0,0,0,482,483,1,0,0,0,483,486,5,107,
  	0,0,484,486,5,145,0,0,485,481,1,0,0,0,485,484,1,0,0,0,486,488,1,0,0,0,
  	487,489,3,42,21,0,488,487,1,0,0,0,488,489,1,0,0,0,489,519,1,0,0,0,490,
  	491,5,46,0,0,491,492,5,3,0,0,492,493,3,64,32,0,493,494,5,4,0,0,494,519,
  	1,0,0,0,495,502,5,58,0,0,496,503,3,36,18,0,497,503,3,68,34,0,498,499,
  	5,3,0,0,499,500,3,64,32,0,500,501,5,4,0,0,501,503,1,0,0,0,502,496,1,0,
  	0,0,502,497,1,0,0,0,502,498,1,0,0,0,503,519,1,0,0,0,504,505,5,47,0,0,
  	505,519,3,158,79,0,506,519,3,40,20,0,507,508,5,164,0,0,508,510,5,165,
  	0,0,509,507,1,0,0,0,509,510,1,0,0,0,510,511,1,0,0,0,511,512,5,35,0,0,
  	512,513,5,3,0,0,513,514,3,64,32,0,514,516,5,4,0,0,515,517,7,3,0,0,516,
  	515,1,0,0,0,516,517,1,0,0,0,517,519,1,0,0,0,518,469,1,0,0,0,518,485,1,
  	0,0,0,518,490,1,0,0,0,518,495,1,0,0,0,518,504,1,0,0,0,518,506,1,0,0,0,
  	518,509,1,0,0,0,519,35,1,0,0,0,520,522,7,4,0,0,521,520,1,0,0,0,521,522,
  	1,0,0,0,522,523,1,0,0,0,523,524,5,181,0,0,524,37,1,0,0,0,525,526,5,51,
  	0,0,526,528,3,144,72,0,527,525,1,0,0,0,527,528,1,0,0,0,528,566,1,0,0,
  	0,529,530,5,116,0,0,530,533,5,97,0,0,531,533,5,145,0,0,532,529,1,0,0,
  	0,532,531,1,0,0,0,533,534,1,0,0,0,534,535,5,3,0,0,535,540,3,24,12,0,536,
  	537,5,5,0,0,537,539,3,24,12,0,538,536,1,0,0,0,539,542,1,0,0,0,540,538,
  	1,0,0,0,540,541,1,0,0,0,541,543,1,0,0,0,542,540,1,0,0,0,543,545,5,4,0,
  	0,544,546,3,42,21,0,545,544,1,0,0,0,545,546,1,0,0,0,546,567,1,0,0,0,547,
  	548,5,46,0,0,548,549,5,3,0,0,549,550,3,64,32,0,550,551,5,4,0,0,551,567,
  	1,0,0,0,552,553,5,76,0,0,553,554,5,97,0,0,554,555,5,3,0,0,555,560,3,154,
  	77,0,556,557,5,5,0,0,557,559,3,154,77,0,558,556,1,0,0,0,559,562,1,0,0,
  	0,560,558,1,0,0,0,560,561,1,0,0,0,561,563,1,0,0,0,562,560,1,0,0,0,563,
  	564,5,4,0,0,564,565,3,40,20,0,565,567,1,0,0,0,566,532,1,0,0,0,566,547,
  	1,0,0,0,566,552,1,0,0,0,567,39,1,0,0,0,568,569,5,120,0,0,569,581,3,160,
  	80,0,570,571,5,3,0,0,571,576,3,154,77,0,572,573,5,5,0,0,573,575,3,154,
  	77,0,574,572,1,0,0,0,575,578,1,0,0,0,576,574,1,0,0,0,576,577,1,0,0,0,
  	577,579,1,0,0,0,578,576,1,0,0,0,579,580,5,4,0,0,580,582,1,0,0,0,581,570,
  	1,0,0,0,581,582,1,0,0,0,582,597,1,0,0,0,583,584,5,110,0,0,584,591,7,5,
  	0,0,585,586,5,135,0,0,586,592,7,6,0,0,587,592,5,43,0,0,588,592,5,126,
  	0,0,589,590,5,104,0,0,590,592,5,28,0,0,591,585,1,0,0,0,591,587,1,0,0,
  	0,591,588,1,0,0,0,591,589,1,0,0,0,592,596,1,0,0,0,593,594,5,101,0,0,594,
  	596,3,144,72,0,595,583,1,0,0,0,595,593,1,0,0,0,596,599,1,0,0,0,597,595,
  	1,0,0,0,597,598,1,0,0,0,598,608,1,0,0,0,599,597,1,0,0,0,600,602,5,105,
  	0,0,601,600,1,0,0,0,601,602,1,0,0,0,602,603,1,0,0,0,603,606,5,59,0,0,
  	604,605,5,88,0,0,605,607,7,7,0,0,606,604,1,0,0,0,606,607,1,0,0,0,607,
  	609,1,0,0,0,608,601,1,0,0,0,608,609,1,0,0,0,609,41,1,0,0,0,610,611,5,
  	110,0,0,611,612,5,50,0,0,612,613,7,8,0,0,613,43,1,0,0,0,614,616,5,52,
  	0,0,615,617,7,2,0,0,616,615,1,0,0,0,616,617,1,0,0,0,617,618,1,0,0,0,618,
  	622,5,143,0,0,619,620,5,82,0,0,620,621,5,105,0,0,621,623,5,72,0,0,622,
  	619,1,0,0,0,622,623,1,0,0,0,623,627,1,0,0,0,624,625,3,148,74,0,625,626,
  	5,2,0,0,626,628,1,0,0,0,627,624,1,0,0,0,627,628,1,0,0,0,628,629,1,0,0,
  	0,629,634,3,164,82,0,630,635,5,39,0,0,631,635,5,30,0,0,632,633,5,91,0,
  	0,633,635,5,108,0,0,634,630,1,0,0,0,634,631,1,0,0,0,634,632,1,0,0,0,634,
  	635,1,0,0,0,635,650,1,0,0,0,636,651,5,61,0,0,637,651,5,90,0,0,638,648,
  	5,146,0,0,639,640,5,108,0,0,640,645,3,154,77,0,641,642,5,5,0,0,642,644,
  	3,154,77,0,643,641,1,0,0,0,644,647,1,0,0,0,645,643,1,0,0,0,645,646,1,
  	0,0,0,646,649,1,0,0,0,647,645,1,0,0,0,648,639,1,0,0,0,648,649,1,0,0,0,
  	649,651,1,0,0,0,650,636,1,0,0,0,650,637,1,0,0,0,650,638,1,0,0,0,651,652,
  	1,0,0,0,652,653,5,110,0,0,653,657,3,150,75,0,654,655,5,75,0,0,655,656,
  	5,66,0,0,656,658,5,130,0,0,657,654,1,0,0,0,657,658,1,0,0,0,658,661,1,
  	0,0,0,659,660,5,152,0,0,660,662,3,64,32,0,661,659,1,0,0,0,661,662,1,0,
  	0,0,662,663,1,0,0,0,663,672,5,40,0,0,664,669,3,102,51,0,665,669,3,74,
  	37,0,666,669,3,56,28,0,667,669,3,86,43,0,668,664,1,0,0,0,668,665,1,0,
  	0,0,668,666,1,0,0,0,668,667,1,0,0,0,669,670,1,0,0,0,670,671,5,1,0,0,671,
  	673,1,0,0,0,672,668,1,0,0,0,673,674,1,0,0,0,674,672,1,0,0,0,674,675,1,
  	0,0,0,675,676,1,0,0,0,676,677,5,68,0,0,677,45,1,0,0,0,678,680,5,52,0,
  	0,679,681,7,2,0,0,680,679,1,0,0,0,680,681,1,0,0,0,681,682,1,0,0,0,682,
  	686,5,150,0,0,683,684,5,82,0,0,684,685,5,105,0,0,685,687,5,72,0,0,686,
  	683,1,0,0,0,686,687,1,0,0,0,687,691,1,0,0,0,688,689,3,148,74,0,689,690,
  	5,2,0,0,690,692,1,0,0,0,691,688,1,0,0,0,691,692,1,0,0,0,692,693,1,0,0,
  	0,693,705,3,166,83,0,694,695,5,3,0,0,695,700,3,154,77,0,696,697,5,5,0,
  	0,697,699,3,154,77,0,698,696,1,0,0,0,699,702,1,0,0,0,700,698,1,0,0,0,
  	700,701,1,0,0,0,701,703,1,0,0,0,702,700,1,0,0,0,703,704,5,4,0,0,704,706,
  	1,0,0,0,705,694,1,0,0,0,705,706,1,0,0,0,706,707,1,0,0,0,707,708,5,35,
  	0,0,708,709,3,86,43,0,709,47,1,0,0,0,710,711,5,52,0,0,711,712,5,151,0,
  	0,712,716,5,137,0,0,713,714,5,82,0,0,714,715,5,105,0,0,715,717,5,72,0,
  	0,716,713,1,0,0,0,716,717,1,0,0,0,717,721,1,0,0,0,718,719,3,148,74,0,
  	719,720,5,2,0,0,720,722,1,0,0,0,721,718,1,0,0,0,721,722,1,0,0,0,722,723,
  	1,0,0,0,723,724,3,150,75,0,724,725,5,147,0,0,725,737,3,168,84,0,726,727,
  	5,3,0,0,727,732,3,140,70,0,728,729,5,5,0,0,729,731,3,140,70,0,730,728,
  	1,0,0,0,731,734,1,0,0,0,732,730,1,0,0,0,732,733,1,0,0,0,733,735,1,0,0,
  	0,734,732,1,0,0,0,735,736,5,4,0,0,736,738,1,0,0,0,737,726,1,0,0,0,737,
  	738,1,0,0,0,738,49,1,0,0,0,739,741,5,154,0,0,740,742,5,119,0,0,741,740,
  	1,0,0,0,741,742,1,0,0,0,742,743,1,0,0,0,743,748,3,52,26,0,744,745,5,5,
  	0,0,745,747,3,52,26,0,746,744,1,0,0,0,747,750,1,0,0,0,748,746,1,0,0,0,
  	748,749,1,0,0,0,749,51,1,0,0,0,750,748,1,0,0,0,751,752,3,54,27,0,752,
  	757,5,35,0,0,753,755,5,105,0,0,754,753,1,0,0,0,754,755,1,0,0,0,755,756,
  	1,0,0,0,756,758,5,102,0,0,757,754,1,0,0,0,757,758,1,0,0,0,758,759,1,0,
  	0,0,759,760,5,3,0,0,760,761,3,86,43,0,761,762,5,4,0,0,762,53,1,0,0,0,
  	763,775,3,150,75,0,764,765,5,3,0,0,765,770,3,154,77,0,766,767,5,5,0,0,
  	767,769,3,154,77,0,768,766,1,0,0,0,769,772,1,0,0,0,770,768,1,0,0,0,770,
  	771,1,0,0,0,771,773,1,0,0,0,772,770,1,0,0,0,773,774,5,4,0,0,774,776,1,
  	0,0,0,775,764,1,0,0,0,775,776,1,0,0,0,776,55,1,0,0,0,777,779,3,50,25,
  	0,778,777,1,0,0,0,778,779,1,0,0,0,779,780,1,0,0,0,780,781,5,61,0,0,781,
  	782,5,77,0,0,782,785,3,108,54,0,783,784,5,153,0,0,784,786,3,64,32,0,785,
  	783,1,0,0,0,785,786,1,0,0,0,786,788,1,0,0,0,787,789,3,76,38,0,788,787,
  	1,0,0,0,788,789,1,0,0,0,789,57,1,0,0,0,790,792,3,50,25,0,791,790,1,0,
  	0,0,791,792,1,0,0,0,792,793,1,0,0,0,793,794,5,61,0,0,794,795,5,77,0,0,
  	795,798,3,108,54,0,796,797,5,153,0,0,797,799,3,64,32,0,798,796,1,0,0,
  	0,798,799,1,0,0,0,799,801,1,0,0,0,800,802,3,76,38,0,801,800,1,0,0,0,801,
  	802,1,0,0,0,802,804,1,0,0,0,803,805,3,122,61,0,804,803,1,0,0,0,804,805,
  	1,0,0,0,805,807,1,0,0,0,806,808,3,124,62,0,807,806,1,0,0,0,807,808,1,
  	0,0,0,808,59,1,0,0,0,809,811,5,63,0,0,810,812,5,57,0,0,811,810,1,0,0,
  	0,811,812,1,0,0,0,812,813,1,0,0,0,813,814,3,148,74,0,814,61,1,0,0,0,815,
  	816,5,65,0,0,816,819,7,9,0,0,817,818,5,82,0,0,818,820,5,72,0,0,819,817,
  	1,0,0,0,819,820,1,0,0,0,820,824,1,0,0,0,821,822,3,148,74,0,822,823,5,
  	2,0,0,823,825,1,0,0,0,824,821,1,0,0,0,824,825,1,0,0,0,825,826,1,0,0,0,
  	826,827,3,208,104,0,827,63,1,0,0,0,828,829,6,32,-1,0,829,921,3,68,34,
  	0,830,921,5,182,0,0,831,832,3,148,74,0,832,833,5,2,0,0,833,835,1,0,0,
  	0,834,831,1,0,0,0,834,835,1,0,0,0,835,836,1,0,0,0,836,837,3,150,75,0,
  	837,838,5,2,0,0,838,840,1,0,0,0,839,834,1,0,0,0,839,840,1,0,0,0,840,841,
  	1,0,0,0,841,921,3,154,77,0,842,843,7,10,0,0,843,921,3,64,32,22,844,845,
  	5,105,0,0,845,921,3,64,32,9,846,847,3,146,73,0,847,863,5,3,0,0,848,850,
  	5,64,0,0,849,848,1,0,0,0,849,850,1,0,0,0,850,851,1,0,0,0,851,856,3,64,
  	32,0,852,853,5,5,0,0,853,855,3,64,32,0,854,852,1,0,0,0,855,858,1,0,0,
  	0,856,854,1,0,0,0,856,857,1,0,0,0,857,860,1,0,0,0,858,856,1,0,0,0,859,
  	861,3,122,61,0,860,859,1,0,0,0,860,861,1,0,0,0,861,864,1,0,0,0,862,864,
  	5,7,0,0,863,849,1,0,0,0,863,862,1,0,0,0,863,864,1,0,0,0,864,865,1,0,0,
  	0,865,867,5,4,0,0,866,868,3,112,56,0,867,866,1,0,0,0,867,868,1,0,0,0,
  	868,870,1,0,0,0,869,871,3,116,58,0,870,869,1,0,0,0,870,871,1,0,0,0,871,
  	921,1,0,0,0,872,873,5,3,0,0,873,878,3,64,32,0,874,875,5,5,0,0,875,877,
  	3,64,32,0,876,874,1,0,0,0,877,880,1,0,0,0,878,876,1,0,0,0,878,879,1,0,
  	0,0,879,881,1,0,0,0,880,878,1,0,0,0,881,882,5,4,0,0,882,921,1,0,0,0,883,
  	884,5,45,0,0,884,885,5,3,0,0,885,886,3,64,32,0,886,887,5,35,0,0,887,888,
  	3,32,16,0,888,889,5,4,0,0,889,921,1,0,0,0,890,892,5,105,0,0,891,890,1,
  	0,0,0,891,892,1,0,0,0,892,893,1,0,0,0,893,895,5,72,0,0,894,891,1,0,0,
  	0,894,895,1,0,0,0,895,896,1,0,0,0,896,897,5,3,0,0,897,898,3,86,43,0,898,
  	899,5,4,0,0,899,921,1,0,0,0,900,902,5,44,0,0,901,903,3,64,32,0,902,901,
  	1,0,0,0,902,903,1,0,0,0,903,909,1,0,0,0,904,905,5,152,0,0,905,906,3,64,
  	32,0,906,907,5,140,0,0,907,908,3,64,32,0,908,910,1,0,0,0,909,904,1,0,
  	0,0,910,911,1,0,0,0,911,909,1,0,0,0,911,912,1,0,0,0,912,915,1,0,0,0,913,
  	914,5,67,0,0,914,916,3,64,32,0,915,913,1,0,0,0,915,916,1,0,0,0,916,917,
  	1,0,0,0,917,918,5,68,0,0,918,921,1,0,0,0,919,921,3,66,33,0,920,828,1,
  	0,0,0,920,830,1,0,0,0,920,839,1,0,0,0,920,842,1,0,0,0,920,844,1,0,0,0,
  	920,846,1,0,0,0,920,872,1,0,0,0,920,883,1,0,0,0,920,894,1,0,0,0,920,900,
  	1,0,0,0,920,919,1,0,0,0,921,1036,1,0,0,0,922,923,10,20,0,0,923,924,7,
  	11,0,0,924,1035,3,64,32,21,925,926,10,19,0,0,926,927,7,12,0,0,927,1035,
  	3,64,32,20,928,929,10,18,0,0,929,930,7,4,0,0,930,1035,3,64,32,19,931,
  	932,10,17,0,0,932,933,7,13,0,0,933,1035,3,64,32,18,934,935,10,16,0,0,
  	935,936,7,14,0,0,936,1035,3,64,32,17,937,938,10,15,0,0,938,939,7,15,0,
  	0,939,1035,3,64,32,16,940,941,10,14,0,0,941,943,5,94,0,0,942,944,5,105,
  	0,0,943,942,1,0,0,0,943,944,1,0,0,0,944,947,1,0,0,0,945,946,5,64,0,0,
  	946,948,5,77,0,0,947,945,1,0,0,0,947,948,1,0,0,0,948,949,1,0,0,0,949,
  	1035,3,64,32,15,950,952,10,13,0,0,951,953,5,105,0,0,952,951,1,0,0,0,952,
  	953,1,0,0,0,953,954,1,0,0,0,954,955,5,41,0,0,955,956,3,64,32,0,956,957,
  	5,34,0,0,957,958,3,64,32,14,958,1035,1,0,0,0,959,960,10,8,0,0,960,961,
  	5,34,0,0,961,1035,3,64,32,9,962,963,10,7,0,0,963,964,5,111,0,0,964,1035,
  	3,64,32,8,965,966,10,21,0,0,966,967,5,47,0,0,967,1035,3,158,79,0,968,
  	970,10,12,0,0,969,971,5,105,0,0,970,969,1,0,0,0,970,971,1,0,0,0,971,972,
  	1,0,0,0,972,1011,5,85,0,0,973,983,5,3,0,0,974,984,3,86,43,0,975,980,3,
  	64,32,0,976,977,5,5,0,0,977,979,3,64,32,0,978,976,1,0,0,0,979,982,1,0,
  	0,0,980,978,1,0,0,0,980,981,1,0,0,0,981,984,1,0,0,0,982,980,1,0,0,0,983,
  	974,1,0,0,0,983,975,1,0,0,0,983,984,1,0,0,0,984,985,1,0,0,0,985,1012,
  	5,4,0,0,986,987,3,148,74,0,987,988,5,2,0,0,988,990,1,0,0,0,989,986,1,
  	0,0,0,989,990,1,0,0,0,990,991,1,0,0,0,991,1012,3,150,75,0,992,993,3,148,
  	74,0,993,994,5,2,0,0,994,996,1,0,0,0,995,992,1,0,0,0,995,996,1,0,0,0,
  	996,997,1,0,0,0,997,998,3,182,91,0,998,1007,5,3,0,0,999,1004,3,64,32,
  	0,1000,1001,5,5,0,0,1001,1003,3,64,32,0,1002,1000,1,0,0,0,1003,1006,1,
  	0,0,0,1004,1002,1,0,0,0,1004,1005,1,0,0,0,1005,1008,1,0,0,0,1006,1004,
  	1,0,0,0,1007,999,1,0,0,0,1007,1008,1,0,0,0,1008,1009,1,0,0,0,1009,1010,
  	5,4,0,0,1010,1012,1,0,0,0,1011,973,1,0,0,0,1011,989,1,0,0,0,1011,995,
  	1,0,0,0,1012,1035,1,0,0,0,1013,1015,10,11,0,0,1014,1016,5,105,0,0,1015,
  	1014,1,0,0,0,1015,1016,1,0,0,0,1016,1025,1,0,0,0,1017,1018,5,99,0,0,1018,
  	1021,3,64,32,0,1019,1020,5,69,0,0,1020,1022,3,64,32,0,1021,1019,1,0,0,
  	0,1021,1022,1,0,0,0,1022,1026,1,0,0,0,1023,1024,7,16,0,0,1024,1026,3,
  	64,32,0,1025,1017,1,0,0,0,1025,1023,1,0,0,0,1026,1035,1,0,0,0,1027,1032,
  	10,10,0,0,1028,1033,5,95,0,0,1029,1033,5,106,0,0,1030,1031,5,105,0,0,
  	1031,1033,5,107,0,0,1032,1028,1,0,0,0,1032,1029,1,0,0,0,1032,1030,1,0,
  	0,0,1033,1035,1,0,0,0,1034,922,1,0,0,0,1034,925,1,0,0,0,1034,928,1,0,
  	0,0,1034,931,1,0,0,0,1034,934,1,0,0,0,1034,937,1,0,0,0,1034,940,1,0,0,
  	0,1034,950,1,0,0,0,1034,959,1,0,0,0,1034,962,1,0,0,0,1034,965,1,0,0,0,
  	1034,968,1,0,0,0,1034,1013,1,0,0,0,1034,1027,1,0,0,0,1035,1038,1,0,0,
  	0,1036,1034,1,0,0,0,1036,1037,1,0,0,0,1037,65,1,0,0,0,1038,1036,1,0,0,
  	0,1039,1040,5,118,0,0,1040,1045,5,3,0,0,1041,1046,5,83,0,0,1042,1043,
  	7,17,0,0,1043,1044,5,5,0,0,1044,1046,3,136,68,0,1045,1041,1,0,0,0,1045,
  	1042,1,0,0,0,1046,1047,1,0,0,0,1047,1048,5,4,0,0,1048,67,1,0,0,0,1049,
  	1050,7,18,0,0,1050,69,1,0,0,0,1051,1052,5,3,0,0,1052,1057,3,64,32,0,1053,
  	1054,5,5,0,0,1054,1056,3,64,32,0,1055,1053,1,0,0,0,1056,1059,1,0,0,0,
  	1057,1055,1,0,0,0,1057,1058,1,0,0,0,1058,1060,1,0,0,0,1059,1057,1,0,0,
  	0,1060,1061,5,4,0,0,1061,71,1,0,0,0,1062,1063,5,149,0,0,1063,1068,3,70,
  	35,0,1064,1065,5,5,0,0,1065,1067,3,70,35,0,1066,1064,1,0,0,0,1067,1070,
  	1,0,0,0,1068,1066,1,0,0,0,1068,1069,1,0,0,0,1069,73,1,0,0,0,1070,1068,
  	1,0,0,0,1071,1073,3,50,25,0,1072,1071,1,0,0,0,1072,1073,1,0,0,0,1073,
  	1079,1,0,0,0,1074,1080,5,90,0,0,1075,1080,5,125,0,0,1076,1077,5,90,0,
  	0,1077,1078,5,111,0,0,1078,1080,7,8,0,0,1079,1074,1,0,0,0,1079,1075,1,
  	0,0,0,1079,1076,1,0,0,0,1080,1081,1,0,0,0,1081,1085,5,93,0,0,1082,1083,
  	3,148,74,0,1083,1084,5,2,0,0,1084,1086,1,0,0,0,1085,1082,1,0,0,0,1085,
  	1086,1,0,0,0,1086,1087,1,0,0,0,1087,1090,3,150,75,0,1088,1089,5,35,0,
  	0,1089,1091,3,174,87,0,1090,1088,1,0,0,0,1090,1091,1,0,0,0,1091,1103,
  	1,0,0,0,1092,1093,5,3,0,0,1093,1098,3,154,77,0,1094,1095,5,5,0,0,1095,
  	1097,3,154,77,0,1096,1094,1,0,0,0,1097,1100,1,0,0,0,1098,1096,1,0,0,0,
  	1098,1099,1,0,0,0,1099,1101,1,0,0,0,1100,1098,1,0,0,0,1101,1102,5,4,0,
  	0,1102,1104,1,0,0,0,1103,1092,1,0,0,0,1103,1104,1,0,0,0,1104,1117,1,0,
  	0,0,1105,1108,3,72,36,0,1106,1108,3,86,43,0,1107,1105,1,0,0,0,1107,1106,
  	1,0,0,0,1108,1112,1,0,0,0,1109,1111,3,78,39,0,1110,1109,1,0,0,0,1111,
  	1114,1,0,0,0,1112,1110,1,0,0,0,1112,1113,1,0,0,0,1113,1118,1,0,0,0,1114,
  	1112,1,0,0,0,1115,1116,5,58,0,0,1116,1118,5,149,0,0,1117,1107,1,0,0,0,
  	1117,1115,1,0,0,0,1118,1120,1,0,0,0,1119,1121,3,76,38,0,1120,1119,1,0,
  	0,0,1120,1121,1,0,0,0,1121,75,1,0,0,0,1122,1131,5,127,0,0,1123,1132,5,
  	7,0,0,1124,1129,3,64,32,0,1125,1127,5,35,0,0,1126,1125,1,0,0,0,1126,1127,
  	1,0,0,0,1127,1128,1,0,0,0,1128,1130,3,156,78,0,1129,1126,1,0,0,0,1129,
  	1130,1,0,0,0,1130,1132,1,0,0,0,1131,1123,1,0,0,0,1131,1124,1,0,0,0,1132,
  	1146,1,0,0,0,1133,1142,5,5,0,0,1134,1143,5,7,0,0,1135,1140,3,64,32,0,
  	1136,1138,5,35,0,0,1137,1136,1,0,0,0,1137,1138,1,0,0,0,1138,1139,1,0,
  	0,0,1139,1141,3,156,78,0,1140,1137,1,0,0,0,1140,1141,1,0,0,0,1141,1143,
  	1,0,0,0,1142,1134,1,0,0,0,1142,1135,1,0,0,0,1143,1145,1,0,0,0,1144,1133,
  	1,0,0,0,1145,1148,1,0,0,0,1146,1144,1,0,0,0,1146,1147,1,0,0,0,1147,77,
  	1,0,0,0,1148,1146,1,0,0,0,1149,1150,5,110,0,0,1150,1165,5,50,0,0,1151,
  	1152,5,3,0,0,1152,1157,3,24,12,0,1153,1154,5,5,0,0,1154,1156,3,24,12,
  	0,1155,1153,1,0,0,0,1156,1159,1,0,0,0,1157,1155,1,0,0,0,1157,1158,1,0,
  	0,0,1158,1160,1,0,0,0,1159,1157,1,0,0,0,1160,1163,5,4,0,0,1161,1162,5,
  	153,0,0,1162,1164,3,64,32,0,1163,1161,1,0,0,0,1163,1164,1,0,0,0,1164,
  	1166,1,0,0,0,1165,1151,1,0,0,0,1165,1166,1,0,0,0,1166,1167,1,0,0,0,1167,
  	1194,5,178,0,0,1168,1195,5,179,0,0,1169,1170,5,146,0,0,1170,1173,5,135,
  	0,0,1171,1174,3,154,77,0,1172,1174,3,104,52,0,1173,1171,1,0,0,0,1173,
  	1172,1,0,0,0,1174,1175,1,0,0,0,1175,1176,5,6,0,0,1176,1187,3,64,32,0,
  	1177,1180,5,5,0,0,1178,1181,3,154,77,0,1179,1181,3,104,52,0,1180,1178,
  	1,0,0,0,1180,1179,1,0,0,0,1181,1182,1,0,0,0,1182,1183,5,6,0,0,1183,1184,
  	3,64,32,0,1184,1186,1,0,0,0,1185,1177,1,0,0,0,1186,1189,1,0,0,0,1187,
  	1185,1,0,0,0,1187,1188,1,0,0,0,1188,1192,1,0,0,0,1189,1187,1,0,0,0,1190,
  	1191,5,153,0,0,1191,1193,3,64,32,0,1192,1190,1,0,0,0,1192,1193,1,0,0,
  	0,1193,1195,1,0,0,0,1194,1168,1,0,0,0,1194,1169,1,0,0,0,1195,79,1,0,0,
  	0,1196,1200,5,115,0,0,1197,1198,3,148,74,0,1198,1199,5,2,0,0,1199,1201,
  	1,0,0,0,1200,1197,1,0,0,0,1200,1201,1,0,0,0,1201,1202,1,0,0,0,1202,1209,
  	3,170,85,0,1203,1204,5,6,0,0,1204,1210,3,82,41,0,1205,1206,5,3,0,0,1206,
  	1207,3,82,41,0,1207,1208,5,4,0,0,1208,1210,1,0,0,0,1209,1203,1,0,0,0,
  	1209,1205,1,0,0,0,1209,1210,1,0,0,0,1210,81,1,0,0,0,1211,1215,3,36,18,
  	0,1212,1215,3,144,72,0,1213,1215,5,183,0,0,1214,1211,1,0,0,0,1214,1212,
  	1,0,0,0,1214,1213,1,0,0,0,1215,83,1,0,0,0,1216,1227,5,122,0,0,1217,1228,
  	3,158,79,0,1218,1219,3,148,74,0,1219,1220,5,2,0,0,1220,1222,1,0,0,0,1221,
  	1218,1,0,0,0,1221,1222,1,0,0,0,1222,1225,1,0,0,0,1223,1226,3,150,75,0,
  	1224,1226,3,162,81,0,1225,1223,1,0,0,0,1225,1224,1,0,0,0,1226,1228,1,
  	0,0,0,1227,1217,1,0,0,0,1227,1221,1,0,0,0,1227,1228,1,0,0,0,1228,85,1,
  	0,0,0,1229,1231,3,50,25,0,1230,1229,1,0,0,0,1230,1231,1,0,0,0,1231,1232,
  	1,0,0,0,1232,1238,3,90,45,0,1233,1234,3,100,50,0,1234,1235,3,90,45,0,
  	1235,1237,1,0,0,0,1236,1233,1,0,0,0,1237,1240,1,0,0,0,1238,1236,1,0,0,
  	0,1238,1239,1,0,0,0,1239,1242,1,0,0,0,1240,1238,1,0,0,0,1241,1243,3,122,
  	61,0,1242,1241,1,0,0,0,1242,1243,1,0,0,0,1243,1245,1,0,0,0,1244,1246,
  	3,124,62,0,1245,1244,1,0,0,0,1245,1246,1,0,0,0,1246,87,1,0,0,0,1247,1255,
  	3,92,46,0,1248,1249,3,96,48,0,1249,1251,3,92,46,0,1250,1252,3,98,49,0,
  	1251,1250,1,0,0,0,1251,1252,1,0,0,0,1252,1254,1,0,0,0,1253,1248,1,0,0,
  	0,1254,1257,1,0,0,0,1255,1253,1,0,0,0,1255,1256,1,0,0,0,1256,89,1,0,0,
  	0,1257,1255,1,0,0,0,1258,1260,5,134,0,0,1259,1261,7,19,0,0,1260,1259,
  	1,0,0,0,1260,1261,1,0,0,0,1261,1262,1,0,0,0,1262,1267,3,94,47,0,1263,
  	1264,5,5,0,0,1264,1266,3,94,47,0,1265,1263,1,0,0,0,1266,1269,1,0,0,0,
  	1267,1265,1,0,0,0,1267,1268,1,0,0,0,1268,1282,1,0,0,0,1269,1267,1,0,0,
  	0,1270,1280,5,77,0,0,1271,1276,3,92,46,0,1272,1273,5,5,0,0,1273,1275,
  	3,92,46,0,1274,1272,1,0,0,0,1275,1278,1,0,0,0,1276,1274,1,0,0,0,1276,
  	1277,1,0,0,0,1277,1281,1,0,0,0,1278,1276,1,0,0,0,1279,1281,3,88,44,0,
  	1280,1271,1,0,0,0,1280,1279,1,0,0,0,1281,1283,1,0,0,0,1282,1270,1,0,0,
  	0,1282,1283,1,0,0,0,1283,1286,1,0,0,0,1284,1285,5,153,0,0,1285,1287,3,
  	64,32,0,1286,1284,1,0,0,0,1286,1287,1,0,0,0,1287,1302,1,0,0,0,1288,1289,
  	5,80,0,0,1289,1290,5,42,0,0,1290,1295,3,64,32,0,1291,1292,5,5,0,0,1292,
  	1294,3,64,32,0,1293,1291,1,0,0,0,1294,1297,1,0,0,0,1295,1293,1,0,0,0,
  	1295,1296,1,0,0,0,1296,1300,1,0,0,0,1297,1295,1,0,0,0,1298,1299,5,81,
  	0,0,1299,1301,3,64,32,0,1300,1298,1,0,0,0,1300,1301,1,0,0,0,1301,1303,
  	1,0,0,0,1302,1288,1,0,0,0,1302,1303,1,0,0,0,1303,1318,1,0,0,0,1304,1305,
  	5,169,0,0,1305,1306,3,176,88,0,1306,1307,5,35,0,0,1307,1315,3,114,57,
  	0,1308,1309,5,5,0,0,1309,1310,3,176,88,0,1310,1311,5,35,0,0,1311,1312,
  	3,114,57,0,1312,1314,1,0,0,0,1313,1308,1,0,0,0,1314,1317,1,0,0,0,1315,
  	1313,1,0,0,0,1315,1316,1,0,0,0,1316,1319,1,0,0,0,1317,1315,1,0,0,0,1318,
  	1304,1,0,0,0,1318,1319,1,0,0,0,1319,1322,1,0,0,0,1320,1322,3,72,36,0,
  	1321,1258,1,0,0,0,1321,1320,1,0,0,0,1322,91,1,0,0,0,1323,1324,3,148,74,
  	0,1324,1325,5,2,0,0,1325,1327,1,0,0,0,1326,1323,1,0,0,0,1326,1327,1,0,
  	0,0,1327,1328,1,0,0,0,1328,1333,3,150,75,0,1329,1331,5,35,0,0,1330,1329,
  	1,0,0,0,1330,1331,1,0,0,0,1331,1332,1,0,0,0,1332,1334,3,174,87,0,1333,
  	1330,1,0,0,0,1333,1334,1,0,0,0,1334,1340,1,0,0,0,1335,1336,5,87,0,0,1336,
  	1337,5,42,0,0,1337,1341,3,162,81,0,1338,1339,5,105,0,0,1339,1341,5,87,
  	0,0,1340,1335,1,0,0,0,1340,1338,1,0,0,0,1340,1341,1,0,0,0,1341,1388,1,
  	0,0,0,1342,1343,3,148,74,0,1343,1344,5,2,0,0,1344,1346,1,0,0,0,1345,1342,
  	1,0,0,0,1345,1346,1,0,0,0,1346,1347,1,0,0,0,1347,1348,3,182,91,0,1348,
  	1349,5,3,0,0,1349,1354,3,64,32,0,1350,1351,5,5,0,0,1351,1353,3,64,32,
  	0,1352,1350,1,0,0,0,1353,1356,1,0,0,0,1354,1352,1,0,0,0,1354,1355,1,0,
  	0,0,1355,1357,1,0,0,0,1356,1354,1,0,0,0,1357,1362,5,4,0,0,1358,1360,5,
  	35,0,0,1359,1358,1,0,0,0,1359,1360,1,0,0,0,1360,1361,1,0,0,0,1361,1363,
  	3,174,87,0,1362,1359,1,0,0,0,1362,1363,1,0,0,0,1363,1388,1,0,0,0,1364,
  	1374,5,3,0,0,1365,1370,3,92,46,0,1366,1367,5,5,0,0,1367,1369,3,92,46,
  	0,1368,1366,1,0,0,0,1369,1372,1,0,0,0,1370,1368,1,0,0,0,1370,1371,1,0,
  	0,0,1371,1375,1,0,0,0,1372,1370,1,0,0,0,1373,1375,3,88,44,0,1374,1365,
  	1,0,0,0,1374,1373,1,0,0,0,1375,1376,1,0,0,0,1376,1377,5,4,0,0,1377,1388,
  	1,0,0,0,1378,1379,5,3,0,0,1379,1380,3,86,43,0,1380,1385,5,4,0,0,1381,
  	1383,5,35,0,0,1382,1381,1,0,0,0,1382,1383,1,0,0,0,1383,1384,1,0,0,0,1384,
  	1386,3,174,87,0,1385,1382,1,0,0,0,1385,1386,1,0,0,0,1386,1388,1,0,0,0,
  	1387,1326,1,0,0,0,1387,1345,1,0,0,0,1387,1364,1,0,0,0,1387,1378,1,0,0,
  	0,1388,93,1,0,0,0,1389,1402,5,7,0,0,1390,1391,3,150,75,0,1391,1392,5,
  	2,0,0,1392,1393,5,7,0,0,1393,1402,1,0,0,0,1394,1399,3,64,32,0,1395,1397,
  	5,35,0,0,1396,1395,1,0,0,0,1396,1397,1,0,0,0,1397,1398,1,0,0,0,1398,1400,
  	3,156,78,0,1399,1396,1,0,0,0,1399,1400,1,0,0,0,1400,1402,1,0,0,0,1401,
  	1389,1,0,0,0,1401,1390,1,0,0,0,1401,1394,1,0,0,0,1402,95,1,0,0,0,1403,
  	1417,5,5,0,0,1404,1406,5,103,0,0,1405,1404,1,0,0,0,1405,1406,1,0,0,0,
  	1406,1413,1,0,0,0,1407,1409,7,20,0,0,1408,1410,5,113,0,0,1409,1408,1,
  	0,0,0,1409,1410,1,0,0,0,1410,1414,1,0,0,0,1411,1414,5,89,0,0,1412,1414,
  	5,53,0,0,1413,1407,1,0,0,0,1413,1411,1,0,0,0,1413,1412,1,0,0,0,1413,1414,
  	1,0,0,0,1414,1415,1,0,0,0,1415,1417,5,96,0,0,1416,1403,1,0,0,0,1416,1405,
  	1,0,0,0,1417,97,1,0,0,0,1418,1419,5,110,0,0,1419,1433,3,64,32,0,1420,
  	1421,5,147,0,0,1421,1422,5,3,0,0,1422,1427,3,154,77,0,1423,1424,5,5,0,
  	0,1424,1426,3,154,77,0,1425,1423,1,0,0,0,1426,1429,1,0,0,0,1427,1425,
  	1,0,0,0,1427,1428,1,0,0,0,1428,1430,1,0,0,0,1429,1427,1,0,0,0,1430,1431,
  	5,4,0,0,1431,1433,1,0,0,0,1432,1418,1,0,0,0,1432,1420,1,0,0,0,1433,99,
  	1,0,0,0,1434,1436,5,144,0,0,1435,1437,5,31,0,0,1436,1435,1,0,0,0,1436,
  	1437,1,0,0,0,1437,1441,1,0,0,0,1438,1441,5,92,0,0,1439,1441,5,70,0,0,
  	1440,1434,1,0,0,0,1440,1438,1,0,0,0,1440,1439,1,0,0,0,1441,101,1,0,0,
  	0,1442,1444,3,50,25,0,1443,1442,1,0,0,0,1443,1444,1,0,0,0,1444,1445,1,
  	0,0,0,1445,1448,5,146,0,0,1446,1447,5,111,0,0,1447,1449,7,8,0,0,1448,
  	1446,1,0,0,0,1448,1449,1,0,0,0,1449,1450,1,0,0,0,1450,1451,3,108,54,0,
  	1451,1454,5,135,0,0,1452,1455,3,154,77,0,1453,1455,3,104,52,0,1454,1452,
  	1,0,0,0,1454,1453,1,0,0,0,1455,1456,1,0,0,0,1456,1457,5,6,0,0,1457,1468,
  	3,64,32,0,1458,1461,5,5,0,0,1459,1462,3,154,77,0,1460,1462,3,104,52,0,
  	1461,1459,1,0,0,0,1461,1460,1,0,0,0,1462,1463,1,0,0,0,1463,1464,5,6,0,
  	0,1464,1465,3,64,32,0,1465,1467,1,0,0,0,1466,1458,1,0,0,0,1467,1470,1,
  	0,0,0,1468,1466,1,0,0,0,1468,1469,1,0,0,0,1469,1483,1,0,0,0,1470,1468,
  	1,0,0,0,1471,1481,5,77,0,0,1472,1477,3,92,46,0,1473,1474,5,5,0,0,1474,
  	1476,3,92,46,0,1475,1473,1,0,0,0,1476,1479,1,0,0,0,1477,1475,1,0,0,0,
  	1477,1478,1,0,0,0,1478,1482,1,0,0,0,1479,1477,1,0,0,0,1480,1482,3,88,
  	44,0,1481,1472,1,0,0,0,1481,1480,1,0,0,0,1482,1484,1,0,0,0,1483,1471,
  	1,0,0,0,1483,1484,1,0,0,0,1484,1487,1,0,0,0,1485,1486,5,153,0,0,1486,
  	1488,3,64,32,0,1487,1485,1,0,0,0,1487,1488,1,0,0,0,1488,1490,1,0,0,0,
  	1489,1491,3,76,38,0,1490,1489,1,0,0,0,1490,1491,1,0,0,0,1491,103,1,0,
  	0,0,1492,1493,5,3,0,0,1493,1498,3,154,77,0,1494,1495,5,5,0,0,1495,1497,
  	3,154,77,0,1496,1494,1,0,0,0,1497,1500,1,0,0,0,1498,1496,1,0,0,0,1498,
  	1499,1,0,0,0,1499,1501,1,0,0,0,1500,1498,1,0,0,0,1501,1502,5,4,0,0,1502,
  	105,1,0,0,0,1503,1505,3,50,25,0,1504,1503,1,0,0,0,1504,1505,1,0,0,0,1505,
  	1506,1,0,0,0,1506,1509,5,146,0,0,1507,1508,5,111,0,0,1508,1510,7,8,0,
  	0,1509,1507,1,0,0,0,1509,1510,1,0,0,0,1510,1511,1,0,0,0,1511,1512,3,108,
  	54,0,1512,1515,5,135,0,0,1513,1516,3,154,77,0,1514,1516,3,104,52,0,1515,
  	1513,1,0,0,0,1515,1514,1,0,0,0,1516,1517,1,0,0,0,1517,1518,5,6,0,0,1518,
  	1529,3,64,32,0,1519,1522,5,5,0,0,1520,1523,3,154,77,0,1521,1523,3,104,
  	52,0,1522,1520,1,0,0,0,1522,1521,1,0,0,0,1523,1524,1,0,0,0,1524,1525,
  	5,6,0,0,1525,1526,3,64,32,0,1526,1528,1,0,0,0,1527,1519,1,0,0,0,1528,
  	1531,1,0,0,0,1529,1527,1,0,0,0,1529,1530,1,0,0,0,1530,1544,1,0,0,0,1531,
  	1529,1,0,0,0,1532,1542,5,77,0,0,1533,1538,3,92,46,0,1534,1535,5,5,0,0,
  	1535,1537,3,92,46,0,1536,1534,1,0,0,0,1537,1540,1,0,0,0,1538,1536,1,0,
  	0,0,1538,1539,1,0,0,0,1539,1543,1,0,0,0,1540,1538,1,0,0,0,1541,1543,3,
  	88,44,0,1542,1533,1,0,0,0,1542,1541,1,0,0,0,1543,1545,1,0,0,0,1544,1532,
  	1,0,0,0,1544,1545,1,0,0,0,1545,1548,1,0,0,0,1546,1547,5,153,0,0,1547,
  	1549,3,64,32,0,1548,1546,1,0,0,0,1548,1549,1,0,0,0,1549,1551,1,0,0,0,
  	1550,1552,3,76,38,0,1551,1550,1,0,0,0,1551,1552,1,0,0,0,1552,1554,1,0,
  	0,0,1553,1555,3,122,61,0,1554,1553,1,0,0,0,1554,1555,1,0,0,0,1555,1557,
  	1,0,0,0,1556,1558,3,124,62,0,1557,1556,1,0,0,0,1557,1558,1,0,0,0,1558,
  	107,1,0,0,0,1559,1560,3,148,74,0,1560,1561,5,2,0,0,1561,1563,1,0,0,0,
  	1562,1559,1,0,0,0,1562,1563,1,0,0,0,1563,1564,1,0,0,0,1564,1567,3,150,
  	75,0,1565,1566,5,35,0,0,1566,1568,3,178,89,0,1567,1565,1,0,0,0,1567,1568,
  	1,0,0,0,1568,1574,1,0,0,0,1569,1570,5,87,0,0,1570,1571,5,42,0,0,1571,
  	1575,3,162,81,0,1572,1573,5,105,0,0,1573,1575,5,87,0,0,1574,1569,1,0,
  	0,0,1574,1572,1,0,0,0,1574,1575,1,0,0,0,1575,109,1,0,0,0,1576,1578,5,
  	148,0,0,1577,1579,3,148,74,0,1578,1577,1,0,0,0,1578,1579,1,0,0,0,1579,
  	1582,1,0,0,0,1580,1581,5,93,0,0,1581,1583,3,138,69,0,1582,1580,1,0,0,
  	0,1582,1583,1,0,0,0,1583,111,1,0,0,0,1584,1585,5,173,0,0,1585,1586,5,
  	3,0,0,1586,1587,5,153,0,0,1587,1588,3,64,32,0,1588,1589,5,4,0,0,1589,
  	113,1,0,0,0,1590,1592,5,3,0,0,1591,1593,3,180,90,0,1592,1591,1,0,0,0,
  	1592,1593,1,0,0,0,1593,1604,1,0,0,0,1594,1595,5,157,0,0,1595,1596,5,42,
  	0,0,1596,1601,3,64,32,0,1597,1598,5,5,0,0,1598,1600,3,64,32,0,1599,1597,
  	1,0,0,0,1600,1603,1,0,0,0,1601,1599,1,0,0,0,1601,1602,1,0,0,0,1602,1605,
  	1,0,0,0,1603,1601,1,0,0,0,1604,1594,1,0,0,0,1604,1605,1,0,0,0,1605,1607,
  	1,0,0,0,1606,1608,3,122,61,0,1607,1606,1,0,0,0,1607,1608,1,0,0,0,1608,
  	1610,1,0,0,0,1609,1611,3,118,59,0,1610,1609,1,0,0,0,1610,1611,1,0,0,0,
  	1611,1612,1,0,0,0,1612,1613,5,4,0,0,1613,115,1,0,0,0,1614,1639,5,156,
  	0,0,1615,1640,3,176,88,0,1616,1618,5,3,0,0,1617,1619,3,180,90,0,1618,
  	1617,1,0,0,0,1618,1619,1,0,0,0,1619,1630,1,0,0,0,1620,1621,5,157,0,0,
  	1621,1622,5,42,0,0,1622,1627,3,64,32,0,1623,1624,5,5,0,0,1624,1626,3,
  	64,32,0,1625,1623,1,0,0,0,1626,1629,1,0,0,0,1627,1625,1,0,0,0,1627,1628,
  	1,0,0,0,1628,1631,1,0,0,0,1629,1627,1,0,0,0,1630,1620,1,0,0,0,1630,1631,
  	1,0,0,0,1631,1633,1,0,0,0,1632,1634,3,122,61,0,1633,1632,1,0,0,0,1633,
  	1634,1,0,0,0,1634,1636,1,0,0,0,1635,1637,3,118,59,0,1636,1635,1,0,0,0,
  	1636,1637,1,0,0,0,1637,1638,1,0,0,0,1638,1640,5,4,0,0,1639,1615,1,0,0,
  	0,1639,1616,1,0,0,0,1640,117,1,0,0,0,1641,1651,3,120,60,0,1642,1649,5,
  	175,0,0,1643,1644,5,104,0,0,1644,1650,5,177,0,0,1645,1646,5,161,0,0,1646,
  	1650,5,130,0,0,1647,1650,5,80,0,0,1648,1650,5,176,0,0,1649,1643,1,0,0,
  	0,1649,1645,1,0,0,0,1649,1647,1,0,0,0,1649,1648,1,0,0,0,1650,1652,1,0,
  	0,0,1651,1642,1,0,0,0,1651,1652,1,0,0,0,1652,119,1,0,0,0,1653,1660,7,
  	21,0,0,1654,1661,3,134,67,0,1655,1656,5,41,0,0,1656,1657,3,130,65,0,1657,
  	1658,5,34,0,0,1658,1659,3,132,66,0,1659,1661,1,0,0,0,1660,1654,1,0,0,
  	0,1660,1655,1,0,0,0,1661,121,1,0,0,0,1662,1663,5,112,0,0,1663,1664,5,
  	42,0,0,1664,1669,3,126,63,0,1665,1666,5,5,0,0,1666,1668,3,126,63,0,1667,
  	1665,1,0,0,0,1668,1671,1,0,0,0,1669,1667,1,0,0,0,1669,1670,1,0,0,0,1670,
  	123,1,0,0,0,1671,1669,1,0,0,0,1672,1673,5,100,0,0,1673,1676,3,64,32,0,
  	1674,1675,7,22,0,0,1675,1677,3,64,32,0,1676,1674,1,0,0,0,1676,1677,1,
  	0,0,0,1677,125,1,0,0,0,1678,1681,3,64,32,0,1679,1680,5,47,0,0,1680,1682,
  	3,158,79,0,1681,1679,1,0,0,0,1681,1682,1,0,0,0,1682,1684,1,0,0,0,1683,
  	1685,3,128,64,0,1684,1683,1,0,0,0,1684,1685,1,0,0,0,1685,1688,1,0,0,0,
  	1686,1687,5,170,0,0,1687,1689,7,23,0,0,1688,1686,1,0,0,0,1688,1689,1,
  	0,0,0,1689,127,1,0,0,0,1690,1691,7,24,0,0,1691,129,1,0,0,0,1692,1693,
  	3,64,32,0,1693,1694,5,159,0,0,1694,1703,1,0,0,0,1695,1696,3,64,32,0,1696,
  	1697,5,162,0,0,1697,1703,1,0,0,0,1698,1699,5,161,0,0,1699,1703,5,130,
  	0,0,1700,1701,5,160,0,0,1701,1703,5,159,0,0,1702,1692,1,0,0,0,1702,1695,
  	1,0,0,0,1702,1698,1,0,0,0,1702,1700,1,0,0,0,1703,131,1,0,0,0,1704,1705,
  	3,64,32,0,1705,1706,5,159,0,0,1706,1715,1,0,0,0,1707,1708,3,64,32,0,1708,
  	1709,5,162,0,0,1709,1715,1,0,0,0,1710,1711,5,161,0,0,1711,1715,5,130,
  	0,0,1712,1713,5,160,0,0,1713,1715,5,162,0,0,1714,1704,1,0,0,0,1714,1707,
  	1,0,0,0,1714,1710,1,0,0,0,1714,1712,1,0,0,0,1715,133,1,0,0,0,1716,1717,
  	3,64,32,0,1717,1718,5,159,0,0,1718,1724,1,0,0,0,1719,1720,5,160,0,0,1720,
  	1724,5,159,0,0,1721,1722,5,161,0,0,1722,1724,5,130,0,0,1723,1716,1,0,
  	0,0,1723,1719,1,0,0,0,1723,1721,1,0,0,0,1724,135,1,0,0,0,1725,1726,3,
  	64,32,0,1726,137,1,0,0,0,1727,1728,3,64,32,0,1728,139,1,0,0,0,1729,1739,
  	8,25,0,0,1730,1734,5,3,0,0,1731,1733,3,140,70,0,1732,1731,1,0,0,0,1733,
  	1736,1,0,0,0,1734,1732,1,0,0,0,1734,1735,1,0,0,0,1735,1737,1,0,0,0,1736,
  	1734,1,0,0,0,1737,1739,5,4,0,0,1738,1729,1,0,0,0,1738,1730,1,0,0,0,1739,
  	1740,1,0,0,0,1740,1741,1,0,0,0,1740,1738,1,0,0,0,1741,141,1,0,0,0,1742,
  	1743,7,26,0,0,1743,143,1,0,0,0,1744,1745,3,208,104,0,1745,145,1,0,0,0,
  	1746,1747,3,208,104,0,1747,147,1,0,0,0,1748,1749,3,208,104,0,1749,149,
  	1,0,0,0,1750,1751,3,208,104,0,1751,151,1,0,0,0,1752,1753,3,208,104,0,
  	1753,153,1,0,0,0,1754,1755,3,208,104,0,1755,155,1,0,0,0,1756,1757,3,208,
  	104,0,1757,157,1,0,0,0,1758,1759,3,208,104,0,1759,159,1,0,0,0,1760,1761,
  	3,208,104,0,1761,161,1,0,0,0,1762,1763,3,208,104,0,1763,163,1,0,0,0,1764,
  	1765,3,208,104,0,1765,165,1,0,0,0,1766,1767,3,208,104,0,1767,167,1,0,
  	0,0,1768,1769,3,208,104,0,1769,169,1,0,0,0,1770,1771,3,208,104,0,1771,
  	171,1,0,0,0,1772,1773,3,208,104,0,1773,173,1,0,0,0,1774,1775,3,208,104,
  	0,1775,175,1,0,0,0,1776,1777,3,208,104,0,1777,177,1,0,0,0,1778,1779,3,
  	208,104,0,1779,179,1,0,0,0,1780,1781,3,208,104,0,1781,181,1,0,0,0,1782,
  	1783,3,208,104,0,1783,183,1,0,0,0,1784,1785,3,86,43,0,1785,185,1,0,0,
  	0,1786,1788,3,50,25,0,1787,1786,1,0,0,0,1787,1788,1,0,0,0,1788,1789,1,
  	0,0,0,1789,1791,3,90,45,0,1790,1792,3,122,61,0,1791,1790,1,0,0,0,1791,
  	1792,1,0,0,0,1792,1794,1,0,0,0,1793,1795,3,124,62,0,1794,1793,1,0,0,0,
  	1794,1795,1,0,0,0,1795,187,1,0,0,0,1796,1798,3,50,25,0,1797,1796,1,0,
  	0,0,1797,1798,1,0,0,0,1798,1799,1,0,0,0,1799,1809,3,90,45,0,1800,1802,
  	5,144,0,0,1801,1803,5,31,0,0,1802,1801,1,0,0,0,1802,1803,1,0,0,0,1803,
  	1807,1,0,0,0,1804,1807,5,92,0,0,1805,1807,5,70,0,0,1806,1800,1,0,0,0,
  	1806,1804,1,0,0,0,1806,1805,1,0,0,0,1807,1808,1,0,0,0,1808,1810,3,90,
  	45,0,1809,1806,1,0,0,0,1810,1811,1,0,0,0,1811,1809,1,0,0,0,1811,1812,
  	1,0,0,0,1812,1814,1,0,0,0,1813,1815,3,122,61,0,1814,1813,1,0,0,0,1814,
  	1815,1,0,0,0,1815,1817,1,0,0,0,1816,1818,3,124,62,0,1817,1816,1,0,0,0,
  	1817,1818,1,0,0,0,1818,189,1,0,0,0,1819,1820,3,54,27,0,1820,1821,5,35,
  	0,0,1821,1822,5,3,0,0,1822,1823,3,192,96,0,1823,1825,5,144,0,0,1824,1826,
  	5,31,0,0,1825,1824,1,0,0,0,1825,1826,1,0,0,0,1826,1827,1,0,0,0,1827,1828,
  	3,194,97,0,1828,1829,5,4,0,0,1829,191,1,0,0,0,1830,1831,3,86,43,0,1831,
  	193,1,0,0,0,1832,1833,3,86,43,0,1833,195,1,0,0,0,1834,1835,3,202,101,
  	0,1835,1845,5,3,0,0,1836,1841,3,64,32,0,1837,1838,5,5,0,0,1838,1840,3,
  	64,32,0,1839,1837,1,0,0,0,1840,1843,1,0,0,0,1841,1839,1,0,0,0,1841,1842,
  	1,0,0,0,1842,1846,1,0,0,0,1843,1841,1,0,0,0,1844,1846,5,7,0,0,1845,1836,
  	1,0,0,0,1845,1844,1,0,0,0,1846,1847,1,0,0,0,1847,1848,5,4,0,0,1848,197,
  	1,0,0,0,1849,1850,3,204,102,0,1850,1866,5,3,0,0,1851,1853,5,64,0,0,1852,
  	1851,1,0,0,0,1852,1853,1,0,0,0,1853,1854,1,0,0,0,1854,1859,3,64,32,0,
  	1855,1856,5,5,0,0,1856,1858,3,64,32,0,1857,1855,1,0,0,0,1858,1861,1,0,
  	0,0,1859,1857,1,0,0,0,1859,1860,1,0,0,0,1860,1863,1,0,0,0,1861,1859,1,
  	0,0,0,1862,1864,3,122,61,0,1863,1862,1,0,0,0,1863,1864,1,0,0,0,1864,1867,
  	1,0,0,0,1865,1867,5,7,0,0,1866,1852,1,0,0,0,1866,1865,1,0,0,0,1866,1867,
  	1,0,0,0,1867,1868,1,0,0,0,1868,1870,5,4,0,0,1869,1871,3,112,56,0,1870,
  	1869,1,0,0,0,1870,1871,1,0,0,0,1871,199,1,0,0,0,1872,1873,3,206,103,0,
  	1873,1883,5,3,0,0,1874,1879,3,64,32,0,1875,1876,5,5,0,0,1876,1878,3,64,
  	32,0,1877,1875,1,0,0,0,1878,1881,1,0,0,0,1879,1877,1,0,0,0,1879,1880,
  	1,0,0,0,1880,1884,1,0,0,0,1881,1879,1,0,0,0,1882,1884,5,7,0,0,1883,1874,
  	1,0,0,0,1883,1882,1,0,0,0,1883,1884,1,0,0,0,1884,1885,1,0,0,0,1885,1887,
  	5,4,0,0,1886,1888,3,112,56,0,1887,1886,1,0,0,0,1887,1888,1,0,0,0,1888,
  	1889,1,0,0,0,1889,1892,5,156,0,0,1890,1893,3,114,57,0,1891,1893,3,176,
  	88,0,1892,1890,1,0,0,0,1892,1891,1,0,0,0,1893,201,1,0,0,0,1894,1895,3,
  	208,104,0,1895,203,1,0,0,0,1896,1897,3,208,104,0,1897,205,1,0,0,0,1898,
  	1899,3,208,104,0,1899,207,1,0,0,0,1900,1904,5,180,0,0,1901,1904,3,142,
  	71,0,1902,1904,5,183,0,0,1903,1900,1,0,0,0,1903,1901,1,0,0,0,1903,1902,
  	1,0,0,0,1904,209,1,0,0,0,290,214,218,222,228,230,256,263,270,276,280,
  	285,288,295,298,302,310,313,317,321,325,328,335,341,347,352,363,369,373,
  	377,380,384,390,395,404,411,416,420,425,431,435,440,445,451,463,467,472,
  	475,478,481,485,488,502,509,516,518,521,527,532,540,545,560,566,576,581,
  	591,595,597,601,606,608,616,622,627,634,645,648,650,657,661,668,674,680,
  	686,691,700,705,716,721,732,737,741,748,754,757,770,775,778,785,788,791,
  	798,801,804,807,811,819,824,834,839,849,856,860,863,867,870,878,891,894,
  	902,911,915,920,943,947,952,970,980,983,989,995,1004,1007,1011,1015,1021,
  	1025,1032,1034,1036,1045,1057,1068,1072,1079,1085,1090,1098,1103,1107,
  	1112,1117,1120,1126,1129,1131,1137,1140,1142,1146,1157,1163,1165,1173,
  	1180,1187,1192,1194,1200,1209,1214,1221,1225,1227,1230,1238,1242,1245,
  	1251,1255,1260,1267,1276,1280,1282,1286,1295,1300,1302,1315,1318,1321,
  	1326,1330,1333,1340,1345,1354,1359,1362,1370,1374,1382,1385,1387,1396,
  	1399,1401,1405,1409,1413,1416,1427,1432,1436,1440,1443,1448,1454,1461,
  	1468,1477,1481,1483,1487,1490,1498,1504,1509,1515,1522,1529,1538,1542,
  	1544,1548,1551,1554,1557,1562,1567,1574,1578,1582,1592,1601,1604,1607,
  	1610,1618,1627,1630,1633,1636,1639,1649,1651,1660,1669,1676,1681,1684,
  	1688,1702,1714,1723,1734,1738,1740,1787,1791,1794,1797,1802,1806,1811,
  	1814,1817,1825,1841,1845,1852,1859,1863,1866,1870,1879,1883,1887,1892,
  	1903
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  sqliteparserParserStaticData = std::move(staticData);
}

}

SQLiteParser::SQLiteParser(TokenStream *input) : SQLiteParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

SQLiteParser::SQLiteParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  SQLiteParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *sqliteparserParserStaticData->atn, sqliteparserParserStaticData->decisionToDFA, sqliteparserParserStaticData->sharedContextCache, options);
}

SQLiteParser::~SQLiteParser() {
  delete _interpreter;
}

const atn::ATN& SQLiteParser::getATN() const {
  return *sqliteparserParserStaticData->atn;
}

std::string SQLiteParser::getGrammarFileName() const {
  return "SQLiteParser.g4";
}

const std::vector<std::string>& SQLiteParser::getRuleNames() const {
  return sqliteparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& SQLiteParser::getVocabulary() const {
  return sqliteparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView SQLiteParser::getSerializedATN() const {
  return sqliteparserParserStaticData->serializedATN;
}


//----------------- ParseContext ------------------------------------------------------------------

SQLiteParser::ParseContext::ParseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Sql_stmt_listContext* SQLiteParser::ParseContext::sql_stmt_list() {
  return getRuleContext<SQLiteParser::Sql_stmt_listContext>(0);
}

tree::TerminalNode* SQLiteParser::ParseContext::EOF() {
  return getToken(SQLiteParser::EOF, 0);
}


size_t SQLiteParser::ParseContext::getRuleIndex() const {
  return SQLiteParser::RuleParse;
}

void SQLiteParser::ParseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParse(this);
}

void SQLiteParser::ParseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParse(this);
}


std::any SQLiteParser::ParseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitParse(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::ParseContext* SQLiteParser::parse() {
  ParseContext *_localctx = _tracker.createInstance<ParseContext>(_ctx, getState());
  enterRule(_localctx, 0, SQLiteParser::RuleParse);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(210);
    sql_stmt_list();
    setState(211);
    match(SQLiteParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_stmt_listContext ------------------------------------------------------------------

SQLiteParser::Sql_stmt_listContext::Sql_stmt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Sql_stmtContext *> SQLiteParser::Sql_stmt_listContext::sql_stmt() {
  return getRuleContexts<SQLiteParser::Sql_stmtContext>();
}

SQLiteParser::Sql_stmtContext* SQLiteParser::Sql_stmt_listContext::sql_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Sql_stmtContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Sql_stmt_listContext::SCOL() {
  return getTokens(SQLiteParser::SCOL);
}

tree::TerminalNode* SQLiteParser::Sql_stmt_listContext::SCOL(size_t i) {
  return getToken(SQLiteParser::SCOL, i);
}


size_t SQLiteParser::Sql_stmt_listContext::getRuleIndex() const {
  return SQLiteParser::RuleSql_stmt_list;
}

void SQLiteParser::Sql_stmt_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_stmt_list(this);
}

void SQLiteParser::Sql_stmt_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_stmt_list(this);
}


std::any SQLiteParser::Sql_stmt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSql_stmt_list(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Sql_stmt_listContext* SQLiteParser::sql_stmt_list() {
  Sql_stmt_listContext *_localctx = _tracker.createInstance<Sql_stmt_listContext>(_ctx, getState());
  enterRule(_localctx, 2, SQLiteParser::RuleSql_stmt_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(214);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 32) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 32)) & 288232655169913123) != 0) || ((((_la - 115) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 115)) & 577673905537) != 0)) {
      setState(213);
      sql_stmt();
    }
    setState(222);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::SCOL) {
      setState(216);
      match(SQLiteParser::SCOL);
      setState(218);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 32) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 32)) & 288232655169913123) != 0) || ((((_la - 115) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 115)) & 577673905537) != 0)) {
        setState(217);
        sql_stmt();
      }
      setState(224);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_stmtContext ------------------------------------------------------------------

SQLiteParser::Sql_stmtContext::Sql_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Alter_table_stmtContext* SQLiteParser::Sql_stmtContext::alter_table_stmt() {
  return getRuleContext<SQLiteParser::Alter_table_stmtContext>(0);
}

SQLiteParser::Analyze_stmtContext* SQLiteParser::Sql_stmtContext::analyze_stmt() {
  return getRuleContext<SQLiteParser::Analyze_stmtContext>(0);
}

SQLiteParser::Attach_stmtContext* SQLiteParser::Sql_stmtContext::attach_stmt() {
  return getRuleContext<SQLiteParser::Attach_stmtContext>(0);
}

SQLiteParser::Begin_stmtContext* SQLiteParser::Sql_stmtContext::begin_stmt() {
  return getRuleContext<SQLiteParser::Begin_stmtContext>(0);
}

SQLiteParser::Commit_stmtContext* SQLiteParser::Sql_stmtContext::commit_stmt() {
  return getRuleContext<SQLiteParser::Commit_stmtContext>(0);
}

SQLiteParser::Create_index_stmtContext* SQLiteParser::Sql_stmtContext::create_index_stmt() {
  return getRuleContext<SQLiteParser::Create_index_stmtContext>(0);
}

SQLiteParser::Create_table_stmtContext* SQLiteParser::Sql_stmtContext::create_table_stmt() {
  return getRuleContext<SQLiteParser::Create_table_stmtContext>(0);
}

SQLiteParser::Create_trigger_stmtContext* SQLiteParser::Sql_stmtContext::create_trigger_stmt() {
  return getRuleContext<SQLiteParser::Create_trigger_stmtContext>(0);
}

SQLiteParser::Create_view_stmtContext* SQLiteParser::Sql_stmtContext::create_view_stmt() {
  return getRuleContext<SQLiteParser::Create_view_stmtContext>(0);
}

SQLiteParser::Create_virtual_table_stmtContext* SQLiteParser::Sql_stmtContext::create_virtual_table_stmt() {
  return getRuleContext<SQLiteParser::Create_virtual_table_stmtContext>(0);
}

SQLiteParser::Delete_stmtContext* SQLiteParser::Sql_stmtContext::delete_stmt() {
  return getRuleContext<SQLiteParser::Delete_stmtContext>(0);
}

SQLiteParser::Delete_stmt_limitedContext* SQLiteParser::Sql_stmtContext::delete_stmt_limited() {
  return getRuleContext<SQLiteParser::Delete_stmt_limitedContext>(0);
}

SQLiteParser::Detach_stmtContext* SQLiteParser::Sql_stmtContext::detach_stmt() {
  return getRuleContext<SQLiteParser::Detach_stmtContext>(0);
}

SQLiteParser::Drop_stmtContext* SQLiteParser::Sql_stmtContext::drop_stmt() {
  return getRuleContext<SQLiteParser::Drop_stmtContext>(0);
}

SQLiteParser::Insert_stmtContext* SQLiteParser::Sql_stmtContext::insert_stmt() {
  return getRuleContext<SQLiteParser::Insert_stmtContext>(0);
}

SQLiteParser::Pragma_stmtContext* SQLiteParser::Sql_stmtContext::pragma_stmt() {
  return getRuleContext<SQLiteParser::Pragma_stmtContext>(0);
}

SQLiteParser::Reindex_stmtContext* SQLiteParser::Sql_stmtContext::reindex_stmt() {
  return getRuleContext<SQLiteParser::Reindex_stmtContext>(0);
}

SQLiteParser::Release_stmtContext* SQLiteParser::Sql_stmtContext::release_stmt() {
  return getRuleContext<SQLiteParser::Release_stmtContext>(0);
}

SQLiteParser::Rollback_stmtContext* SQLiteParser::Sql_stmtContext::rollback_stmt() {
  return getRuleContext<SQLiteParser::Rollback_stmtContext>(0);
}

SQLiteParser::Savepoint_stmtContext* SQLiteParser::Sql_stmtContext::savepoint_stmt() {
  return getRuleContext<SQLiteParser::Savepoint_stmtContext>(0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Sql_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

SQLiteParser::Update_stmtContext* SQLiteParser::Sql_stmtContext::update_stmt() {
  return getRuleContext<SQLiteParser::Update_stmtContext>(0);
}

SQLiteParser::Update_stmt_limitedContext* SQLiteParser::Sql_stmtContext::update_stmt_limited() {
  return getRuleContext<SQLiteParser::Update_stmt_limitedContext>(0);
}

SQLiteParser::Vacuum_stmtContext* SQLiteParser::Sql_stmtContext::vacuum_stmt() {
  return getRuleContext<SQLiteParser::Vacuum_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Sql_stmtContext::EXPLAIN_() {
  return getToken(SQLiteParser::EXPLAIN_, 0);
}

tree::TerminalNode* SQLiteParser::Sql_stmtContext::QUERY_() {
  return getToken(SQLiteParser::QUERY_, 0);
}

tree::TerminalNode* SQLiteParser::Sql_stmtContext::PLAN_() {
  return getToken(SQLiteParser::PLAN_, 0);
}


size_t SQLiteParser::Sql_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSql_stmt;
}

void SQLiteParser::Sql_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_stmt(this);
}

void SQLiteParser::Sql_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_stmt(this);
}


std::any SQLiteParser::Sql_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSql_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Sql_stmtContext* SQLiteParser::sql_stmt() {
  Sql_stmtContext *_localctx = _tracker.createInstance<Sql_stmtContext>(_ctx, getState());
  enterRule(_localctx, 4, SQLiteParser::RuleSql_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(230);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::EXPLAIN_) {
      setState(225);
      match(SQLiteParser::EXPLAIN_);
      setState(228);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::QUERY_) {
        setState(226);
        match(SQLiteParser::QUERY_);
        setState(227);
        match(SQLiteParser::PLAN_);
      }
    }
    setState(256);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      setState(232);
      alter_table_stmt();
      break;
    }

    case 2: {
      setState(233);
      analyze_stmt();
      break;
    }

    case 3: {
      setState(234);
      attach_stmt();
      break;
    }

    case 4: {
      setState(235);
      begin_stmt();
      break;
    }

    case 5: {
      setState(236);
      commit_stmt();
      break;
    }

    case 6: {
      setState(237);
      create_index_stmt();
      break;
    }

    case 7: {
      setState(238);
      create_table_stmt();
      break;
    }

    case 8: {
      setState(239);
      create_trigger_stmt();
      break;
    }

    case 9: {
      setState(240);
      create_view_stmt();
      break;
    }

    case 10: {
      setState(241);
      create_virtual_table_stmt();
      break;
    }

    case 11: {
      setState(242);
      delete_stmt();
      break;
    }

    case 12: {
      setState(243);
      delete_stmt_limited();
      break;
    }

    case 13: {
      setState(244);
      detach_stmt();
      break;
    }

    case 14: {
      setState(245);
      drop_stmt();
      break;
    }

    case 15: {
      setState(246);
      insert_stmt();
      break;
    }

    case 16: {
      setState(247);
      pragma_stmt();
      break;
    }

    case 17: {
      setState(248);
      reindex_stmt();
      break;
    }

    case 18: {
      setState(249);
      release_stmt();
      break;
    }

    case 19: {
      setState(250);
      rollback_stmt();
      break;
    }

    case 20: {
      setState(251);
      savepoint_stmt();
      break;
    }

    case 21: {
      setState(252);
      select_stmt();
      break;
    }

    case 22: {
      setState(253);
      update_stmt();
      break;
    }

    case 23: {
      setState(254);
      update_stmt_limited();
      break;
    }

    case 24: {
      setState(255);
      vacuum_stmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Alter_table_stmtContext::Alter_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::ALTER_() {
  return getToken(SQLiteParser::ALTER_, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

std::vector<SQLiteParser::Table_nameContext *> SQLiteParser::Alter_table_stmtContext::table_name() {
  return getRuleContexts<SQLiteParser::Table_nameContext>();
}

SQLiteParser::Table_nameContext* SQLiteParser::Alter_table_stmtContext::table_name(size_t i) {
  return getRuleContext<SQLiteParser::Table_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::RENAME_() {
  return getToken(SQLiteParser::RENAME_, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::ADD_() {
  return getToken(SQLiteParser::ADD_, 0);
}

SQLiteParser::Column_defContext* SQLiteParser::Alter_table_stmtContext::column_def() {
  return getRuleContext<SQLiteParser::Column_defContext>(0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::DROP_() {
  return getToken(SQLiteParser::DROP_, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Alter_table_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Alter_table_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Alter_table_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::TO_() {
  return getToken(SQLiteParser::TO_, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::COLUMN_() {
  return getToken(SQLiteParser::COLUMN_, 0);
}


size_t SQLiteParser::Alter_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleAlter_table_stmt;
}

void SQLiteParser::Alter_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_stmt(this);
}

void SQLiteParser::Alter_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_stmt(this);
}


std::any SQLiteParser::Alter_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Alter_table_stmtContext* SQLiteParser::alter_table_stmt() {
  Alter_table_stmtContext *_localctx = _tracker.createInstance<Alter_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 6, SQLiteParser::RuleAlter_table_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(258);
    match(SQLiteParser::ALTER_);
    setState(259);
    match(SQLiteParser::TABLE_);
    setState(263);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      setState(260);
      schema_name();
      setState(261);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(265);
    table_name();
    setState(288);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::RENAME_: {
        setState(266);
        match(SQLiteParser::RENAME_);
        setState(276);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
        case 1: {
          setState(267);
          match(SQLiteParser::TO_);
          setState(268);
          antlrcpp::downCast<Alter_table_stmtContext *>(_localctx)->new_table_name = table_name();
          break;
        }

        case 2: {
          setState(270);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
          case 1: {
            setState(269);
            match(SQLiteParser::COLUMN_);
            break;
          }

          default:
            break;
          }
          setState(272);
          antlrcpp::downCast<Alter_table_stmtContext *>(_localctx)->old_column_name = column_name();
          setState(273);
          match(SQLiteParser::TO_);
          setState(274);
          antlrcpp::downCast<Alter_table_stmtContext *>(_localctx)->new_column_name = column_name();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SQLiteParser::ADD_: {
        setState(278);
        match(SQLiteParser::ADD_);
        setState(280);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
        case 1: {
          setState(279);
          match(SQLiteParser::COLUMN_);
          break;
        }

        default:
          break;
        }
        setState(282);
        column_def();
        break;
      }

      case SQLiteParser::DROP_: {
        setState(283);
        match(SQLiteParser::DROP_);
        setState(285);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
        case 1: {
          setState(284);
          match(SQLiteParser::COLUMN_);
          break;
        }

        default:
          break;
        }
        setState(287);
        column_name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analyze_stmtContext ------------------------------------------------------------------

SQLiteParser::Analyze_stmtContext::Analyze_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Analyze_stmtContext::ANALYZE_() {
  return getToken(SQLiteParser::ANALYZE_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Analyze_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

SQLiteParser::Table_or_index_nameContext* SQLiteParser::Analyze_stmtContext::table_or_index_name() {
  return getRuleContext<SQLiteParser::Table_or_index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Analyze_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}


size_t SQLiteParser::Analyze_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleAnalyze_stmt;
}

void SQLiteParser::Analyze_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalyze_stmt(this);
}

void SQLiteParser::Analyze_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalyze_stmt(this);
}


std::any SQLiteParser::Analyze_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAnalyze_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Analyze_stmtContext* SQLiteParser::analyze_stmt() {
  Analyze_stmtContext *_localctx = _tracker.createInstance<Analyze_stmtContext>(_ctx, getState());
  enterRule(_localctx, 8, SQLiteParser::RuleAnalyze_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(290);
    match(SQLiteParser::ANALYZE_);
    setState(298);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      setState(291);
      schema_name();
      break;
    }

    case 2: {
      setState(295);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
      case 1: {
        setState(292);
        schema_name();
        setState(293);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(297);
      table_or_index_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attach_stmtContext ------------------------------------------------------------------

SQLiteParser::Attach_stmtContext::Attach_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Attach_stmtContext::ATTACH_() {
  return getToken(SQLiteParser::ATTACH_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Attach_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Attach_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Attach_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Attach_stmtContext::DATABASE_() {
  return getToken(SQLiteParser::DATABASE_, 0);
}


size_t SQLiteParser::Attach_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleAttach_stmt;
}

void SQLiteParser::Attach_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttach_stmt(this);
}

void SQLiteParser::Attach_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttach_stmt(this);
}


std::any SQLiteParser::Attach_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAttach_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Attach_stmtContext* SQLiteParser::attach_stmt() {
  Attach_stmtContext *_localctx = _tracker.createInstance<Attach_stmtContext>(_ctx, getState());
  enterRule(_localctx, 10, SQLiteParser::RuleAttach_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(300);
    match(SQLiteParser::ATTACH_);
    setState(302);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      setState(301);
      match(SQLiteParser::DATABASE_);
      break;
    }

    default:
      break;
    }
    setState(304);
    expr(0);
    setState(305);
    match(SQLiteParser::AS_);
    setState(306);
    schema_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Begin_stmtContext ------------------------------------------------------------------

SQLiteParser::Begin_stmtContext::Begin_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::BEGIN_() {
  return getToken(SQLiteParser::BEGIN_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::DEFERRED_() {
  return getToken(SQLiteParser::DEFERRED_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::IMMEDIATE_() {
  return getToken(SQLiteParser::IMMEDIATE_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::EXCLUSIVE_() {
  return getToken(SQLiteParser::EXCLUSIVE_, 0);
}


size_t SQLiteParser::Begin_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleBegin_stmt;
}

void SQLiteParser::Begin_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegin_stmt(this);
}

void SQLiteParser::Begin_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegin_stmt(this);
}


std::any SQLiteParser::Begin_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitBegin_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Begin_stmtContext* SQLiteParser::begin_stmt() {
  Begin_stmtContext *_localctx = _tracker.createInstance<Begin_stmtContext>(_ctx, getState());
  enterRule(_localctx, 12, SQLiteParser::RuleBegin_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(308);
    match(SQLiteParser::BEGIN_);
    setState(310);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 60) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 60)) & 16779265) != 0)) {
      setState(309);
      _la = _input->LA(1);
      if (!(((((_la - 60) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 60)) & 16779265) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(313);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TRANSACTION_) {
      setState(312);
      match(SQLiteParser::TRANSACTION_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Commit_stmtContext ------------------------------------------------------------------

SQLiteParser::Commit_stmtContext::Commit_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Commit_stmtContext::COMMIT_() {
  return getToken(SQLiteParser::COMMIT_, 0);
}

tree::TerminalNode* SQLiteParser::Commit_stmtContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

tree::TerminalNode* SQLiteParser::Commit_stmtContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}


size_t SQLiteParser::Commit_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCommit_stmt;
}

void SQLiteParser::Commit_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommit_stmt(this);
}

void SQLiteParser::Commit_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommit_stmt(this);
}


std::any SQLiteParser::Commit_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCommit_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Commit_stmtContext* SQLiteParser::commit_stmt() {
  Commit_stmtContext *_localctx = _tracker.createInstance<Commit_stmtContext>(_ctx, getState());
  enterRule(_localctx, 14, SQLiteParser::RuleCommit_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(315);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::COMMIT_

    || _la == SQLiteParser::END_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(317);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TRANSACTION_) {
      setState(316);
      match(SQLiteParser::TRANSACTION_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rollback_stmtContext ------------------------------------------------------------------

SQLiteParser::Rollback_stmtContext::Rollback_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::TO_() {
  return getToken(SQLiteParser::TO_, 0);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::Rollback_stmtContext::savepoint_name() {
  return getRuleContext<SQLiteParser::Savepoint_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}


size_t SQLiteParser::Rollback_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleRollback_stmt;
}

void SQLiteParser::Rollback_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRollback_stmt(this);
}

void SQLiteParser::Rollback_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRollback_stmt(this);
}


std::any SQLiteParser::Rollback_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRollback_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Rollback_stmtContext* SQLiteParser::rollback_stmt() {
  Rollback_stmtContext *_localctx = _tracker.createInstance<Rollback_stmtContext>(_ctx, getState());
  enterRule(_localctx, 16, SQLiteParser::RuleRollback_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(319);
    match(SQLiteParser::ROLLBACK_);
    setState(321);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TRANSACTION_) {
      setState(320);
      match(SQLiteParser::TRANSACTION_);
    }
    setState(328);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TO_) {
      setState(323);
      match(SQLiteParser::TO_);
      setState(325);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
      case 1: {
        setState(324);
        match(SQLiteParser::SAVEPOINT_);
        break;
      }

      default:
        break;
      }
      setState(327);
      savepoint_name();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Savepoint_stmtContext ------------------------------------------------------------------

SQLiteParser::Savepoint_stmtContext::Savepoint_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Savepoint_stmtContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::Savepoint_stmtContext::savepoint_name() {
  return getRuleContext<SQLiteParser::Savepoint_nameContext>(0);
}


size_t SQLiteParser::Savepoint_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSavepoint_stmt;
}

void SQLiteParser::Savepoint_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepoint_stmt(this);
}

void SQLiteParser::Savepoint_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepoint_stmt(this);
}


std::any SQLiteParser::Savepoint_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSavepoint_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Savepoint_stmtContext* SQLiteParser::savepoint_stmt() {
  Savepoint_stmtContext *_localctx = _tracker.createInstance<Savepoint_stmtContext>(_ctx, getState());
  enterRule(_localctx, 18, SQLiteParser::RuleSavepoint_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(330);
    match(SQLiteParser::SAVEPOINT_);
    setState(331);
    savepoint_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Release_stmtContext ------------------------------------------------------------------

SQLiteParser::Release_stmtContext::Release_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Release_stmtContext::RELEASE_() {
  return getToken(SQLiteParser::RELEASE_, 0);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::Release_stmtContext::savepoint_name() {
  return getRuleContext<SQLiteParser::Savepoint_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Release_stmtContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}


size_t SQLiteParser::Release_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleRelease_stmt;
}

void SQLiteParser::Release_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelease_stmt(this);
}

void SQLiteParser::Release_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelease_stmt(this);
}


std::any SQLiteParser::Release_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRelease_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Release_stmtContext* SQLiteParser::release_stmt() {
  Release_stmtContext *_localctx = _tracker.createInstance<Release_stmtContext>(_ctx, getState());
  enterRule(_localctx, 20, SQLiteParser::RuleRelease_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(333);
    match(SQLiteParser::RELEASE_);
    setState(335);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(334);
      match(SQLiteParser::SAVEPOINT_);
      break;
    }

    default:
      break;
    }
    setState(337);
    savepoint_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_index_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_index_stmtContext::Create_index_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::INDEX_() {
  return getToken(SQLiteParser::INDEX_, 0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Create_index_stmtContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_index_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Indexed_columnContext *> SQLiteParser::Create_index_stmtContext::indexed_column() {
  return getRuleContexts<SQLiteParser::Indexed_columnContext>();
}

SQLiteParser::Indexed_columnContext* SQLiteParser::Create_index_stmtContext::indexed_column(size_t i) {
  return getRuleContext<SQLiteParser::Indexed_columnContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_index_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_index_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Create_index_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}


size_t SQLiteParser::Create_index_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_index_stmt;
}

void SQLiteParser::Create_index_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_index_stmt(this);
}

void SQLiteParser::Create_index_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_index_stmt(this);
}


std::any SQLiteParser::Create_index_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_index_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_index_stmtContext* SQLiteParser::create_index_stmt() {
  Create_index_stmtContext *_localctx = _tracker.createInstance<Create_index_stmtContext>(_ctx, getState());
  enterRule(_localctx, 22, SQLiteParser::RuleCreate_index_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(339);
    match(SQLiteParser::CREATE_);
    setState(341);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::UNIQUE_) {
      setState(340);
      match(SQLiteParser::UNIQUE_);
    }
    setState(343);
    match(SQLiteParser::INDEX_);
    setState(347);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      setState(344);
      match(SQLiteParser::IF_);
      setState(345);
      match(SQLiteParser::NOT_);
      setState(346);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(352);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      setState(349);
      schema_name();
      setState(350);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(354);
    index_name();
    setState(355);
    match(SQLiteParser::ON_);
    setState(356);
    table_name();
    setState(357);
    match(SQLiteParser::OPEN_PAR);
    setState(358);
    indexed_column();
    setState(363);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(359);
      match(SQLiteParser::COMMA);
      setState(360);
      indexed_column();
      setState(365);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(366);
    match(SQLiteParser::CLOSE_PAR);
    setState(369);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(367);
      match(SQLiteParser::WHERE_);
      setState(368);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Indexed_columnContext ------------------------------------------------------------------

SQLiteParser::Indexed_columnContext::Indexed_columnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Column_nameContext* SQLiteParser::Indexed_columnContext::column_name() {
  return getRuleContext<SQLiteParser::Column_nameContext>(0);
}

SQLiteParser::ExprContext* SQLiteParser::Indexed_columnContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Indexed_columnContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Indexed_columnContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Asc_descContext* SQLiteParser::Indexed_columnContext::asc_desc() {
  return getRuleContext<SQLiteParser::Asc_descContext>(0);
}


size_t SQLiteParser::Indexed_columnContext::getRuleIndex() const {
  return SQLiteParser::RuleIndexed_column;
}

void SQLiteParser::Indexed_columnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexed_column(this);
}

void SQLiteParser::Indexed_columnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexed_column(this);
}


std::any SQLiteParser::Indexed_columnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitIndexed_column(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Indexed_columnContext* SQLiteParser::indexed_column() {
  Indexed_columnContext *_localctx = _tracker.createInstance<Indexed_columnContext>(_ctx, getState());
  enterRule(_localctx, 24, SQLiteParser::RuleIndexed_column);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(373);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(371);
      column_name();
      break;
    }

    case 2: {
      setState(372);
      expr(0);
      break;
    }

    default:
      break;
    }
    setState(377);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::COLLATE_) {
      setState(375);
      match(SQLiteParser::COLLATE_);
      setState(376);
      collation_name();
    }
    setState(380);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_) {
      setState(379);
      asc_desc();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_table_stmtContext::Create_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_table_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_defContext *> SQLiteParser::Create_table_stmtContext::column_def() {
  return getRuleContexts<SQLiteParser::Column_defContext>();
}

SQLiteParser::Column_defContext* SQLiteParser::Create_table_stmtContext::column_def(size_t i) {
  return getRuleContext<SQLiteParser::Column_defContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Create_table_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_table_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_table_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<SQLiteParser::Table_constraintContext *> SQLiteParser::Create_table_stmtContext::table_constraint() {
  return getRuleContexts<SQLiteParser::Table_constraintContext>();
}

SQLiteParser::Table_constraintContext* SQLiteParser::Create_table_stmtContext::table_constraint(size_t i) {
  return getRuleContext<SQLiteParser::Table_constraintContext>(i);
}

SQLiteParser::Table_optionsContext* SQLiteParser::Create_table_stmtContext::table_options() {
  return getRuleContext<SQLiteParser::Table_optionsContext>(0);
}


size_t SQLiteParser::Create_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_table_stmt;
}

void SQLiteParser::Create_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_stmt(this);
}

void SQLiteParser::Create_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_stmt(this);
}


std::any SQLiteParser::Create_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_table_stmtContext* SQLiteParser::create_table_stmt() {
  Create_table_stmtContext *_localctx = _tracker.createInstance<Create_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 26, SQLiteParser::RuleCreate_table_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(382);
    match(SQLiteParser::CREATE_);
    setState(384);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TEMP_

    || _la == SQLiteParser::TEMPORARY_) {
      setState(383);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::TEMP_

      || _la == SQLiteParser::TEMPORARY_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(386);
    match(SQLiteParser::TABLE_);
    setState(390);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(387);
      match(SQLiteParser::IF_);
      setState(388);
      match(SQLiteParser::NOT_);
      setState(389);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(395);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      setState(392);
      schema_name();
      setState(393);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(397);
    table_name();
    setState(420);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR: {
        setState(398);
        match(SQLiteParser::OPEN_PAR);
        setState(399);
        column_def();
        setState(404);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
        while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1 + 1) {
            setState(400);
            match(SQLiteParser::COMMA);
            setState(401);
            column_def(); 
          }
          setState(406);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
        }
        setState(411);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(407);
          match(SQLiteParser::COMMA);
          setState(408);
          table_constraint();
          setState(413);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(414);
        match(SQLiteParser::CLOSE_PAR);
        setState(416);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::STRICT_

        || _la == SQLiteParser::WITHOUT_) {
          setState(415);
          table_options();
        }
        break;
      }

      case SQLiteParser::AS_: {
        setState(418);
        match(SQLiteParser::AS_);
        setState(419);
        select_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_optionsContext ------------------------------------------------------------------

SQLiteParser::Table_optionsContext::Table_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SQLiteParser::Table_optionsContext::WITHOUT_() {
  return getTokens(SQLiteParser::WITHOUT_);
}

tree::TerminalNode* SQLiteParser::Table_optionsContext::WITHOUT_(size_t i) {
  return getToken(SQLiteParser::WITHOUT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Table_optionsContext::ROWID_() {
  return getTokens(SQLiteParser::ROWID_);
}

tree::TerminalNode* SQLiteParser::Table_optionsContext::ROWID_(size_t i) {
  return getToken(SQLiteParser::ROWID_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Table_optionsContext::STRICT_() {
  return getTokens(SQLiteParser::STRICT_);
}

tree::TerminalNode* SQLiteParser::Table_optionsContext::STRICT_(size_t i) {
  return getToken(SQLiteParser::STRICT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Table_optionsContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Table_optionsContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Table_optionsContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_options;
}

void SQLiteParser::Table_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_options(this);
}

void SQLiteParser::Table_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_options(this);
}


std::any SQLiteParser::Table_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_options(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_optionsContext* SQLiteParser::table_options() {
  Table_optionsContext *_localctx = _tracker.createInstance<Table_optionsContext>(_ctx, getState());
  enterRule(_localctx, 28, SQLiteParser::RuleTable_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(425);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::WITHOUT_: {
        setState(422);
        match(SQLiteParser::WITHOUT_);
        setState(423);
        match(SQLiteParser::ROWID_);
        break;
      }

      case SQLiteParser::STRICT_: {
        setState(424);
        match(SQLiteParser::STRICT_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(435);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(427);
      match(SQLiteParser::COMMA);
      setState(431);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::WITHOUT_: {
          setState(428);
          match(SQLiteParser::WITHOUT_);
          setState(429);
          match(SQLiteParser::ROWID_);
          break;
        }

        case SQLiteParser::STRICT_: {
          setState(430);
          match(SQLiteParser::STRICT_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(437);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_defContext ------------------------------------------------------------------

SQLiteParser::Column_defContext::Column_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Column_nameContext* SQLiteParser::Column_defContext::column_name() {
  return getRuleContext<SQLiteParser::Column_nameContext>(0);
}

SQLiteParser::Type_nameContext* SQLiteParser::Column_defContext::type_name() {
  return getRuleContext<SQLiteParser::Type_nameContext>(0);
}

std::vector<SQLiteParser::Column_constraintContext *> SQLiteParser::Column_defContext::column_constraint() {
  return getRuleContexts<SQLiteParser::Column_constraintContext>();
}

SQLiteParser::Column_constraintContext* SQLiteParser::Column_defContext::column_constraint(size_t i) {
  return getRuleContext<SQLiteParser::Column_constraintContext>(i);
}


size_t SQLiteParser::Column_defContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_def;
}

void SQLiteParser::Column_defContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_def(this);
}

void SQLiteParser::Column_defContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_def(this);
}


std::any SQLiteParser::Column_defContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_def(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_defContext* SQLiteParser::column_def() {
  Column_defContext *_localctx = _tracker.createInstance<Column_defContext>(_ctx, getState());
  enterRule(_localctx, 30, SQLiteParser::RuleColumn_def);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(438);
    column_name();
    setState(440);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1 + 1: {
      setState(439);
      type_name();
      break;
    }

    default:
      break;
    }
    setState(445);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 290693316557668352) != 0) || ((((_la - 105) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 105)) & 576461851815086085) != 0)) {
      setState(442);
      column_constraint();
      setState(447);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_nameContext ------------------------------------------------------------------

SQLiteParser::Type_nameContext::Type_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::NameContext *> SQLiteParser::Type_nameContext::name() {
  return getRuleContexts<SQLiteParser::NameContext>();
}

SQLiteParser::NameContext* SQLiteParser::Type_nameContext::name(size_t i) {
  return getRuleContext<SQLiteParser::NameContext>(i);
}

tree::TerminalNode* SQLiteParser::Type_nameContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Signed_numberContext *> SQLiteParser::Type_nameContext::signed_number() {
  return getRuleContexts<SQLiteParser::Signed_numberContext>();
}

SQLiteParser::Signed_numberContext* SQLiteParser::Type_nameContext::signed_number(size_t i) {
  return getRuleContext<SQLiteParser::Signed_numberContext>(i);
}

tree::TerminalNode* SQLiteParser::Type_nameContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Type_nameContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}


size_t SQLiteParser::Type_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleType_name;
}

void SQLiteParser::Type_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_name(this);
}

void SQLiteParser::Type_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_name(this);
}


std::any SQLiteParser::Type_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitType_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Type_nameContext* SQLiteParser::type_name() {
  Type_nameContext *_localctx = _tracker.createInstance<Type_nameContext>(_ctx, getState());
  enterRule(_localctx, 32, SQLiteParser::RuleType_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(449); 
    _errHandler->sync(this);
    alt = 1 + 1;
    do {
      switch (alt) {
        case 1 + 1: {
              setState(448);
              name();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(451); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
    } while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(463);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(453);
      match(SQLiteParser::OPEN_PAR);
      setState(454);
      signed_number();
      setState(455);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 2: {
      setState(457);
      match(SQLiteParser::OPEN_PAR);
      setState(458);
      signed_number();
      setState(459);
      match(SQLiteParser::COMMA);
      setState(460);
      signed_number();
      setState(461);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_constraintContext ------------------------------------------------------------------

SQLiteParser::Column_constraintContext::Column_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::CHECK_() {
  return getToken(SQLiteParser::CHECK_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Column_constraintContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::DEFAULT_() {
  return getToken(SQLiteParser::DEFAULT_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Column_constraintContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Foreign_key_clauseContext* SQLiteParser::Column_constraintContext::foreign_key_clause() {
  return getRuleContext<SQLiteParser::Foreign_key_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::CONSTRAINT_() {
  return getToken(SQLiteParser::CONSTRAINT_, 0);
}

SQLiteParser::NameContext* SQLiteParser::Column_constraintContext::name() {
  return getRuleContext<SQLiteParser::NameContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::PRIMARY_() {
  return getToken(SQLiteParser::PRIMARY_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::KEY_() {
  return getToken(SQLiteParser::KEY_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

SQLiteParser::Signed_numberContext* SQLiteParser::Column_constraintContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}

SQLiteParser::Literal_valueContext* SQLiteParser::Column_constraintContext::literal_value() {
  return getRuleContext<SQLiteParser::Literal_valueContext>(0);
}

SQLiteParser::Conflict_clauseContext* SQLiteParser::Column_constraintContext::conflict_clause() {
  return getRuleContext<SQLiteParser::Conflict_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::GENERATED_() {
  return getToken(SQLiteParser::GENERATED_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::ALWAYS_() {
  return getToken(SQLiteParser::ALWAYS_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::STORED_() {
  return getToken(SQLiteParser::STORED_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::VIRTUAL_() {
  return getToken(SQLiteParser::VIRTUAL_, 0);
}

SQLiteParser::Asc_descContext* SQLiteParser::Column_constraintContext::asc_desc() {
  return getRuleContext<SQLiteParser::Asc_descContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::AUTOINCREMENT_() {
  return getToken(SQLiteParser::AUTOINCREMENT_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}


size_t SQLiteParser::Column_constraintContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_constraint;
}

void SQLiteParser::Column_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_constraint(this);
}

void SQLiteParser::Column_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_constraint(this);
}


std::any SQLiteParser::Column_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_constraint(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_constraintContext* SQLiteParser::column_constraint() {
  Column_constraintContext *_localctx = _tracker.createInstance<Column_constraintContext>(_ctx, getState());
  enterRule(_localctx, 34, SQLiteParser::RuleColumn_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(467);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::CONSTRAINT_) {
      setState(465);
      match(SQLiteParser::CONSTRAINT_);
      setState(466);
      name();
    }
    setState(518);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::PRIMARY_: {
        setState(469);
        match(SQLiteParser::PRIMARY_);
        setState(470);
        match(SQLiteParser::KEY_);
        setState(472);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ASC_

        || _la == SQLiteParser::DESC_) {
          setState(471);
          asc_desc();
        }
        setState(475);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(474);
          conflict_clause();
        }
        setState(478);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::AUTOINCREMENT_) {
          setState(477);
          match(SQLiteParser::AUTOINCREMENT_);
        }
        break;
      }

      case SQLiteParser::NOT_:
      case SQLiteParser::NULL_:
      case SQLiteParser::UNIQUE_: {
        setState(485);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SQLiteParser::NOT_:
          case SQLiteParser::NULL_: {
            setState(481);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SQLiteParser::NOT_) {
              setState(480);
              match(SQLiteParser::NOT_);
            }
            setState(483);
            match(SQLiteParser::NULL_);
            break;
          }

          case SQLiteParser::UNIQUE_: {
            setState(484);
            match(SQLiteParser::UNIQUE_);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(488);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(487);
          conflict_clause();
        }
        break;
      }

      case SQLiteParser::CHECK_: {
        setState(490);
        match(SQLiteParser::CHECK_);
        setState(491);
        match(SQLiteParser::OPEN_PAR);
        setState(492);
        expr(0);
        setState(493);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::DEFAULT_: {
        setState(495);
        match(SQLiteParser::DEFAULT_);
        setState(502);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
        case 1: {
          setState(496);
          signed_number();
          break;
        }

        case 2: {
          setState(497);
          literal_value();
          break;
        }

        case 3: {
          setState(498);
          match(SQLiteParser::OPEN_PAR);
          setState(499);
          expr(0);
          setState(500);
          match(SQLiteParser::CLOSE_PAR);
          break;
        }

        default:
          break;
        }
        break;
      }

      case SQLiteParser::COLLATE_: {
        setState(504);
        match(SQLiteParser::COLLATE_);
        setState(505);
        collation_name();
        break;
      }

      case SQLiteParser::REFERENCES_: {
        setState(506);
        foreign_key_clause();
        break;
      }

      case SQLiteParser::AS_:
      case SQLiteParser::GENERATED_: {
        setState(509);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::GENERATED_) {
          setState(507);
          match(SQLiteParser::GENERATED_);
          setState(508);
          match(SQLiteParser::ALWAYS_);
        }
        setState(511);
        match(SQLiteParser::AS_);
        setState(512);
        match(SQLiteParser::OPEN_PAR);
        setState(513);
        expr(0);
        setState(514);
        match(SQLiteParser::CLOSE_PAR);
        setState(516);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::VIRTUAL_

        || _la == SQLiteParser::STORED_) {
          setState(515);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::VIRTUAL_

          || _la == SQLiteParser::STORED_)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Signed_numberContext ------------------------------------------------------------------

SQLiteParser::Signed_numberContext::Signed_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Signed_numberContext::NUMERIC_LITERAL() {
  return getToken(SQLiteParser::NUMERIC_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Signed_numberContext::PLUS() {
  return getToken(SQLiteParser::PLUS, 0);
}

tree::TerminalNode* SQLiteParser::Signed_numberContext::MINUS() {
  return getToken(SQLiteParser::MINUS, 0);
}


size_t SQLiteParser::Signed_numberContext::getRuleIndex() const {
  return SQLiteParser::RuleSigned_number;
}

void SQLiteParser::Signed_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigned_number(this);
}

void SQLiteParser::Signed_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigned_number(this);
}


std::any SQLiteParser::Signed_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSigned_number(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Signed_numberContext* SQLiteParser::signed_number() {
  Signed_numberContext *_localctx = _tracker.createInstance<Signed_numberContext>(_ctx, getState());
  enterRule(_localctx, 36, SQLiteParser::RuleSigned_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(521);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::PLUS

    || _la == SQLiteParser::MINUS) {
      setState(520);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::PLUS

      || _la == SQLiteParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(523);
    match(SQLiteParser::NUMERIC_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_constraintContext ------------------------------------------------------------------

SQLiteParser::Table_constraintContext::Table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Indexed_columnContext *> SQLiteParser::Table_constraintContext::indexed_column() {
  return getRuleContexts<SQLiteParser::Indexed_columnContext>();
}

SQLiteParser::Indexed_columnContext* SQLiteParser::Table_constraintContext::indexed_column(size_t i) {
  return getRuleContext<SQLiteParser::Indexed_columnContext>(i);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::CHECK_() {
  return getToken(SQLiteParser::CHECK_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Table_constraintContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::FOREIGN_() {
  return getToken(SQLiteParser::FOREIGN_, 0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::KEY_() {
  return getToken(SQLiteParser::KEY_, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Table_constraintContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Table_constraintContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

SQLiteParser::Foreign_key_clauseContext* SQLiteParser::Table_constraintContext::foreign_key_clause() {
  return getRuleContext<SQLiteParser::Foreign_key_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::CONSTRAINT_() {
  return getToken(SQLiteParser::CONSTRAINT_, 0);
}

SQLiteParser::NameContext* SQLiteParser::Table_constraintContext::name() {
  return getRuleContext<SQLiteParser::NameContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::PRIMARY_() {
  return getToken(SQLiteParser::PRIMARY_, 0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Table_constraintContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::Conflict_clauseContext* SQLiteParser::Table_constraintContext::conflict_clause() {
  return getRuleContext<SQLiteParser::Conflict_clauseContext>(0);
}


size_t SQLiteParser::Table_constraintContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_constraint;
}

void SQLiteParser::Table_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_constraint(this);
}

void SQLiteParser::Table_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_constraint(this);
}


std::any SQLiteParser::Table_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_constraint(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_constraintContext* SQLiteParser::table_constraint() {
  Table_constraintContext *_localctx = _tracker.createInstance<Table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 38, SQLiteParser::RuleTable_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(527);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::CONSTRAINT_) {
      setState(525);
      match(SQLiteParser::CONSTRAINT_);
      setState(526);
      name();
    }
    setState(566);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::UNIQUE_: {
        setState(532);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SQLiteParser::PRIMARY_: {
            setState(529);
            match(SQLiteParser::PRIMARY_);
            setState(530);
            match(SQLiteParser::KEY_);
            break;
          }

          case SQLiteParser::UNIQUE_: {
            setState(531);
            match(SQLiteParser::UNIQUE_);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(534);
        match(SQLiteParser::OPEN_PAR);
        setState(535);
        indexed_column();
        setState(540);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(536);
          match(SQLiteParser::COMMA);
          setState(537);
          indexed_column();
          setState(542);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(543);
        match(SQLiteParser::CLOSE_PAR);
        setState(545);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(544);
          conflict_clause();
        }
        break;
      }

      case SQLiteParser::CHECK_: {
        setState(547);
        match(SQLiteParser::CHECK_);
        setState(548);
        match(SQLiteParser::OPEN_PAR);
        setState(549);
        expr(0);
        setState(550);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::FOREIGN_: {
        setState(552);
        match(SQLiteParser::FOREIGN_);
        setState(553);
        match(SQLiteParser::KEY_);
        setState(554);
        match(SQLiteParser::OPEN_PAR);
        setState(555);
        column_name();
        setState(560);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(556);
          match(SQLiteParser::COMMA);
          setState(557);
          column_name();
          setState(562);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(563);
        match(SQLiteParser::CLOSE_PAR);
        setState(564);
        foreign_key_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Foreign_key_clauseContext ------------------------------------------------------------------

SQLiteParser::Foreign_key_clauseContext::Foreign_key_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::REFERENCES_() {
  return getToken(SQLiteParser::REFERENCES_, 0);
}

SQLiteParser::Foreign_tableContext* SQLiteParser::Foreign_key_clauseContext::foreign_table() {
  return getRuleContext<SQLiteParser::Foreign_tableContext>(0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Foreign_key_clauseContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Foreign_key_clauseContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::ON_() {
  return getTokens(SQLiteParser::ON_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::ON_(size_t i) {
  return getToken(SQLiteParser::ON_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::MATCH_() {
  return getTokens(SQLiteParser::MATCH_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::MATCH_(size_t i) {
  return getToken(SQLiteParser::MATCH_, i);
}

std::vector<SQLiteParser::NameContext *> SQLiteParser::Foreign_key_clauseContext::name() {
  return getRuleContexts<SQLiteParser::NameContext>();
}

SQLiteParser::NameContext* SQLiteParser::Foreign_key_clauseContext::name(size_t i) {
  return getRuleContext<SQLiteParser::NameContext>(i);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DEFERRABLE_() {
  return getToken(SQLiteParser::DEFERRABLE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::DELETE_() {
  return getTokens(SQLiteParser::DELETE_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DELETE_(size_t i) {
  return getToken(SQLiteParser::DELETE_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::UPDATE_() {
  return getTokens(SQLiteParser::UPDATE_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::UPDATE_(size_t i) {
  return getToken(SQLiteParser::UPDATE_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::SET_() {
  return getTokens(SQLiteParser::SET_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::SET_(size_t i) {
  return getToken(SQLiteParser::SET_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::CASCADE_() {
  return getTokens(SQLiteParser::CASCADE_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::CASCADE_(size_t i) {
  return getToken(SQLiteParser::CASCADE_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::RESTRICT_() {
  return getTokens(SQLiteParser::RESTRICT_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::RESTRICT_(size_t i) {
  return getToken(SQLiteParser::RESTRICT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::NO_() {
  return getTokens(SQLiteParser::NO_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::NO_(size_t i) {
  return getToken(SQLiteParser::NO_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::ACTION_() {
  return getTokens(SQLiteParser::ACTION_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::ACTION_(size_t i) {
  return getToken(SQLiteParser::ACTION_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::NULL_() {
  return getTokens(SQLiteParser::NULL_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::NULL_(size_t i) {
  return getToken(SQLiteParser::NULL_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::DEFAULT_() {
  return getTokens(SQLiteParser::DEFAULT_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DEFAULT_(size_t i) {
  return getToken(SQLiteParser::DEFAULT_, i);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::INITIALLY_() {
  return getToken(SQLiteParser::INITIALLY_, 0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DEFERRED_() {
  return getToken(SQLiteParser::DEFERRED_, 0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::IMMEDIATE_() {
  return getToken(SQLiteParser::IMMEDIATE_, 0);
}


size_t SQLiteParser::Foreign_key_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleForeign_key_clause;
}

void SQLiteParser::Foreign_key_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForeign_key_clause(this);
}

void SQLiteParser::Foreign_key_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForeign_key_clause(this);
}


std::any SQLiteParser::Foreign_key_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitForeign_key_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Foreign_key_clauseContext* SQLiteParser::foreign_key_clause() {
  Foreign_key_clauseContext *_localctx = _tracker.createInstance<Foreign_key_clauseContext>(_ctx, getState());
  enterRule(_localctx, 40, SQLiteParser::RuleForeign_key_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(568);
    match(SQLiteParser::REFERENCES_);
    setState(569);
    foreign_table();
    setState(581);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(570);
      match(SQLiteParser::OPEN_PAR);
      setState(571);
      column_name();
      setState(576);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(572);
        match(SQLiteParser::COMMA);
        setState(573);
        column_name();
        setState(578);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(579);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(597);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::MATCH_

    || _la == SQLiteParser::ON_) {
      setState(595);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::ON_: {
          setState(583);
          match(SQLiteParser::ON_);
          setState(584);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::DELETE_ || _la == SQLiteParser::UPDATE_)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(591);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case SQLiteParser::SET_: {
              setState(585);
              match(SQLiteParser::SET_);
              setState(586);
              _la = _input->LA(1);
              if (!(_la == SQLiteParser::DEFAULT_

              || _la == SQLiteParser::NULL_)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              break;
            }

            case SQLiteParser::CASCADE_: {
              setState(587);
              match(SQLiteParser::CASCADE_);
              break;
            }

            case SQLiteParser::RESTRICT_: {
              setState(588);
              match(SQLiteParser::RESTRICT_);
              break;
            }

            case SQLiteParser::NO_: {
              setState(589);
              match(SQLiteParser::NO_);
              setState(590);
              match(SQLiteParser::ACTION_);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case SQLiteParser::MATCH_: {
          setState(593);
          match(SQLiteParser::MATCH_);
          setState(594);
          name();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(599);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(608);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(601);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::NOT_) {
        setState(600);
        match(SQLiteParser::NOT_);
      }
      setState(603);
      match(SQLiteParser::DEFERRABLE_);
      setState(606);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::INITIALLY_) {
        setState(604);
        match(SQLiteParser::INITIALLY_);
        setState(605);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::DEFERRED_

        || _la == SQLiteParser::IMMEDIATE_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conflict_clauseContext ------------------------------------------------------------------

SQLiteParser::Conflict_clauseContext::Conflict_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::CONFLICT_() {
  return getToken(SQLiteParser::CONFLICT_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}


size_t SQLiteParser::Conflict_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleConflict_clause;
}

void SQLiteParser::Conflict_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConflict_clause(this);
}

void SQLiteParser::Conflict_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConflict_clause(this);
}


std::any SQLiteParser::Conflict_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitConflict_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Conflict_clauseContext* SQLiteParser::conflict_clause() {
  Conflict_clauseContext *_localctx = _tracker.createInstance<Conflict_clauseContext>(_ctx, getState());
  enterRule(_localctx, 42, SQLiteParser::RuleConflict_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(610);
    match(SQLiteParser::ON_);
    setState(611);
    match(SQLiteParser::CONFLICT_);
    setState(612);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::ABORT_ || ((((_la - 74) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 74)) & 38280596832649729) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_trigger_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_trigger_stmtContext::Create_trigger_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::TRIGGER_() {
  return getToken(SQLiteParser::TRIGGER_, 0);
}

SQLiteParser::Trigger_nameContext* SQLiteParser::Create_trigger_stmtContext::trigger_name() {
  return getRuleContext<SQLiteParser::Trigger_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_trigger_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::BEGIN_() {
  return getToken(SQLiteParser::BEGIN_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::INSERT_() {
  return getToken(SQLiteParser::INSERT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_trigger_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::BEFORE_() {
  return getToken(SQLiteParser::BEFORE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::AFTER_() {
  return getToken(SQLiteParser::AFTER_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::INSTEAD_() {
  return getToken(SQLiteParser::INSTEAD_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_trigger_stmtContext::OF_() {
  return getTokens(SQLiteParser::OF_);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::OF_(size_t i) {
  return getToken(SQLiteParser::OF_, i);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::FOR_() {
  return getToken(SQLiteParser::FOR_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::EACH_() {
  return getToken(SQLiteParser::EACH_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::WHEN_() {
  return getToken(SQLiteParser::WHEN_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Create_trigger_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_trigger_stmtContext::SCOL() {
  return getTokens(SQLiteParser::SCOL);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::SCOL(size_t i) {
  return getToken(SQLiteParser::SCOL, i);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Create_trigger_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Create_trigger_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Update_stmtContext *> SQLiteParser::Create_trigger_stmtContext::update_stmt() {
  return getRuleContexts<SQLiteParser::Update_stmtContext>();
}

SQLiteParser::Update_stmtContext* SQLiteParser::Create_trigger_stmtContext::update_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Update_stmtContext>(i);
}

std::vector<SQLiteParser::Insert_stmtContext *> SQLiteParser::Create_trigger_stmtContext::insert_stmt() {
  return getRuleContexts<SQLiteParser::Insert_stmtContext>();
}

SQLiteParser::Insert_stmtContext* SQLiteParser::Create_trigger_stmtContext::insert_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Insert_stmtContext>(i);
}

std::vector<SQLiteParser::Delete_stmtContext *> SQLiteParser::Create_trigger_stmtContext::delete_stmt() {
  return getRuleContexts<SQLiteParser::Delete_stmtContext>();
}

SQLiteParser::Delete_stmtContext* SQLiteParser::Create_trigger_stmtContext::delete_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Delete_stmtContext>(i);
}

std::vector<SQLiteParser::Select_stmtContext *> SQLiteParser::Create_trigger_stmtContext::select_stmt() {
  return getRuleContexts<SQLiteParser::Select_stmtContext>();
}

SQLiteParser::Select_stmtContext* SQLiteParser::Create_trigger_stmtContext::select_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Select_stmtContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_trigger_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Create_trigger_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_trigger_stmt;
}

void SQLiteParser::Create_trigger_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_trigger_stmt(this);
}

void SQLiteParser::Create_trigger_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_trigger_stmt(this);
}


std::any SQLiteParser::Create_trigger_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_trigger_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_trigger_stmtContext* SQLiteParser::create_trigger_stmt() {
  Create_trigger_stmtContext *_localctx = _tracker.createInstance<Create_trigger_stmtContext>(_ctx, getState());
  enterRule(_localctx, 44, SQLiteParser::RuleCreate_trigger_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(614);
    match(SQLiteParser::CREATE_);
    setState(616);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TEMP_

    || _la == SQLiteParser::TEMPORARY_) {
      setState(615);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::TEMP_

      || _la == SQLiteParser::TEMPORARY_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(618);
    match(SQLiteParser::TRIGGER_);
    setState(622);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
    case 1: {
      setState(619);
      match(SQLiteParser::IF_);
      setState(620);
      match(SQLiteParser::NOT_);
      setState(621);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(627);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      setState(624);
      schema_name();
      setState(625);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(629);
    trigger_name();
    setState(634);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::BEFORE_: {
        setState(630);
        match(SQLiteParser::BEFORE_);
        break;
      }

      case SQLiteParser::AFTER_: {
        setState(631);
        match(SQLiteParser::AFTER_);
        break;
      }

      case SQLiteParser::INSTEAD_: {
        setState(632);
        match(SQLiteParser::INSTEAD_);
        setState(633);
        match(SQLiteParser::OF_);
        break;
      }

      case SQLiteParser::DELETE_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::UPDATE_: {
        break;
      }

    default:
      break;
    }
    setState(650);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::DELETE_: {
        setState(636);
        match(SQLiteParser::DELETE_);
        break;
      }

      case SQLiteParser::INSERT_: {
        setState(637);
        match(SQLiteParser::INSERT_);
        break;
      }

      case SQLiteParser::UPDATE_: {
        setState(638);
        match(SQLiteParser::UPDATE_);
        setState(648);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::OF_) {
          setState(639);
          match(SQLiteParser::OF_);
          setState(640);
          column_name();
          setState(645);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(641);
            match(SQLiteParser::COMMA);
            setState(642);
            column_name();
            setState(647);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(652);
    match(SQLiteParser::ON_);
    setState(653);
    table_name();
    setState(657);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FOR_) {
      setState(654);
      match(SQLiteParser::FOR_);
      setState(655);
      match(SQLiteParser::EACH_);
      setState(656);
      match(SQLiteParser::ROW_);
    }
    setState(661);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHEN_) {
      setState(659);
      match(SQLiteParser::WHEN_);
      setState(660);
      expr(0);
    }
    setState(663);
    match(SQLiteParser::BEGIN_);
    setState(672); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(668);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
      case 1: {
        setState(664);
        update_stmt();
        break;
      }

      case 2: {
        setState(665);
        insert_stmt();
        break;
      }

      case 3: {
        setState(666);
        delete_stmt();
        break;
      }

      case 4: {
        setState(667);
        select_stmt();
        break;
      }

      default:
        break;
      }
      setState(670);
      match(SQLiteParser::SCOL);
      setState(674); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SQLiteParser::DELETE_

    || _la == SQLiteParser::INSERT_ || ((((_la - 125) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 125)) & 555745793) != 0));
    setState(676);
    match(SQLiteParser::END_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_view_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_view_stmtContext::Create_view_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::VIEW_() {
  return getToken(SQLiteParser::VIEW_, 0);
}

SQLiteParser::View_nameContext* SQLiteParser::Create_view_stmtContext::view_name() {
  return getRuleContext<SQLiteParser::View_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Create_view_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_view_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Create_view_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Create_view_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_view_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Create_view_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_view_stmt;
}

void SQLiteParser::Create_view_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_view_stmt(this);
}

void SQLiteParser::Create_view_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_view_stmt(this);
}


std::any SQLiteParser::Create_view_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_view_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_view_stmtContext* SQLiteParser::create_view_stmt() {
  Create_view_stmtContext *_localctx = _tracker.createInstance<Create_view_stmtContext>(_ctx, getState());
  enterRule(_localctx, 46, SQLiteParser::RuleCreate_view_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(678);
    match(SQLiteParser::CREATE_);
    setState(680);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TEMP_

    || _la == SQLiteParser::TEMPORARY_) {
      setState(679);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::TEMP_

      || _la == SQLiteParser::TEMPORARY_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(682);
    match(SQLiteParser::VIEW_);
    setState(686);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(683);
      match(SQLiteParser::IF_);
      setState(684);
      match(SQLiteParser::NOT_);
      setState(685);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(691);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
    case 1: {
      setState(688);
      schema_name();
      setState(689);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(693);
    view_name();
    setState(705);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(694);
      match(SQLiteParser::OPEN_PAR);
      setState(695);
      column_name();
      setState(700);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(696);
        match(SQLiteParser::COMMA);
        setState(697);
        column_name();
        setState(702);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(703);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(707);
    match(SQLiteParser::AS_);
    setState(708);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_virtual_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_virtual_table_stmtContext::Create_virtual_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::VIRTUAL_() {
  return getToken(SQLiteParser::VIRTUAL_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_virtual_table_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::USING_() {
  return getToken(SQLiteParser::USING_, 0);
}

SQLiteParser::Module_nameContext* SQLiteParser::Create_virtual_table_stmtContext::module_name() {
  return getRuleContext<SQLiteParser::Module_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_virtual_table_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Module_argumentContext *> SQLiteParser::Create_virtual_table_stmtContext::module_argument() {
  return getRuleContexts<SQLiteParser::Module_argumentContext>();
}

SQLiteParser::Module_argumentContext* SQLiteParser::Create_virtual_table_stmtContext::module_argument(size_t i) {
  return getRuleContext<SQLiteParser::Module_argumentContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_virtual_table_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Create_virtual_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_virtual_table_stmt;
}

void SQLiteParser::Create_virtual_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_virtual_table_stmt(this);
}

void SQLiteParser::Create_virtual_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_virtual_table_stmt(this);
}


std::any SQLiteParser::Create_virtual_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_virtual_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_virtual_table_stmtContext* SQLiteParser::create_virtual_table_stmt() {
  Create_virtual_table_stmtContext *_localctx = _tracker.createInstance<Create_virtual_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 48, SQLiteParser::RuleCreate_virtual_table_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(710);
    match(SQLiteParser::CREATE_);
    setState(711);
    match(SQLiteParser::VIRTUAL_);
    setState(712);
    match(SQLiteParser::TABLE_);
    setState(716);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(713);
      match(SQLiteParser::IF_);
      setState(714);
      match(SQLiteParser::NOT_);
      setState(715);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(721);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(718);
      schema_name();
      setState(719);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(723);
    table_name();
    setState(724);
    match(SQLiteParser::USING_);
    setState(725);
    module_name();
    setState(737);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(726);
      match(SQLiteParser::OPEN_PAR);
      setState(727);
      module_argument();
      setState(732);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(728);
        match(SQLiteParser::COMMA);
        setState(729);
        module_argument();
        setState(734);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(735);
      match(SQLiteParser::CLOSE_PAR);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_clauseContext ------------------------------------------------------------------

SQLiteParser::With_clauseContext::With_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::With_clauseContext::WITH_() {
  return getToken(SQLiteParser::WITH_, 0);
}

std::vector<SQLiteParser::Common_table_expressionContext *> SQLiteParser::With_clauseContext::common_table_expression() {
  return getRuleContexts<SQLiteParser::Common_table_expressionContext>();
}

SQLiteParser::Common_table_expressionContext* SQLiteParser::With_clauseContext::common_table_expression(size_t i) {
  return getRuleContext<SQLiteParser::Common_table_expressionContext>(i);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::RECURSIVE_() {
  return getToken(SQLiteParser::RECURSIVE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::With_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::With_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleWith_clause;
}

void SQLiteParser::With_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_clause(this);
}

void SQLiteParser::With_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_clause(this);
}


std::any SQLiteParser::With_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWith_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::With_clauseContext* SQLiteParser::with_clause() {
  With_clauseContext *_localctx = _tracker.createInstance<With_clauseContext>(_ctx, getState());
  enterRule(_localctx, 50, SQLiteParser::RuleWith_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(739);
    match(SQLiteParser::WITH_);
    setState(741);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      setState(740);
      match(SQLiteParser::RECURSIVE_);
      break;
    }

    default:
      break;
    }
    setState(743);
    common_table_expression();
    setState(748);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(744);
      match(SQLiteParser::COMMA);
      setState(745);
      common_table_expression();
      setState(750);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_expressionContext ------------------------------------------------------------------

SQLiteParser::Common_table_expressionContext::Common_table_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Cte_table_nameContext* SQLiteParser::Common_table_expressionContext::cte_table_name() {
  return getRuleContext<SQLiteParser::Cte_table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Common_table_expressionContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::MATERIALIZED_() {
  return getToken(SQLiteParser::MATERIALIZED_, 0);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}


size_t SQLiteParser::Common_table_expressionContext::getRuleIndex() const {
  return SQLiteParser::RuleCommon_table_expression;
}

void SQLiteParser::Common_table_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommon_table_expression(this);
}

void SQLiteParser::Common_table_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommon_table_expression(this);
}


std::any SQLiteParser::Common_table_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCommon_table_expression(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Common_table_expressionContext* SQLiteParser::common_table_expression() {
  Common_table_expressionContext *_localctx = _tracker.createInstance<Common_table_expressionContext>(_ctx, getState());
  enterRule(_localctx, 52, SQLiteParser::RuleCommon_table_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(751);
    cte_table_name();
    setState(752);
    match(SQLiteParser::AS_);
    setState(757);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::MATERIALIZED_

    || _la == SQLiteParser::NOT_) {
      setState(754);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::NOT_) {
        setState(753);
        match(SQLiteParser::NOT_);
      }
      setState(756);
      match(SQLiteParser::MATERIALIZED_);
    }
    setState(759);
    match(SQLiteParser::OPEN_PAR);
    setState(760);
    select_stmt();
    setState(761);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cte_table_nameContext ------------------------------------------------------------------

SQLiteParser::Cte_table_nameContext::Cte_table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Table_nameContext* SQLiteParser::Cte_table_nameContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Cte_table_nameContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Cte_table_nameContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Cte_table_nameContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Cte_table_nameContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Cte_table_nameContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Cte_table_nameContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Cte_table_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleCte_table_name;
}

void SQLiteParser::Cte_table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCte_table_name(this);
}

void SQLiteParser::Cte_table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCte_table_name(this);
}


std::any SQLiteParser::Cte_table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCte_table_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Cte_table_nameContext* SQLiteParser::cte_table_name() {
  Cte_table_nameContext *_localctx = _tracker.createInstance<Cte_table_nameContext>(_ctx, getState());
  enterRule(_localctx, 54, SQLiteParser::RuleCte_table_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(763);
    table_name();
    setState(775);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(764);
      match(SQLiteParser::OPEN_PAR);
      setState(765);
      column_name();
      setState(770);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(766);
        match(SQLiteParser::COMMA);
        setState(767);
        column_name();
        setState(772);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(773);
      match(SQLiteParser::CLOSE_PAR);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmtContext ------------------------------------------------------------------

SQLiteParser::Delete_stmtContext::Delete_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Delete_stmtContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::Delete_stmtContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Delete_stmtContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

SQLiteParser::With_clauseContext* SQLiteParser::Delete_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Delete_stmtContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Delete_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Delete_stmtContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}


size_t SQLiteParser::Delete_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleDelete_stmt;
}

void SQLiteParser::Delete_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt(this);
}

void SQLiteParser::Delete_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt(this);
}


std::any SQLiteParser::Delete_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Delete_stmtContext* SQLiteParser::delete_stmt() {
  Delete_stmtContext *_localctx = _tracker.createInstance<Delete_stmtContext>(_ctx, getState());
  enterRule(_localctx, 56, SQLiteParser::RuleDelete_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(778);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(777);
      with_clause();
    }
    setState(780);
    match(SQLiteParser::DELETE_);
    setState(781);
    match(SQLiteParser::FROM_);
    setState(782);
    qualified_table_name();
    setState(785);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(783);
      match(SQLiteParser::WHERE_);
      setState(784);
      expr(0);
    }
    setState(788);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(787);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmt_limitedContext ------------------------------------------------------------------

SQLiteParser::Delete_stmt_limitedContext::Delete_stmt_limitedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Delete_stmt_limitedContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::Delete_stmt_limitedContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Delete_stmt_limitedContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

SQLiteParser::With_clauseContext* SQLiteParser::Delete_stmt_limitedContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Delete_stmt_limitedContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Delete_stmt_limitedContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Delete_stmt_limitedContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

SQLiteParser::Order_clauseContext* SQLiteParser::Delete_stmt_limitedContext::order_clause() {
  return getRuleContext<SQLiteParser::Order_clauseContext>(0);
}

SQLiteParser::Limit_clauseContext* SQLiteParser::Delete_stmt_limitedContext::limit_clause() {
  return getRuleContext<SQLiteParser::Limit_clauseContext>(0);
}


size_t SQLiteParser::Delete_stmt_limitedContext::getRuleIndex() const {
  return SQLiteParser::RuleDelete_stmt_limited;
}

void SQLiteParser::Delete_stmt_limitedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt_limited(this);
}

void SQLiteParser::Delete_stmt_limitedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt_limited(this);
}


std::any SQLiteParser::Delete_stmt_limitedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt_limited(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Delete_stmt_limitedContext* SQLiteParser::delete_stmt_limited() {
  Delete_stmt_limitedContext *_localctx = _tracker.createInstance<Delete_stmt_limitedContext>(_ctx, getState());
  enterRule(_localctx, 58, SQLiteParser::RuleDelete_stmt_limited);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(791);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(790);
      with_clause();
    }
    setState(793);
    match(SQLiteParser::DELETE_);
    setState(794);
    match(SQLiteParser::FROM_);
    setState(795);
    qualified_table_name();
    setState(798);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(796);
      match(SQLiteParser::WHERE_);
      setState(797);
      expr(0);
    }
    setState(801);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(800);
      returning_clause();
    }
    setState(804);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(803);
      order_clause();
    }
    setState(807);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(806);
      limit_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Detach_stmtContext ------------------------------------------------------------------

SQLiteParser::Detach_stmtContext::Detach_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Detach_stmtContext::DETACH_() {
  return getToken(SQLiteParser::DETACH_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Detach_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Detach_stmtContext::DATABASE_() {
  return getToken(SQLiteParser::DATABASE_, 0);
}


size_t SQLiteParser::Detach_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleDetach_stmt;
}

void SQLiteParser::Detach_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDetach_stmt(this);
}

void SQLiteParser::Detach_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDetach_stmt(this);
}


std::any SQLiteParser::Detach_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDetach_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Detach_stmtContext* SQLiteParser::detach_stmt() {
  Detach_stmtContext *_localctx = _tracker.createInstance<Detach_stmtContext>(_ctx, getState());
  enterRule(_localctx, 60, SQLiteParser::RuleDetach_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(809);
    match(SQLiteParser::DETACH_);
    setState(811);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(810);
      match(SQLiteParser::DATABASE_);
      break;
    }

    default:
      break;
    }
    setState(813);
    schema_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_stmtContext ------------------------------------------------------------------

SQLiteParser::Drop_stmtContext::Drop_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::DROP_() {
  return getToken(SQLiteParser::DROP_, 0);
}

SQLiteParser::Any_nameContext* SQLiteParser::Drop_stmtContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::INDEX_() {
  return getToken(SQLiteParser::INDEX_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::TRIGGER_() {
  return getToken(SQLiteParser::TRIGGER_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::VIEW_() {
  return getToken(SQLiteParser::VIEW_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Drop_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}


size_t SQLiteParser::Drop_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleDrop_stmt;
}

void SQLiteParser::Drop_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_stmt(this);
}

void SQLiteParser::Drop_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_stmt(this);
}


std::any SQLiteParser::Drop_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDrop_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Drop_stmtContext* SQLiteParser::drop_stmt() {
  Drop_stmtContext *_localctx = _tracker.createInstance<Drop_stmtContext>(_ctx, getState());
  enterRule(_localctx, 62, SQLiteParser::RuleDrop_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(815);
    match(SQLiteParser::DROP_);
    setState(816);
    antlrcpp::downCast<Drop_stmtContext *>(_localctx)->object = _input->LT(1);
    _la = _input->LA(1);
    if (!(((((_la - 86) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 86)) & 146366987889541121) != 0) || _la == SQLiteParser::VIEW_)) {
      antlrcpp::downCast<Drop_stmtContext *>(_localctx)->object = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(819);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      setState(817);
      match(SQLiteParser::IF_);
      setState(818);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(824);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      setState(821);
      schema_name();
      setState(822);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(826);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

SQLiteParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Literal_valueContext* SQLiteParser::ExprContext::literal_value() {
  return getRuleContext<SQLiteParser::Literal_valueContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::BIND_PARAMETER() {
  return getToken(SQLiteParser::BIND_PARAMETER, 0);
}

SQLiteParser::Column_nameContext* SQLiteParser::ExprContext::column_name() {
  return getRuleContext<SQLiteParser::Column_nameContext>(0);
}

SQLiteParser::Table_nameContext* SQLiteParser::ExprContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::ExprContext::DOT() {
  return getTokens(SQLiteParser::DOT);
}

tree::TerminalNode* SQLiteParser::ExprContext::DOT(size_t i) {
  return getToken(SQLiteParser::DOT, i);
}

SQLiteParser::Schema_nameContext* SQLiteParser::ExprContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::ExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::ExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::ExprContext::MINUS() {
  return getToken(SQLiteParser::MINUS, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::PLUS() {
  return getToken(SQLiteParser::PLUS, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::TILDE() {
  return getToken(SQLiteParser::TILDE, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

SQLiteParser::Function_nameContext* SQLiteParser::ExprContext::function_name() {
  return getRuleContext<SQLiteParser::Function_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::ExprContext::filter_clause() {
  return getRuleContext<SQLiteParser::Filter_clauseContext>(0);
}

SQLiteParser::Over_clauseContext* SQLiteParser::ExprContext::over_clause() {
  return getRuleContext<SQLiteParser::Over_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::ExprContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::ExprContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::Order_clauseContext* SQLiteParser::ExprContext::order_clause() {
  return getRuleContext<SQLiteParser::Order_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::CAST_() {
  return getToken(SQLiteParser::CAST_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Type_nameContext* SQLiteParser::ExprContext::type_name() {
  return getRuleContext<SQLiteParser::Type_nameContext>(0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::ExprContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::CASE_() {
  return getToken(SQLiteParser::CASE_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::ExprContext::WHEN_() {
  return getTokens(SQLiteParser::WHEN_);
}

tree::TerminalNode* SQLiteParser::ExprContext::WHEN_(size_t i) {
  return getToken(SQLiteParser::WHEN_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::ExprContext::THEN_() {
  return getTokens(SQLiteParser::THEN_);
}

tree::TerminalNode* SQLiteParser::ExprContext::THEN_(size_t i) {
  return getToken(SQLiteParser::THEN_, i);
}

tree::TerminalNode* SQLiteParser::ExprContext::ELSE_() {
  return getToken(SQLiteParser::ELSE_, 0);
}

SQLiteParser::Raise_functionContext* SQLiteParser::ExprContext::raise_function() {
  return getRuleContext<SQLiteParser::Raise_functionContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::PIPE2() {
  return getToken(SQLiteParser::PIPE2, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::JPTR() {
  return getToken(SQLiteParser::JPTR, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::JPTR2() {
  return getToken(SQLiteParser::JPTR2, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::DIV() {
  return getToken(SQLiteParser::DIV, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::MOD() {
  return getToken(SQLiteParser::MOD, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::LT2() {
  return getToken(SQLiteParser::LT2, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::GT2() {
  return getToken(SQLiteParser::GT2, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::AMP() {
  return getToken(SQLiteParser::AMP, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::PIPE() {
  return getToken(SQLiteParser::PIPE, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::LT() {
  return getToken(SQLiteParser::LT, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::LT_EQ() {
  return getToken(SQLiteParser::LT_EQ, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::GT() {
  return getToken(SQLiteParser::GT, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::GT_EQ() {
  return getToken(SQLiteParser::GT_EQ, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::ASSIGN() {
  return getToken(SQLiteParser::ASSIGN, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::EQ() {
  return getToken(SQLiteParser::EQ, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::NOT_EQ1() {
  return getToken(SQLiteParser::NOT_EQ1, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::NOT_EQ2() {
  return getToken(SQLiteParser::NOT_EQ2, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::IS_() {
  return getToken(SQLiteParser::IS_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::BETWEEN_() {
  return getToken(SQLiteParser::BETWEEN_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::AND_() {
  return getToken(SQLiteParser::AND_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::ExprContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::IN_() {
  return getToken(SQLiteParser::IN_, 0);
}

SQLiteParser::Table_function_nameContext* SQLiteParser::ExprContext::table_function_name() {
  return getRuleContext<SQLiteParser::Table_function_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::GLOB_() {
  return getToken(SQLiteParser::GLOB_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::REGEXP_() {
  return getToken(SQLiteParser::REGEXP_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::MATCH_() {
  return getToken(SQLiteParser::MATCH_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::LIKE_() {
  return getToken(SQLiteParser::LIKE_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::ESCAPE_() {
  return getToken(SQLiteParser::ESCAPE_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::ISNULL_() {
  return getToken(SQLiteParser::ISNULL_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::NOTNULL_() {
  return getToken(SQLiteParser::NOTNULL_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}


size_t SQLiteParser::ExprContext::getRuleIndex() const {
  return SQLiteParser::RuleExpr;
}

void SQLiteParser::ExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr(this);
}

void SQLiteParser::ExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr(this);
}


std::any SQLiteParser::ExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitExpr(this);
  else
    return visitor->visitChildren(this);
}


SQLiteParser::ExprContext* SQLiteParser::expr() {
   return expr(0);
}

SQLiteParser::ExprContext* SQLiteParser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SQLiteParser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  SQLiteParser::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 64;
  enterRecursionRule(_localctx, 64, SQLiteParser::RuleExpr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(920);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      setState(829);
      literal_value();
      break;
    }

    case 2: {
      setState(830);
      match(SQLiteParser::BIND_PARAMETER);
      break;
    }

    case 3: {
      setState(839);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
      case 1: {
        setState(834);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
        case 1: {
          setState(831);
          schema_name();
          setState(832);
          match(SQLiteParser::DOT);
          break;
        }

        default:
          break;
        }
        setState(836);
        table_name();
        setState(837);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(841);
      column_name();
      break;
    }

    case 4: {
      setState(842);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1792) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(843);
      expr(22);
      break;
    }

    case 5: {
      setState(844);
      match(SQLiteParser::NOT_);
      setState(845);
      expr(9);
      break;
    }

    case 6: {
      setState(846);
      function_name();
      setState(847);
      match(SQLiteParser::OPEN_PAR);
      setState(863);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::OPEN_PAR:
        case SQLiteParser::PLUS:
        case SQLiteParser::MINUS:
        case SQLiteParser::TILDE:
        case SQLiteParser::ABORT_:
        case SQLiteParser::ACTION_:
        case SQLiteParser::ADD_:
        case SQLiteParser::AFTER_:
        case SQLiteParser::ALL_:
        case SQLiteParser::ALTER_:
        case SQLiteParser::ANALYZE_:
        case SQLiteParser::AND_:
        case SQLiteParser::AS_:
        case SQLiteParser::ASC_:
        case SQLiteParser::ATTACH_:
        case SQLiteParser::AUTOINCREMENT_:
        case SQLiteParser::BEFORE_:
        case SQLiteParser::BEGIN_:
        case SQLiteParser::BETWEEN_:
        case SQLiteParser::BY_:
        case SQLiteParser::CASCADE_:
        case SQLiteParser::CASE_:
        case SQLiteParser::CAST_:
        case SQLiteParser::CHECK_:
        case SQLiteParser::COLLATE_:
        case SQLiteParser::COLUMN_:
        case SQLiteParser::COMMIT_:
        case SQLiteParser::CONFLICT_:
        case SQLiteParser::CONSTRAINT_:
        case SQLiteParser::CREATE_:
        case SQLiteParser::CROSS_:
        case SQLiteParser::CURRENT_DATE_:
        case SQLiteParser::CURRENT_TIME_:
        case SQLiteParser::CURRENT_TIMESTAMP_:
        case SQLiteParser::DATABASE_:
        case SQLiteParser::DEFAULT_:
        case SQLiteParser::DEFERRABLE_:
        case SQLiteParser::DEFERRED_:
        case SQLiteParser::DELETE_:
        case SQLiteParser::DESC_:
        case SQLiteParser::DETACH_:
        case SQLiteParser::DISTINCT_:
        case SQLiteParser::DROP_:
        case SQLiteParser::EACH_:
        case SQLiteParser::ELSE_:
        case SQLiteParser::END_:
        case SQLiteParser::ESCAPE_:
        case SQLiteParser::EXCEPT_:
        case SQLiteParser::EXCLUSIVE_:
        case SQLiteParser::EXISTS_:
        case SQLiteParser::EXPLAIN_:
        case SQLiteParser::FAIL_:
        case SQLiteParser::FOR_:
        case SQLiteParser::FOREIGN_:
        case SQLiteParser::FROM_:
        case SQLiteParser::FULL_:
        case SQLiteParser::GLOB_:
        case SQLiteParser::GROUP_:
        case SQLiteParser::HAVING_:
        case SQLiteParser::IF_:
        case SQLiteParser::IGNORE_:
        case SQLiteParser::IMMEDIATE_:
        case SQLiteParser::IN_:
        case SQLiteParser::INDEX_:
        case SQLiteParser::INDEXED_:
        case SQLiteParser::INITIALLY_:
        case SQLiteParser::INNER_:
        case SQLiteParser::INSERT_:
        case SQLiteParser::INSTEAD_:
        case SQLiteParser::INTERSECT_:
        case SQLiteParser::INTO_:
        case SQLiteParser::IS_:
        case SQLiteParser::ISNULL_:
        case SQLiteParser::JOIN_:
        case SQLiteParser::KEY_:
        case SQLiteParser::LEFT_:
        case SQLiteParser::LIKE_:
        case SQLiteParser::LIMIT_:
        case SQLiteParser::MATCH_:
        case SQLiteParser::MATERIALIZED_:
        case SQLiteParser::NATURAL_:
        case SQLiteParser::NO_:
        case SQLiteParser::NOT_:
        case SQLiteParser::NOTNULL_:
        case SQLiteParser::NULL_:
        case SQLiteParser::OF_:
        case SQLiteParser::OFFSET_:
        case SQLiteParser::ON_:
        case SQLiteParser::OR_:
        case SQLiteParser::ORDER_:
        case SQLiteParser::OUTER_:
        case SQLiteParser::PLAN_:
        case SQLiteParser::PRAGMA_:
        case SQLiteParser::PRIMARY_:
        case SQLiteParser::QUERY_:
        case SQLiteParser::RAISE_:
        case SQLiteParser::RECURSIVE_:
        case SQLiteParser::REFERENCES_:
        case SQLiteParser::REGEXP_:
        case SQLiteParser::REINDEX_:
        case SQLiteParser::RELEASE_:
        case SQLiteParser::RENAME_:
        case SQLiteParser::REPLACE_:
        case SQLiteParser::RESTRICT_:
        case SQLiteParser::RETURNING_:
        case SQLiteParser::RIGHT_:
        case SQLiteParser::ROLLBACK_:
        case SQLiteParser::ROW_:
        case SQLiteParser::ROWS_:
        case SQLiteParser::ROWID_:
        case SQLiteParser::SAVEPOINT_:
        case SQLiteParser::SELECT_:
        case SQLiteParser::SET_:
        case SQLiteParser::STRICT_:
        case SQLiteParser::TABLE_:
        case SQLiteParser::TEMP_:
        case SQLiteParser::TEMPORARY_:
        case SQLiteParser::THEN_:
        case SQLiteParser::TO_:
        case SQLiteParser::TRANSACTION_:
        case SQLiteParser::TRIGGER_:
        case SQLiteParser::UNION_:
        case SQLiteParser::UNIQUE_:
        case SQLiteParser::UPDATE_:
        case SQLiteParser::USING_:
        case SQLiteParser::VACUUM_:
        case SQLiteParser::VALUES_:
        case SQLiteParser::VIEW_:
        case SQLiteParser::VIRTUAL_:
        case SQLiteParser::WHEN_:
        case SQLiteParser::WHERE_:
        case SQLiteParser::WITH_:
        case SQLiteParser::WITHOUT_:
        case SQLiteParser::OVER_:
        case SQLiteParser::PARTITION_:
        case SQLiteParser::RANGE_:
        case SQLiteParser::PRECEDING_:
        case SQLiteParser::UNBOUNDED_:
        case SQLiteParser::CURRENT_:
        case SQLiteParser::FOLLOWING_:
        case SQLiteParser::RANK_:
        case SQLiteParser::GENERATED_:
        case SQLiteParser::ALWAYS_:
        case SQLiteParser::STORED_:
        case SQLiteParser::TRUE_:
        case SQLiteParser::FALSE_:
        case SQLiteParser::WINDOW_:
        case SQLiteParser::NULLS_:
        case SQLiteParser::FIRST_:
        case SQLiteParser::LAST_:
        case SQLiteParser::FILTER_:
        case SQLiteParser::GROUPS_:
        case SQLiteParser::EXCLUDE_:
        case SQLiteParser::TIES_:
        case SQLiteParser::OTHERS_:
        case SQLiteParser::DO_:
        case SQLiteParser::NOTHING_:
        case SQLiteParser::IDENTIFIER:
        case SQLiteParser::NUMERIC_LITERAL:
        case SQLiteParser::BIND_PARAMETER:
        case SQLiteParser::STRING_LITERAL:
        case SQLiteParser::BLOB_LITERAL: {
          setState(849);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
          case 1: {
            setState(848);
            match(SQLiteParser::DISTINCT_);
            break;
          }

          default:
            break;
          }
          setState(851);
          expr(0);
          setState(856);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(852);
            match(SQLiteParser::COMMA);
            setState(853);
            expr(0);
            setState(858);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(860);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::ORDER_) {
            setState(859);
            order_clause();
          }
          break;
        }

        case SQLiteParser::STAR: {
          setState(862);
          match(SQLiteParser::STAR);
          break;
        }

        case SQLiteParser::CLOSE_PAR: {
          break;
        }

      default:
        break;
      }
      setState(865);
      match(SQLiteParser::CLOSE_PAR);
      setState(867);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
      case 1: {
        setState(866);
        filter_clause();
        break;
      }

      default:
        break;
      }
      setState(870);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
      case 1: {
        setState(869);
        over_clause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      setState(872);
      match(SQLiteParser::OPEN_PAR);
      setState(873);
      expr(0);
      setState(878);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(874);
        match(SQLiteParser::COMMA);
        setState(875);
        expr(0);
        setState(880);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(881);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 8: {
      setState(883);
      match(SQLiteParser::CAST_);
      setState(884);
      match(SQLiteParser::OPEN_PAR);
      setState(885);
      expr(0);
      setState(886);
      match(SQLiteParser::AS_);
      setState(887);
      type_name();
      setState(888);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 9: {
      setState(894);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::EXISTS_

      || _la == SQLiteParser::NOT_) {
        setState(891);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::NOT_) {
          setState(890);
          match(SQLiteParser::NOT_);
        }
        setState(893);
        match(SQLiteParser::EXISTS_);
      }
      setState(896);
      match(SQLiteParser::OPEN_PAR);
      setState(897);
      select_stmt();
      setState(898);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 10: {
      setState(900);
      match(SQLiteParser::CASE_);
      setState(902);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
      case 1: {
        setState(901);
        expr(0);
        break;
      }

      default:
        break;
      }
      setState(909); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(904);
        match(SQLiteParser::WHEN_);
        setState(905);
        expr(0);
        setState(906);
        match(SQLiteParser::THEN_);
        setState(907);
        expr(0);
        setState(911); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SQLiteParser::WHEN_);
      setState(915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ELSE_) {
        setState(913);
        match(SQLiteParser::ELSE_);
        setState(914);
        expr(0);
      }
      setState(917);
      match(SQLiteParser::END_);
      break;
    }

    case 11: {
      setState(919);
      raise_function();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1036);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1034);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(922);

          if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
          setState(923);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 100665344) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(924);
          expr(21);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(925);

          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, "precpred(_ctx, 19)");
          setState(926);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 12416) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(927);
          expr(20);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(928);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(929);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::PLUS

          || _la == SQLiteParser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(930);
          expr(19);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(931);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(932);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 245760) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(933);
          expr(18);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(934);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(935);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 3932160) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(936);
          expr(17);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(937);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(938);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 29360192) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(939);
          expr(16);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(940);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(941);
          match(SQLiteParser::IS_);
          setState(943);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
          case 1: {
            setState(942);
            match(SQLiteParser::NOT_);
            break;
          }

          default:
            break;
          }
          setState(947);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
          case 1: {
            setState(945);
            match(SQLiteParser::DISTINCT_);
            setState(946);
            match(SQLiteParser::FROM_);
            break;
          }

          default:
            break;
          }
          setState(949);
          expr(15);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(950);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(952);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::NOT_) {
            setState(951);
            match(SQLiteParser::NOT_);
          }
          setState(954);
          match(SQLiteParser::BETWEEN_);
          setState(955);
          expr(0);
          setState(956);
          match(SQLiteParser::AND_);
          setState(957);
          expr(14);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(959);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(960);
          match(SQLiteParser::AND_);
          setState(961);
          expr(9);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(962);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(963);
          match(SQLiteParser::OR_);
          setState(964);
          expr(8);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(965);

          if (!(precpred(_ctx, 21))) throw FailedPredicateException(this, "precpred(_ctx, 21)");
          setState(966);
          match(SQLiteParser::COLLATE_);
          setState(967);
          collation_name();
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(968);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(970);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::NOT_) {
            setState(969);
            match(SQLiteParser::NOT_);
          }
          setState(972);
          match(SQLiteParser::IN_);
          setState(1011);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
          case 1: {
            setState(973);
            match(SQLiteParser::OPEN_PAR);
            setState(983);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
            case 1: {
              setState(974);
              select_stmt();
              break;
            }

            case 2: {
              setState(975);
              expr(0);
              setState(980);
              _errHandler->sync(this);
              _la = _input->LA(1);
              while (_la == SQLiteParser::COMMA) {
                setState(976);
                match(SQLiteParser::COMMA);
                setState(977);
                expr(0);
                setState(982);
                _errHandler->sync(this);
                _la = _input->LA(1);
              }
              break;
            }

            default:
              break;
            }
            setState(985);
            match(SQLiteParser::CLOSE_PAR);
            break;
          }

          case 2: {
            setState(989);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
            case 1: {
              setState(986);
              schema_name();
              setState(987);
              match(SQLiteParser::DOT);
              break;
            }

            default:
              break;
            }
            setState(991);
            table_name();
            break;
          }

          case 3: {
            setState(995);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
            case 1: {
              setState(992);
              schema_name();
              setState(993);
              match(SQLiteParser::DOT);
              break;
            }

            default:
              break;
            }
            setState(997);
            table_function_name();
            setState(998);
            match(SQLiteParser::OPEN_PAR);
            setState(1007);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if ((((_la & ~ 0x3fULL) == 0) &&
              ((1ULL << _la) & -134215928) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 128)) & 144115188075855871) != 0)) {
              setState(999);
              expr(0);
              setState(1004);
              _errHandler->sync(this);
              _la = _input->LA(1);
              while (_la == SQLiteParser::COMMA) {
                setState(1000);
                match(SQLiteParser::COMMA);
                setState(1001);
                expr(0);
                setState(1006);
                _errHandler->sync(this);
                _la = _input->LA(1);
              }
            }
            setState(1009);
            match(SQLiteParser::CLOSE_PAR);
            break;
          }

          default:
            break;
          }
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1013);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(1015);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::NOT_) {
            setState(1014);
            match(SQLiteParser::NOT_);
          }
          setState(1025);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case SQLiteParser::LIKE_: {
              setState(1017);
              match(SQLiteParser::LIKE_);
              setState(1018);
              expr(0);
              setState(1021);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
              case 1: {
                setState(1019);
                match(SQLiteParser::ESCAPE_);
                setState(1020);
                expr(0);
                break;
              }

              default:
                break;
              }
              break;
            }

            case SQLiteParser::GLOB_:
            case SQLiteParser::MATCH_:
            case SQLiteParser::REGEXP_: {
              setState(1023);
              _la = _input->LA(1);
              if (!(((((_la - 79) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 79)) & 4398050705409) != 0))) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              setState(1024);
              expr(0);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1027);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(1032);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case SQLiteParser::ISNULL_: {
              setState(1028);
              match(SQLiteParser::ISNULL_);
              break;
            }

            case SQLiteParser::NOTNULL_: {
              setState(1029);
              match(SQLiteParser::NOTNULL_);
              break;
            }

            case SQLiteParser::NOT_: {
              setState(1030);
              match(SQLiteParser::NOT_);
              setState(1031);
              match(SQLiteParser::NULL_);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(1038);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Raise_functionContext ------------------------------------------------------------------

SQLiteParser::Raise_functionContext::Raise_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::RAISE_() {
  return getToken(SQLiteParser::RAISE_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

SQLiteParser::Error_messageContext* SQLiteParser::Raise_functionContext::error_message() {
  return getRuleContext<SQLiteParser::Error_messageContext>(0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}


size_t SQLiteParser::Raise_functionContext::getRuleIndex() const {
  return SQLiteParser::RuleRaise_function;
}

void SQLiteParser::Raise_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaise_function(this);
}

void SQLiteParser::Raise_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaise_function(this);
}


std::any SQLiteParser::Raise_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRaise_function(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Raise_functionContext* SQLiteParser::raise_function() {
  Raise_functionContext *_localctx = _tracker.createInstance<Raise_functionContext>(_ctx, getState());
  enterRule(_localctx, 66, SQLiteParser::RuleRaise_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1039);
    match(SQLiteParser::RAISE_);
    setState(1040);
    match(SQLiteParser::OPEN_PAR);
    setState(1045);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::IGNORE_: {
        setState(1041);
        match(SQLiteParser::IGNORE_);
        break;
      }

      case SQLiteParser::ABORT_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::ROLLBACK_: {
        setState(1042);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::ABORT_ || _la == SQLiteParser::FAIL_

        || _la == SQLiteParser::ROLLBACK_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1043);
        match(SQLiteParser::COMMA);
        setState(1044);
        error_message();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1047);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Literal_valueContext ------------------------------------------------------------------

SQLiteParser::Literal_valueContext::Literal_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::NUMERIC_LITERAL() {
  return getToken(SQLiteParser::NUMERIC_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::BLOB_LITERAL() {
  return getToken(SQLiteParser::BLOB_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::TRUE_() {
  return getToken(SQLiteParser::TRUE_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::FALSE_() {
  return getToken(SQLiteParser::FALSE_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::CURRENT_TIME_() {
  return getToken(SQLiteParser::CURRENT_TIME_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::CURRENT_DATE_() {
  return getToken(SQLiteParser::CURRENT_DATE_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::CURRENT_TIMESTAMP_() {
  return getToken(SQLiteParser::CURRENT_TIMESTAMP_, 0);
}


size_t SQLiteParser::Literal_valueContext::getRuleIndex() const {
  return SQLiteParser::RuleLiteral_value;
}

void SQLiteParser::Literal_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral_value(this);
}

void SQLiteParser::Literal_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral_value(this);
}


std::any SQLiteParser::Literal_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitLiteral_value(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Literal_valueContext* SQLiteParser::literal_value() {
  Literal_valueContext *_localctx = _tracker.createInstance<Literal_valueContext>(_ctx, getState());
  enterRule(_localctx, 68, SQLiteParser::RuleLiteral_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1049);
    _la = _input->LA(1);
    if (!(((((_la - 54) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 54)) & 9007199254740999) != 0) || ((((_la - 167) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 167)) & 212995) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Value_rowContext ------------------------------------------------------------------

SQLiteParser::Value_rowContext::Value_rowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Value_rowContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Value_rowContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Value_rowContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Value_rowContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Value_rowContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Value_rowContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Value_rowContext::getRuleIndex() const {
  return SQLiteParser::RuleValue_row;
}

void SQLiteParser::Value_rowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue_row(this);
}

void SQLiteParser::Value_rowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue_row(this);
}


std::any SQLiteParser::Value_rowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitValue_row(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Value_rowContext* SQLiteParser::value_row() {
  Value_rowContext *_localctx = _tracker.createInstance<Value_rowContext>(_ctx, getState());
  enterRule(_localctx, 70, SQLiteParser::RuleValue_row);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1051);
    match(SQLiteParser::OPEN_PAR);
    setState(1052);
    expr(0);
    setState(1057);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1053);
      match(SQLiteParser::COMMA);
      setState(1054);
      expr(0);
      setState(1059);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1060);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Values_clauseContext ------------------------------------------------------------------

SQLiteParser::Values_clauseContext::Values_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Values_clauseContext::VALUES_() {
  return getToken(SQLiteParser::VALUES_, 0);
}

std::vector<SQLiteParser::Value_rowContext *> SQLiteParser::Values_clauseContext::value_row() {
  return getRuleContexts<SQLiteParser::Value_rowContext>();
}

SQLiteParser::Value_rowContext* SQLiteParser::Values_clauseContext::value_row(size_t i) {
  return getRuleContext<SQLiteParser::Value_rowContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Values_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Values_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Values_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleValues_clause;
}

void SQLiteParser::Values_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValues_clause(this);
}

void SQLiteParser::Values_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValues_clause(this);
}


std::any SQLiteParser::Values_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitValues_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Values_clauseContext* SQLiteParser::values_clause() {
  Values_clauseContext *_localctx = _tracker.createInstance<Values_clauseContext>(_ctx, getState());
  enterRule(_localctx, 72, SQLiteParser::RuleValues_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1062);
    match(SQLiteParser::VALUES_);
    setState(1063);
    value_row();
    setState(1068);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1064);
      match(SQLiteParser::COMMA);
      setState(1065);
      value_row();
      setState(1070);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_stmtContext ------------------------------------------------------------------

SQLiteParser::Insert_stmtContext::Insert_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::INTO_() {
  return getToken(SQLiteParser::INTO_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Insert_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::INSERT_() {
  return getToken(SQLiteParser::INSERT_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::DEFAULT_() {
  return getToken(SQLiteParser::DEFAULT_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::VALUES_() {
  return getToken(SQLiteParser::VALUES_, 0);
}

SQLiteParser::With_clauseContext* SQLiteParser::Insert_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Insert_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Table_aliasContext* SQLiteParser::Insert_stmtContext::table_alias() {
  return getRuleContext<SQLiteParser::Table_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Insert_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Insert_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Insert_stmtContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Insert_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::Values_clauseContext* SQLiteParser::Insert_stmtContext::values_clause() {
  return getRuleContext<SQLiteParser::Values_clauseContext>(0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Insert_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

std::vector<SQLiteParser::Upsert_clauseContext *> SQLiteParser::Insert_stmtContext::upsert_clause() {
  return getRuleContexts<SQLiteParser::Upsert_clauseContext>();
}

SQLiteParser::Upsert_clauseContext* SQLiteParser::Insert_stmtContext::upsert_clause(size_t i) {
  return getRuleContext<SQLiteParser::Upsert_clauseContext>(i);
}


size_t SQLiteParser::Insert_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleInsert_stmt;
}

void SQLiteParser::Insert_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_stmt(this);
}

void SQLiteParser::Insert_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_stmt(this);
}


std::any SQLiteParser::Insert_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitInsert_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Insert_stmtContext* SQLiteParser::insert_stmt() {
  Insert_stmtContext *_localctx = _tracker.createInstance<Insert_stmtContext>(_ctx, getState());
  enterRule(_localctx, 74, SQLiteParser::RuleInsert_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1072);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1071);
      with_clause();
    }
    setState(1079);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
    case 1: {
      setState(1074);
      match(SQLiteParser::INSERT_);
      break;
    }

    case 2: {
      setState(1075);
      match(SQLiteParser::REPLACE_);
      break;
    }

    case 3: {
      setState(1076);
      match(SQLiteParser::INSERT_);
      setState(1077);
      match(SQLiteParser::OR_);
      setState(1078);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::ABORT_ || ((((_la - 74) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 74)) & 38280596832649729) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1081);
    match(SQLiteParser::INTO_);
    setState(1085);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
    case 1: {
      setState(1082);
      schema_name();
      setState(1083);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1087);
    table_name();
    setState(1090);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::AS_) {
      setState(1088);
      match(SQLiteParser::AS_);
      setState(1089);
      table_alias();
    }
    setState(1103);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(1092);
      match(SQLiteParser::OPEN_PAR);
      setState(1093);
      column_name();
      setState(1098);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1094);
        match(SQLiteParser::COMMA);
        setState(1095);
        column_name();
        setState(1100);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1101);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(1117);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::SELECT_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::WITH_: {
        setState(1107);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
        case 1: {
          setState(1105);
          values_clause();
          break;
        }

        case 2: {
          setState(1106);
          select_stmt();
          break;
        }

        default:
          break;
        }
        setState(1112);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::ON_) {
          setState(1109);
          upsert_clause();
          setState(1114);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SQLiteParser::DEFAULT_: {
        setState(1115);
        match(SQLiteParser::DEFAULT_);
        setState(1116);
        match(SQLiteParser::VALUES_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1120);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(1119);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Returning_clauseContext ------------------------------------------------------------------

SQLiteParser::Returning_clauseContext::Returning_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Returning_clauseContext::RETURNING_() {
  return getToken(SQLiteParser::RETURNING_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Returning_clauseContext::STAR() {
  return getTokens(SQLiteParser::STAR);
}

tree::TerminalNode* SQLiteParser::Returning_clauseContext::STAR(size_t i) {
  return getToken(SQLiteParser::STAR, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Returning_clauseContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Returning_clauseContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Returning_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Returning_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<SQLiteParser::Column_aliasContext *> SQLiteParser::Returning_clauseContext::column_alias() {
  return getRuleContexts<SQLiteParser::Column_aliasContext>();
}

SQLiteParser::Column_aliasContext* SQLiteParser::Returning_clauseContext::column_alias(size_t i) {
  return getRuleContext<SQLiteParser::Column_aliasContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Returning_clauseContext::AS_() {
  return getTokens(SQLiteParser::AS_);
}

tree::TerminalNode* SQLiteParser::Returning_clauseContext::AS_(size_t i) {
  return getToken(SQLiteParser::AS_, i);
}


size_t SQLiteParser::Returning_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleReturning_clause;
}

void SQLiteParser::Returning_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturning_clause(this);
}

void SQLiteParser::Returning_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturning_clause(this);
}


std::any SQLiteParser::Returning_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitReturning_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::returning_clause() {
  Returning_clauseContext *_localctx = _tracker.createInstance<Returning_clauseContext>(_ctx, getState());
  enterRule(_localctx, 76, SQLiteParser::RuleReturning_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1122);
    match(SQLiteParser::RETURNING_);
    setState(1131);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::STAR: {
        setState(1123);
        match(SQLiteParser::STAR);
        break;
      }

      case SQLiteParser::OPEN_PAR:
      case SQLiteParser::PLUS:
      case SQLiteParser::MINUS:
      case SQLiteParser::TILDE:
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::MATERIALIZED_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::ROWID_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::STRICT_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::RANK_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::TIES_:
      case SQLiteParser::OTHERS_:
      case SQLiteParser::DO_:
      case SQLiteParser::NOTHING_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::NUMERIC_LITERAL:
      case SQLiteParser::BIND_PARAMETER:
      case SQLiteParser::STRING_LITERAL:
      case SQLiteParser::BLOB_LITERAL: {
        setState(1124);
        expr(0);
        setState(1129);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
        case 1: {
          setState(1126);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx)) {
          case 1: {
            setState(1125);
            match(SQLiteParser::AS_);
            break;
          }

          default:
            break;
          }
          setState(1128);
          column_alias();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1146);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1133);
      match(SQLiteParser::COMMA);
      setState(1142);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::STAR: {
          setState(1134);
          match(SQLiteParser::STAR);
          break;
        }

        case SQLiteParser::OPEN_PAR:
        case SQLiteParser::PLUS:
        case SQLiteParser::MINUS:
        case SQLiteParser::TILDE:
        case SQLiteParser::ABORT_:
        case SQLiteParser::ACTION_:
        case SQLiteParser::ADD_:
        case SQLiteParser::AFTER_:
        case SQLiteParser::ALL_:
        case SQLiteParser::ALTER_:
        case SQLiteParser::ANALYZE_:
        case SQLiteParser::AND_:
        case SQLiteParser::AS_:
        case SQLiteParser::ASC_:
        case SQLiteParser::ATTACH_:
        case SQLiteParser::AUTOINCREMENT_:
        case SQLiteParser::BEFORE_:
        case SQLiteParser::BEGIN_:
        case SQLiteParser::BETWEEN_:
        case SQLiteParser::BY_:
        case SQLiteParser::CASCADE_:
        case SQLiteParser::CASE_:
        case SQLiteParser::CAST_:
        case SQLiteParser::CHECK_:
        case SQLiteParser::COLLATE_:
        case SQLiteParser::COLUMN_:
        case SQLiteParser::COMMIT_:
        case SQLiteParser::CONFLICT_:
        case SQLiteParser::CONSTRAINT_:
        case SQLiteParser::CREATE_:
        case SQLiteParser::CROSS_:
        case SQLiteParser::CURRENT_DATE_:
        case SQLiteParser::CURRENT_TIME_:
        case SQLiteParser::CURRENT_TIMESTAMP_:
        case SQLiteParser::DATABASE_:
        case SQLiteParser::DEFAULT_:
        case SQLiteParser::DEFERRABLE_:
        case SQLiteParser::DEFERRED_:
        case SQLiteParser::DELETE_:
        case SQLiteParser::DESC_:
        case SQLiteParser::DETACH_:
        case SQLiteParser::DISTINCT_:
        case SQLiteParser::DROP_:
        case SQLiteParser::EACH_:
        case SQLiteParser::ELSE_:
        case SQLiteParser::END_:
        case SQLiteParser::ESCAPE_:
        case SQLiteParser::EXCEPT_:
        case SQLiteParser::EXCLUSIVE_:
        case SQLiteParser::EXISTS_:
        case SQLiteParser::EXPLAIN_:
        case SQLiteParser::FAIL_:
        case SQLiteParser::FOR_:
        case SQLiteParser::FOREIGN_:
        case SQLiteParser::FROM_:
        case SQLiteParser::FULL_:
        case SQLiteParser::GLOB_:
        case SQLiteParser::GROUP_:
        case SQLiteParser::HAVING_:
        case SQLiteParser::IF_:
        case SQLiteParser::IGNORE_:
        case SQLiteParser::IMMEDIATE_:
        case SQLiteParser::IN_:
        case SQLiteParser::INDEX_:
        case SQLiteParser::INDEXED_:
        case SQLiteParser::INITIALLY_:
        case SQLiteParser::INNER_:
        case SQLiteParser::INSERT_:
        case SQLiteParser::INSTEAD_:
        case SQLiteParser::INTERSECT_:
        case SQLiteParser::INTO_:
        case SQLiteParser::IS_:
        case SQLiteParser::ISNULL_:
        case SQLiteParser::JOIN_:
        case SQLiteParser::KEY_:
        case SQLiteParser::LEFT_:
        case SQLiteParser::LIKE_:
        case SQLiteParser::LIMIT_:
        case SQLiteParser::MATCH_:
        case SQLiteParser::MATERIALIZED_:
        case SQLiteParser::NATURAL_:
        case SQLiteParser::NO_:
        case SQLiteParser::NOT_:
        case SQLiteParser::NOTNULL_:
        case SQLiteParser::NULL_:
        case SQLiteParser::OF_:
        case SQLiteParser::OFFSET_:
        case SQLiteParser::ON_:
        case SQLiteParser::OR_:
        case SQLiteParser::ORDER_:
        case SQLiteParser::OUTER_:
        case SQLiteParser::PLAN_:
        case SQLiteParser::PRAGMA_:
        case SQLiteParser::PRIMARY_:
        case SQLiteParser::QUERY_:
        case SQLiteParser::RAISE_:
        case SQLiteParser::RECURSIVE_:
        case SQLiteParser::REFERENCES_:
        case SQLiteParser::REGEXP_:
        case SQLiteParser::REINDEX_:
        case SQLiteParser::RELEASE_:
        case SQLiteParser::RENAME_:
        case SQLiteParser::REPLACE_:
        case SQLiteParser::RESTRICT_:
        case SQLiteParser::RETURNING_:
        case SQLiteParser::RIGHT_:
        case SQLiteParser::ROLLBACK_:
        case SQLiteParser::ROW_:
        case SQLiteParser::ROWS_:
        case SQLiteParser::ROWID_:
        case SQLiteParser::SAVEPOINT_:
        case SQLiteParser::SELECT_:
        case SQLiteParser::SET_:
        case SQLiteParser::STRICT_:
        case SQLiteParser::TABLE_:
        case SQLiteParser::TEMP_:
        case SQLiteParser::TEMPORARY_:
        case SQLiteParser::THEN_:
        case SQLiteParser::TO_:
        case SQLiteParser::TRANSACTION_:
        case SQLiteParser::TRIGGER_:
        case SQLiteParser::UNION_:
        case SQLiteParser::UNIQUE_:
        case SQLiteParser::UPDATE_:
        case SQLiteParser::USING_:
        case SQLiteParser::VACUUM_:
        case SQLiteParser::VALUES_:
        case SQLiteParser::VIEW_:
        case SQLiteParser::VIRTUAL_:
        case SQLiteParser::WHEN_:
        case SQLiteParser::WHERE_:
        case SQLiteParser::WITH_:
        case SQLiteParser::WITHOUT_:
        case SQLiteParser::OVER_:
        case SQLiteParser::PARTITION_:
        case SQLiteParser::RANGE_:
        case SQLiteParser::PRECEDING_:
        case SQLiteParser::UNBOUNDED_:
        case SQLiteParser::CURRENT_:
        case SQLiteParser::FOLLOWING_:
        case SQLiteParser::RANK_:
        case SQLiteParser::GENERATED_:
        case SQLiteParser::ALWAYS_:
        case SQLiteParser::STORED_:
        case SQLiteParser::TRUE_:
        case SQLiteParser::FALSE_:
        case SQLiteParser::WINDOW_:
        case SQLiteParser::NULLS_:
        case SQLiteParser::FIRST_:
        case SQLiteParser::LAST_:
        case SQLiteParser::FILTER_:
        case SQLiteParser::GROUPS_:
        case SQLiteParser::EXCLUDE_:
        case SQLiteParser::TIES_:
        case SQLiteParser::OTHERS_:
        case SQLiteParser::DO_:
        case SQLiteParser::NOTHING_:
        case SQLiteParser::IDENTIFIER:
        case SQLiteParser::NUMERIC_LITERAL:
        case SQLiteParser::BIND_PARAMETER:
        case SQLiteParser::STRING_LITERAL:
        case SQLiteParser::BLOB_LITERAL: {
          setState(1135);
          expr(0);
          setState(1140);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx)) {
          case 1: {
            setState(1137);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
            case 1: {
              setState(1136);
              match(SQLiteParser::AS_);
              break;
            }

            default:
              break;
            }
            setState(1139);
            column_alias();
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1148);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Upsert_clauseContext ------------------------------------------------------------------

SQLiteParser::Upsert_clauseContext::Upsert_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::CONFLICT_() {
  return getToken(SQLiteParser::CONFLICT_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::DO_() {
  return getToken(SQLiteParser::DO_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::NOTHING_() {
  return getToken(SQLiteParser::NOTHING_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Indexed_columnContext *> SQLiteParser::Upsert_clauseContext::indexed_column() {
  return getRuleContexts<SQLiteParser::Indexed_columnContext>();
}

SQLiteParser::Indexed_columnContext* SQLiteParser::Upsert_clauseContext::indexed_column(size_t i) {
  return getRuleContext<SQLiteParser::Indexed_columnContext>(i);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Upsert_clauseContext::ASSIGN() {
  return getTokens(SQLiteParser::ASSIGN);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::ASSIGN(size_t i) {
  return getToken(SQLiteParser::ASSIGN, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Upsert_clauseContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Upsert_clauseContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Upsert_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Upsert_clauseContext::WHERE_() {
  return getTokens(SQLiteParser::WHERE_);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::WHERE_(size_t i) {
  return getToken(SQLiteParser::WHERE_, i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Upsert_clauseContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Upsert_clauseContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Column_name_listContext *> SQLiteParser::Upsert_clauseContext::column_name_list() {
  return getRuleContexts<SQLiteParser::Column_name_listContext>();
}

SQLiteParser::Column_name_listContext* SQLiteParser::Upsert_clauseContext::column_name_list(size_t i) {
  return getRuleContext<SQLiteParser::Column_name_listContext>(i);
}


size_t SQLiteParser::Upsert_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleUpsert_clause;
}

void SQLiteParser::Upsert_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpsert_clause(this);
}

void SQLiteParser::Upsert_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpsert_clause(this);
}


std::any SQLiteParser::Upsert_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUpsert_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Upsert_clauseContext* SQLiteParser::upsert_clause() {
  Upsert_clauseContext *_localctx = _tracker.createInstance<Upsert_clauseContext>(_ctx, getState());
  enterRule(_localctx, 78, SQLiteParser::RuleUpsert_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1149);
    match(SQLiteParser::ON_);
    setState(1150);
    match(SQLiteParser::CONFLICT_);
    setState(1165);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(1151);
      match(SQLiteParser::OPEN_PAR);
      setState(1152);
      indexed_column();
      setState(1157);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1153);
        match(SQLiteParser::COMMA);
        setState(1154);
        indexed_column();
        setState(1159);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1160);
      match(SQLiteParser::CLOSE_PAR);
      setState(1163);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::WHERE_) {
        setState(1161);
        match(SQLiteParser::WHERE_);
        setState(1162);
        expr(0);
      }
    }
    setState(1167);
    match(SQLiteParser::DO_);
    setState(1194);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::NOTHING_: {
        setState(1168);
        match(SQLiteParser::NOTHING_);
        break;
      }

      case SQLiteParser::UPDATE_: {
        setState(1169);
        match(SQLiteParser::UPDATE_);
        setState(1170);
        match(SQLiteParser::SET_);

        setState(1173);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SQLiteParser::ABORT_:
          case SQLiteParser::ACTION_:
          case SQLiteParser::ADD_:
          case SQLiteParser::AFTER_:
          case SQLiteParser::ALL_:
          case SQLiteParser::ALTER_:
          case SQLiteParser::ANALYZE_:
          case SQLiteParser::AND_:
          case SQLiteParser::AS_:
          case SQLiteParser::ASC_:
          case SQLiteParser::ATTACH_:
          case SQLiteParser::AUTOINCREMENT_:
          case SQLiteParser::BEFORE_:
          case SQLiteParser::BEGIN_:
          case SQLiteParser::BETWEEN_:
          case SQLiteParser::BY_:
          case SQLiteParser::CASCADE_:
          case SQLiteParser::CASE_:
          case SQLiteParser::CAST_:
          case SQLiteParser::CHECK_:
          case SQLiteParser::COLLATE_:
          case SQLiteParser::COLUMN_:
          case SQLiteParser::COMMIT_:
          case SQLiteParser::CONFLICT_:
          case SQLiteParser::CONSTRAINT_:
          case SQLiteParser::CREATE_:
          case SQLiteParser::CROSS_:
          case SQLiteParser::CURRENT_DATE_:
          case SQLiteParser::CURRENT_TIME_:
          case SQLiteParser::CURRENT_TIMESTAMP_:
          case SQLiteParser::DATABASE_:
          case SQLiteParser::DEFAULT_:
          case SQLiteParser::DEFERRABLE_:
          case SQLiteParser::DEFERRED_:
          case SQLiteParser::DELETE_:
          case SQLiteParser::DESC_:
          case SQLiteParser::DETACH_:
          case SQLiteParser::DISTINCT_:
          case SQLiteParser::DROP_:
          case SQLiteParser::EACH_:
          case SQLiteParser::ELSE_:
          case SQLiteParser::END_:
          case SQLiteParser::ESCAPE_:
          case SQLiteParser::EXCEPT_:
          case SQLiteParser::EXCLUSIVE_:
          case SQLiteParser::EXISTS_:
          case SQLiteParser::EXPLAIN_:
          case SQLiteParser::FAIL_:
          case SQLiteParser::FOR_:
          case SQLiteParser::FOREIGN_:
          case SQLiteParser::FROM_:
          case SQLiteParser::FULL_:
          case SQLiteParser::GLOB_:
          case SQLiteParser::GROUP_:
          case SQLiteParser::HAVING_:
          case SQLiteParser::IF_:
          case SQLiteParser::IGNORE_:
          case SQLiteParser::IMMEDIATE_:
          case SQLiteParser::IN_:
          case SQLiteParser::INDEX_:
          case SQLiteParser::INDEXED_:
          case SQLiteParser::INITIALLY_:
          case SQLiteParser::INNER_:
          case SQLiteParser::INSERT_:
          case SQLiteParser::INSTEAD_:
          case SQLiteParser::INTERSECT_:
          case SQLiteParser::INTO_:
          case SQLiteParser::IS_:
          case SQLiteParser::ISNULL_:
          case SQLiteParser::JOIN_:
          case SQLiteParser::KEY_:
          case SQLiteParser::LEFT_:
          case SQLiteParser::LIKE_:
          case SQLiteParser::LIMIT_:
          case SQLiteParser::MATCH_:
          case SQLiteParser::MATERIALIZED_:
          case SQLiteParser::NATURAL_:
          case SQLiteParser::NO_:
          case SQLiteParser::NOT_:
          case SQLiteParser::NOTNULL_:
          case SQLiteParser::NULL_:
          case SQLiteParser::OF_:
          case SQLiteParser::OFFSET_:
          case SQLiteParser::ON_:
          case SQLiteParser::OR_:
          case SQLiteParser::ORDER_:
          case SQLiteParser::OUTER_:
          case SQLiteParser::PLAN_:
          case SQLiteParser::PRAGMA_:
          case SQLiteParser::PRIMARY_:
          case SQLiteParser::QUERY_:
          case SQLiteParser::RAISE_:
          case SQLiteParser::RECURSIVE_:
          case SQLiteParser::REFERENCES_:
          case SQLiteParser::REGEXP_:
          case SQLiteParser::REINDEX_:
          case SQLiteParser::RELEASE_:
          case SQLiteParser::RENAME_:
          case SQLiteParser::REPLACE_:
          case SQLiteParser::RESTRICT_:
          case SQLiteParser::RETURNING_:
          case SQLiteParser::RIGHT_:
          case SQLiteParser::ROLLBACK_:
          case SQLiteParser::ROW_:
          case SQLiteParser::ROWS_:
          case SQLiteParser::ROWID_:
          case SQLiteParser::SAVEPOINT_:
          case SQLiteParser::SELECT_:
          case SQLiteParser::SET_:
          case SQLiteParser::STRICT_:
          case SQLiteParser::TABLE_:
          case SQLiteParser::TEMP_:
          case SQLiteParser::TEMPORARY_:
          case SQLiteParser::THEN_:
          case SQLiteParser::TO_:
          case SQLiteParser::TRANSACTION_:
          case SQLiteParser::TRIGGER_:
          case SQLiteParser::UNION_:
          case SQLiteParser::UNIQUE_:
          case SQLiteParser::UPDATE_:
          case SQLiteParser::USING_:
          case SQLiteParser::VACUUM_:
          case SQLiteParser::VALUES_:
          case SQLiteParser::VIEW_:
          case SQLiteParser::VIRTUAL_:
          case SQLiteParser::WHEN_:
          case SQLiteParser::WHERE_:
          case SQLiteParser::WITH_:
          case SQLiteParser::WITHOUT_:
          case SQLiteParser::OVER_:
          case SQLiteParser::PARTITION_:
          case SQLiteParser::RANGE_:
          case SQLiteParser::PRECEDING_:
          case SQLiteParser::UNBOUNDED_:
          case SQLiteParser::CURRENT_:
          case SQLiteParser::FOLLOWING_:
          case SQLiteParser::RANK_:
          case SQLiteParser::GENERATED_:
          case SQLiteParser::ALWAYS_:
          case SQLiteParser::STORED_:
          case SQLiteParser::TRUE_:
          case SQLiteParser::FALSE_:
          case SQLiteParser::WINDOW_:
          case SQLiteParser::NULLS_:
          case SQLiteParser::FIRST_:
          case SQLiteParser::LAST_:
          case SQLiteParser::FILTER_:
          case SQLiteParser::GROUPS_:
          case SQLiteParser::EXCLUDE_:
          case SQLiteParser::TIES_:
          case SQLiteParser::OTHERS_:
          case SQLiteParser::DO_:
          case SQLiteParser::NOTHING_:
          case SQLiteParser::IDENTIFIER:
          case SQLiteParser::STRING_LITERAL: {
            setState(1171);
            column_name();
            break;
          }

          case SQLiteParser::OPEN_PAR: {
            setState(1172);
            column_name_list();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1175);
        match(SQLiteParser::ASSIGN);
        setState(1176);
        expr(0);
        setState(1187);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1177);
          match(SQLiteParser::COMMA);
          setState(1180);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case SQLiteParser::ABORT_:
            case SQLiteParser::ACTION_:
            case SQLiteParser::ADD_:
            case SQLiteParser::AFTER_:
            case SQLiteParser::ALL_:
            case SQLiteParser::ALTER_:
            case SQLiteParser::ANALYZE_:
            case SQLiteParser::AND_:
            case SQLiteParser::AS_:
            case SQLiteParser::ASC_:
            case SQLiteParser::ATTACH_:
            case SQLiteParser::AUTOINCREMENT_:
            case SQLiteParser::BEFORE_:
            case SQLiteParser::BEGIN_:
            case SQLiteParser::BETWEEN_:
            case SQLiteParser::BY_:
            case SQLiteParser::CASCADE_:
            case SQLiteParser::CASE_:
            case SQLiteParser::CAST_:
            case SQLiteParser::CHECK_:
            case SQLiteParser::COLLATE_:
            case SQLiteParser::COLUMN_:
            case SQLiteParser::COMMIT_:
            case SQLiteParser::CONFLICT_:
            case SQLiteParser::CONSTRAINT_:
            case SQLiteParser::CREATE_:
            case SQLiteParser::CROSS_:
            case SQLiteParser::CURRENT_DATE_:
            case SQLiteParser::CURRENT_TIME_:
            case SQLiteParser::CURRENT_TIMESTAMP_:
            case SQLiteParser::DATABASE_:
            case SQLiteParser::DEFAULT_:
            case SQLiteParser::DEFERRABLE_:
            case SQLiteParser::DEFERRED_:
            case SQLiteParser::DELETE_:
            case SQLiteParser::DESC_:
            case SQLiteParser::DETACH_:
            case SQLiteParser::DISTINCT_:
            case SQLiteParser::DROP_:
            case SQLiteParser::EACH_:
            case SQLiteParser::ELSE_:
            case SQLiteParser::END_:
            case SQLiteParser::ESCAPE_:
            case SQLiteParser::EXCEPT_:
            case SQLiteParser::EXCLUSIVE_:
            case SQLiteParser::EXISTS_:
            case SQLiteParser::EXPLAIN_:
            case SQLiteParser::FAIL_:
            case SQLiteParser::FOR_:
            case SQLiteParser::FOREIGN_:
            case SQLiteParser::FROM_:
            case SQLiteParser::FULL_:
            case SQLiteParser::GLOB_:
            case SQLiteParser::GROUP_:
            case SQLiteParser::HAVING_:
            case SQLiteParser::IF_:
            case SQLiteParser::IGNORE_:
            case SQLiteParser::IMMEDIATE_:
            case SQLiteParser::IN_:
            case SQLiteParser::INDEX_:
            case SQLiteParser::INDEXED_:
            case SQLiteParser::INITIALLY_:
            case SQLiteParser::INNER_:
            case SQLiteParser::INSERT_:
            case SQLiteParser::INSTEAD_:
            case SQLiteParser::INTERSECT_:
            case SQLiteParser::INTO_:
            case SQLiteParser::IS_:
            case SQLiteParser::ISNULL_:
            case SQLiteParser::JOIN_:
            case SQLiteParser::KEY_:
            case SQLiteParser::LEFT_:
            case SQLiteParser::LIKE_:
            case SQLiteParser::LIMIT_:
            case SQLiteParser::MATCH_:
            case SQLiteParser::MATERIALIZED_:
            case SQLiteParser::NATURAL_:
            case SQLiteParser::NO_:
            case SQLiteParser::NOT_:
            case SQLiteParser::NOTNULL_:
            case SQLiteParser::NULL_:
            case SQLiteParser::OF_:
            case SQLiteParser::OFFSET_:
            case SQLiteParser::ON_:
            case SQLiteParser::OR_:
            case SQLiteParser::ORDER_:
            case SQLiteParser::OUTER_:
            case SQLiteParser::PLAN_:
            case SQLiteParser::PRAGMA_:
            case SQLiteParser::PRIMARY_:
            case SQLiteParser::QUERY_:
            case SQLiteParser::RAISE_:
            case SQLiteParser::RECURSIVE_:
            case SQLiteParser::REFERENCES_:
            case SQLiteParser::REGEXP_:
            case SQLiteParser::REINDEX_:
            case SQLiteParser::RELEASE_:
            case SQLiteParser::RENAME_:
            case SQLiteParser::REPLACE_:
            case SQLiteParser::RESTRICT_:
            case SQLiteParser::RETURNING_:
            case SQLiteParser::RIGHT_:
            case SQLiteParser::ROLLBACK_:
            case SQLiteParser::ROW_:
            case SQLiteParser::ROWS_:
            case SQLiteParser::ROWID_:
            case SQLiteParser::SAVEPOINT_:
            case SQLiteParser::SELECT_:
            case SQLiteParser::SET_:
            case SQLiteParser::STRICT_:
            case SQLiteParser::TABLE_:
            case SQLiteParser::TEMP_:
            case SQLiteParser::TEMPORARY_:
            case SQLiteParser::THEN_:
            case SQLiteParser::TO_:
            case SQLiteParser::TRANSACTION_:
            case SQLiteParser::TRIGGER_:
            case SQLiteParser::UNION_:
            case SQLiteParser::UNIQUE_:
            case SQLiteParser::UPDATE_:
            case SQLiteParser::USING_:
            case SQLiteParser::VACUUM_:
            case SQLiteParser::VALUES_:
            case SQLiteParser::VIEW_:
            case SQLiteParser::VIRTUAL_:
            case SQLiteParser::WHEN_:
            case SQLiteParser::WHERE_:
            case SQLiteParser::WITH_:
            case SQLiteParser::WITHOUT_:
            case SQLiteParser::OVER_:
            case SQLiteParser::PARTITION_:
            case SQLiteParser::RANGE_:
            case SQLiteParser::PRECEDING_:
            case SQLiteParser::UNBOUNDED_:
            case SQLiteParser::CURRENT_:
            case SQLiteParser::FOLLOWING_:
            case SQLiteParser::RANK_:
            case SQLiteParser::GENERATED_:
            case SQLiteParser::ALWAYS_:
            case SQLiteParser::STORED_:
            case SQLiteParser::TRUE_:
            case SQLiteParser::FALSE_:
            case SQLiteParser::WINDOW_:
            case SQLiteParser::NULLS_:
            case SQLiteParser::FIRST_:
            case SQLiteParser::LAST_:
            case SQLiteParser::FILTER_:
            case SQLiteParser::GROUPS_:
            case SQLiteParser::EXCLUDE_:
            case SQLiteParser::TIES_:
            case SQLiteParser::OTHERS_:
            case SQLiteParser::DO_:
            case SQLiteParser::NOTHING_:
            case SQLiteParser::IDENTIFIER:
            case SQLiteParser::STRING_LITERAL: {
              setState(1178);
              column_name();
              break;
            }

            case SQLiteParser::OPEN_PAR: {
              setState(1179);
              column_name_list();
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(1182);
          match(SQLiteParser::ASSIGN);
          setState(1183);
          expr(0);
          setState(1189);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1192);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WHERE_) {
          setState(1190);
          match(SQLiteParser::WHERE_);
          setState(1191);
          expr(0);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_stmtContext ------------------------------------------------------------------

SQLiteParser::Pragma_stmtContext::Pragma_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::PRAGMA_() {
  return getToken(SQLiteParser::PRAGMA_, 0);
}

SQLiteParser::Pragma_nameContext* SQLiteParser::Pragma_stmtContext::pragma_name() {
  return getRuleContext<SQLiteParser::Pragma_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Pragma_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::ASSIGN() {
  return getToken(SQLiteParser::ASSIGN, 0);
}

SQLiteParser::Pragma_valueContext* SQLiteParser::Pragma_stmtContext::pragma_value() {
  return getRuleContext<SQLiteParser::Pragma_valueContext>(0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}


size_t SQLiteParser::Pragma_stmtContext::getRuleIndex() const {
  return SQLiteParser::RulePragma_stmt;
}

void SQLiteParser::Pragma_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_stmt(this);
}

void SQLiteParser::Pragma_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_stmt(this);
}


std::any SQLiteParser::Pragma_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPragma_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Pragma_stmtContext* SQLiteParser::pragma_stmt() {
  Pragma_stmtContext *_localctx = _tracker.createInstance<Pragma_stmtContext>(_ctx, getState());
  enterRule(_localctx, 80, SQLiteParser::RulePragma_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1196);
    match(SQLiteParser::PRAGMA_);
    setState(1200);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
    case 1: {
      setState(1197);
      schema_name();
      setState(1198);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1202);
    pragma_name();
    setState(1209);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::ASSIGN: {
        setState(1203);
        match(SQLiteParser::ASSIGN);
        setState(1204);
        pragma_value();
        break;
      }

      case SQLiteParser::OPEN_PAR: {
        setState(1205);
        match(SQLiteParser::OPEN_PAR);
        setState(1206);
        pragma_value();
        setState(1207);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::EOF:
      case SQLiteParser::SCOL: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_valueContext ------------------------------------------------------------------

SQLiteParser::Pragma_valueContext::Pragma_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Signed_numberContext* SQLiteParser::Pragma_valueContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}

SQLiteParser::NameContext* SQLiteParser::Pragma_valueContext::name() {
  return getRuleContext<SQLiteParser::NameContext>(0);
}

tree::TerminalNode* SQLiteParser::Pragma_valueContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}


size_t SQLiteParser::Pragma_valueContext::getRuleIndex() const {
  return SQLiteParser::RulePragma_value;
}

void SQLiteParser::Pragma_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_value(this);
}

void SQLiteParser::Pragma_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_value(this);
}


std::any SQLiteParser::Pragma_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPragma_value(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Pragma_valueContext* SQLiteParser::pragma_value() {
  Pragma_valueContext *_localctx = _tracker.createInstance<Pragma_valueContext>(_ctx, getState());
  enterRule(_localctx, 82, SQLiteParser::RulePragma_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1214);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1211);
      signed_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1212);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1213);
      match(SQLiteParser::STRING_LITERAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reindex_stmtContext ------------------------------------------------------------------

SQLiteParser::Reindex_stmtContext::Reindex_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Reindex_stmtContext::REINDEX_() {
  return getToken(SQLiteParser::REINDEX_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Reindex_stmtContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Reindex_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Reindex_stmtContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Reindex_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Reindex_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}


size_t SQLiteParser::Reindex_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleReindex_stmt;
}

void SQLiteParser::Reindex_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReindex_stmt(this);
}

void SQLiteParser::Reindex_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReindex_stmt(this);
}


std::any SQLiteParser::Reindex_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitReindex_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Reindex_stmtContext* SQLiteParser::reindex_stmt() {
  Reindex_stmtContext *_localctx = _tracker.createInstance<Reindex_stmtContext>(_ctx, getState());
  enterRule(_localctx, 84, SQLiteParser::RuleReindex_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1216);
    match(SQLiteParser::REINDEX_);
    setState(1227);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
    case 1: {
      setState(1217);
      collation_name();
      break;
    }

    case 2: {
      setState(1221);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx)) {
      case 1: {
        setState(1218);
        schema_name();
        setState(1219);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(1225);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx)) {
      case 1: {
        setState(1223);
        table_name();
        break;
      }

      case 2: {
        setState(1224);
        index_name();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_stmtContext ------------------------------------------------------------------

SQLiteParser::Select_stmtContext::Select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Select_coreContext *> SQLiteParser::Select_stmtContext::select_core() {
  return getRuleContexts<SQLiteParser::Select_coreContext>();
}

SQLiteParser::Select_coreContext* SQLiteParser::Select_stmtContext::select_core(size_t i) {
  return getRuleContext<SQLiteParser::Select_coreContext>(i);
}

SQLiteParser::With_clauseContext* SQLiteParser::Select_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

std::vector<SQLiteParser::Compound_operatorContext *> SQLiteParser::Select_stmtContext::compound_operator() {
  return getRuleContexts<SQLiteParser::Compound_operatorContext>();
}

SQLiteParser::Compound_operatorContext* SQLiteParser::Select_stmtContext::compound_operator(size_t i) {
  return getRuleContext<SQLiteParser::Compound_operatorContext>(i);
}

SQLiteParser::Order_clauseContext* SQLiteParser::Select_stmtContext::order_clause() {
  return getRuleContext<SQLiteParser::Order_clauseContext>(0);
}

SQLiteParser::Limit_clauseContext* SQLiteParser::Select_stmtContext::limit_clause() {
  return getRuleContext<SQLiteParser::Limit_clauseContext>(0);
}


size_t SQLiteParser::Select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSelect_stmt;
}

void SQLiteParser::Select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_stmt(this);
}

void SQLiteParser::Select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_stmt(this);
}


std::any SQLiteParser::Select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSelect_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Select_stmtContext* SQLiteParser::select_stmt() {
  Select_stmtContext *_localctx = _tracker.createInstance<Select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 86, SQLiteParser::RuleSelect_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1230);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1229);
      with_clause();
    }
    setState(1232);
    select_core();
    setState(1238);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1233);
        compound_operator();
        setState(1234);
        select_core(); 
      }
      setState(1240);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx);
    }
    setState(1242);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1241);
      order_clause();
    }
    setState(1245);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(1244);
      limit_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_clauseContext ------------------------------------------------------------------

SQLiteParser::Join_clauseContext::Join_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Join_clauseContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Join_clauseContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

std::vector<SQLiteParser::Join_operatorContext *> SQLiteParser::Join_clauseContext::join_operator() {
  return getRuleContexts<SQLiteParser::Join_operatorContext>();
}

SQLiteParser::Join_operatorContext* SQLiteParser::Join_clauseContext::join_operator(size_t i) {
  return getRuleContext<SQLiteParser::Join_operatorContext>(i);
}

std::vector<SQLiteParser::Join_constraintContext *> SQLiteParser::Join_clauseContext::join_constraint() {
  return getRuleContexts<SQLiteParser::Join_constraintContext>();
}

SQLiteParser::Join_constraintContext* SQLiteParser::Join_clauseContext::join_constraint(size_t i) {
  return getRuleContext<SQLiteParser::Join_constraintContext>(i);
}


size_t SQLiteParser::Join_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleJoin_clause;
}

void SQLiteParser::Join_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_clause(this);
}

void SQLiteParser::Join_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_clause(this);
}


std::any SQLiteParser::Join_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitJoin_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Join_clauseContext* SQLiteParser::join_clause() {
  Join_clauseContext *_localctx = _tracker.createInstance<Join_clauseContext>(_ctx, getState());
  enterRule(_localctx, 88, SQLiteParser::RuleJoin_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1247);
    table_or_subquery();
    setState(1255);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA

    || _la == SQLiteParser::CROSS_ || ((((_la - 78) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 78)) & 1125899941709825) != 0)) {
      setState(1248);
      join_operator();
      setState(1249);
      table_or_subquery();
      setState(1251);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
      case 1: {
        setState(1250);
        join_constraint();
        break;
      }

      default:
        break;
      }
      setState(1257);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_coreContext ------------------------------------------------------------------

SQLiteParser::Select_coreContext::Select_coreContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Select_coreContext::SELECT_() {
  return getToken(SQLiteParser::SELECT_, 0);
}

std::vector<SQLiteParser::Result_columnContext *> SQLiteParser::Select_coreContext::result_column() {
  return getRuleContexts<SQLiteParser::Result_columnContext>();
}

SQLiteParser::Result_columnContext* SQLiteParser::Select_coreContext::result_column(size_t i) {
  return getRuleContext<SQLiteParser::Result_columnContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Select_coreContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::GROUP_() {
  return getToken(SQLiteParser::GROUP_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::WINDOW_() {
  return getToken(SQLiteParser::WINDOW_, 0);
}

std::vector<SQLiteParser::Window_nameContext *> SQLiteParser::Select_coreContext::window_name() {
  return getRuleContexts<SQLiteParser::Window_nameContext>();
}

SQLiteParser::Window_nameContext* SQLiteParser::Select_coreContext::window_name(size_t i) {
  return getRuleContext<SQLiteParser::Window_nameContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Select_coreContext::AS_() {
  return getTokens(SQLiteParser::AS_);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::AS_(size_t i) {
  return getToken(SQLiteParser::AS_, i);
}

std::vector<SQLiteParser::Window_defnContext *> SQLiteParser::Select_coreContext::window_defn() {
  return getRuleContexts<SQLiteParser::Window_defnContext>();
}

SQLiteParser::Window_defnContext* SQLiteParser::Select_coreContext::window_defn(size_t i) {
  return getRuleContext<SQLiteParser::Window_defnContext>(i);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Select_coreContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Select_coreContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Select_coreContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Select_coreContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

SQLiteParser::Join_clauseContext* SQLiteParser::Select_coreContext::join_clause() {
  return getRuleContext<SQLiteParser::Join_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::HAVING_() {
  return getToken(SQLiteParser::HAVING_, 0);
}

SQLiteParser::Values_clauseContext* SQLiteParser::Select_coreContext::values_clause() {
  return getRuleContext<SQLiteParser::Values_clauseContext>(0);
}


size_t SQLiteParser::Select_coreContext::getRuleIndex() const {
  return SQLiteParser::RuleSelect_core;
}

void SQLiteParser::Select_coreContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_core(this);
}

void SQLiteParser::Select_coreContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_core(this);
}


std::any SQLiteParser::Select_coreContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSelect_core(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Select_coreContext* SQLiteParser::select_core() {
  Select_coreContext *_localctx = _tracker.createInstance<Select_coreContext>(_ctx, getState());
  enterRule(_localctx, 90, SQLiteParser::RuleSelect_core);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1321);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::SELECT_: {
        enterOuterAlt(_localctx, 1);
        setState(1258);
        match(SQLiteParser::SELECT_);
        setState(1260);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx)) {
        case 1: {
          setState(1259);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::ALL_

          || _la == SQLiteParser::DISTINCT_)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        setState(1262);
        result_column();
        setState(1267);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1263);
          match(SQLiteParser::COMMA);
          setState(1264);
          result_column();
          setState(1269);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1282);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::FROM_) {
          setState(1270);
          match(SQLiteParser::FROM_);
          setState(1280);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
          case 1: {
            setState(1271);
            table_or_subquery();
            setState(1276);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == SQLiteParser::COMMA) {
              setState(1272);
              match(SQLiteParser::COMMA);
              setState(1273);
              table_or_subquery();
              setState(1278);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
            break;
          }

          case 2: {
            setState(1279);
            join_clause();
            break;
          }

          default:
            break;
          }
        }
        setState(1286);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WHERE_) {
          setState(1284);
          match(SQLiteParser::WHERE_);
          setState(1285);
          antlrcpp::downCast<Select_coreContext *>(_localctx)->where_expr = expr(0);
        }
        setState(1302);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::GROUP_) {
          setState(1288);
          match(SQLiteParser::GROUP_);
          setState(1289);
          match(SQLiteParser::BY_);
          setState(1290);
          antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext = expr(0);
          antlrcpp::downCast<Select_coreContext *>(_localctx)->group_by_expr.push_back(antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext);
          setState(1295);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(1291);
            match(SQLiteParser::COMMA);
            setState(1292);
            antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext = expr(0);
            antlrcpp::downCast<Select_coreContext *>(_localctx)->group_by_expr.push_back(antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext);
            setState(1297);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(1300);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::HAVING_) {
            setState(1298);
            match(SQLiteParser::HAVING_);
            setState(1299);
            antlrcpp::downCast<Select_coreContext *>(_localctx)->having_expr = expr(0);
          }
        }
        setState(1318);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WINDOW_) {
          setState(1304);
          match(SQLiteParser::WINDOW_);
          setState(1305);
          window_name();
          setState(1306);
          match(SQLiteParser::AS_);
          setState(1307);
          window_defn();
          setState(1315);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(1308);
            match(SQLiteParser::COMMA);
            setState(1309);
            window_name();
            setState(1310);
            match(SQLiteParser::AS_);
            setState(1311);
            window_defn();
            setState(1317);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        break;
      }

      case SQLiteParser::VALUES_: {
        enterOuterAlt(_localctx, 2);
        setState(1320);
        values_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_or_subqueryContext ------------------------------------------------------------------

SQLiteParser::Table_or_subqueryContext::Table_or_subqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Table_nameContext* SQLiteParser::Table_or_subqueryContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Table_or_subqueryContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

SQLiteParser::Table_aliasContext* SQLiteParser::Table_or_subqueryContext::table_alias() {
  return getRuleContext<SQLiteParser::Table_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::INDEXED_() {
  return getToken(SQLiteParser::INDEXED_, 0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Table_or_subqueryContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Table_function_nameContext* SQLiteParser::Table_or_subqueryContext::table_function_name() {
  return getRuleContext<SQLiteParser::Table_function_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Table_or_subqueryContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Table_or_subqueryContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Table_or_subqueryContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Table_or_subqueryContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Table_or_subqueryContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

SQLiteParser::Join_clauseContext* SQLiteParser::Table_or_subqueryContext::join_clause() {
  return getRuleContext<SQLiteParser::Join_clauseContext>(0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Table_or_subqueryContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Table_or_subqueryContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_or_subquery;
}

void SQLiteParser::Table_or_subqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_or_subquery(this);
}

void SQLiteParser::Table_or_subqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_or_subquery(this);
}


std::any SQLiteParser::Table_or_subqueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_or_subquery(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::table_or_subquery() {
  Table_or_subqueryContext *_localctx = _tracker.createInstance<Table_or_subqueryContext>(_ctx, getState());
  enterRule(_localctx, 92, SQLiteParser::RuleTable_or_subquery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1387);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1326);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx)) {
      case 1: {
        setState(1323);
        schema_name();
        setState(1324);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(1328);
      table_name();
      setState(1333);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
      case 1: {
        setState(1330);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx)) {
        case 1: {
          setState(1329);
          match(SQLiteParser::AS_);
          break;
        }

        default:
          break;
        }
        setState(1332);
        table_alias();
        break;
      }

      default:
        break;
      }
      setState(1340);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::INDEXED_: {
          setState(1335);
          match(SQLiteParser::INDEXED_);
          setState(1336);
          match(SQLiteParser::BY_);
          setState(1337);
          index_name();
          break;
        }

        case SQLiteParser::NOT_: {
          setState(1338);
          match(SQLiteParser::NOT_);
          setState(1339);
          match(SQLiteParser::INDEXED_);
          break;
        }

        case SQLiteParser::EOF:
        case SQLiteParser::SCOL:
        case SQLiteParser::CLOSE_PAR:
        case SQLiteParser::COMMA:
        case SQLiteParser::CROSS_:
        case SQLiteParser::EXCEPT_:
        case SQLiteParser::FULL_:
        case SQLiteParser::GROUP_:
        case SQLiteParser::INNER_:
        case SQLiteParser::INTERSECT_:
        case SQLiteParser::JOIN_:
        case SQLiteParser::LEFT_:
        case SQLiteParser::LIMIT_:
        case SQLiteParser::NATURAL_:
        case SQLiteParser::ON_:
        case SQLiteParser::ORDER_:
        case SQLiteParser::RETURNING_:
        case SQLiteParser::RIGHT_:
        case SQLiteParser::UNION_:
        case SQLiteParser::USING_:
        case SQLiteParser::WHERE_:
        case SQLiteParser::WINDOW_: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1345);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
      case 1: {
        setState(1342);
        schema_name();
        setState(1343);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(1347);
      table_function_name();
      setState(1348);
      match(SQLiteParser::OPEN_PAR);
      setState(1349);
      expr(0);
      setState(1354);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1350);
        match(SQLiteParser::COMMA);
        setState(1351);
        expr(0);
        setState(1356);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1357);
      match(SQLiteParser::CLOSE_PAR);
      setState(1362);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
      case 1: {
        setState(1359);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
        case 1: {
          setState(1358);
          match(SQLiteParser::AS_);
          break;
        }

        default:
          break;
        }
        setState(1361);
        table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1364);
      match(SQLiteParser::OPEN_PAR);
      setState(1374);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
      case 1: {
        setState(1365);
        table_or_subquery();
        setState(1370);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1366);
          match(SQLiteParser::COMMA);
          setState(1367);
          table_or_subquery();
          setState(1372);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(1373);
        join_clause();
        break;
      }

      default:
        break;
      }
      setState(1376);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1378);
      match(SQLiteParser::OPEN_PAR);
      setState(1379);
      select_stmt();
      setState(1380);
      match(SQLiteParser::CLOSE_PAR);
      setState(1385);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, _ctx)) {
      case 1: {
        setState(1382);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
        case 1: {
          setState(1381);
          match(SQLiteParser::AS_);
          break;
        }

        default:
          break;
        }
        setState(1384);
        table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Result_columnContext ------------------------------------------------------------------

SQLiteParser::Result_columnContext::Result_columnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Result_columnContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Result_columnContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Result_columnContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Result_columnContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Column_aliasContext* SQLiteParser::Result_columnContext::column_alias() {
  return getRuleContext<SQLiteParser::Column_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Result_columnContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}


size_t SQLiteParser::Result_columnContext::getRuleIndex() const {
  return SQLiteParser::RuleResult_column;
}

void SQLiteParser::Result_columnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResult_column(this);
}

void SQLiteParser::Result_columnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResult_column(this);
}


std::any SQLiteParser::Result_columnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitResult_column(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Result_columnContext* SQLiteParser::result_column() {
  Result_columnContext *_localctx = _tracker.createInstance<Result_columnContext>(_ctx, getState());
  enterRule(_localctx, 94, SQLiteParser::RuleResult_column);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1401);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1389);
      match(SQLiteParser::STAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1390);
      table_name();
      setState(1391);
      match(SQLiteParser::DOT);
      setState(1392);
      match(SQLiteParser::STAR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1394);
      expr(0);
      setState(1399);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
      case 1: {
        setState(1396);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
        case 1: {
          setState(1395);
          match(SQLiteParser::AS_);
          break;
        }

        default:
          break;
        }
        setState(1398);
        column_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_operatorContext ------------------------------------------------------------------

SQLiteParser::Join_operatorContext::Join_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::JOIN_() {
  return getToken(SQLiteParser::JOIN_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::NATURAL_() {
  return getToken(SQLiteParser::NATURAL_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::INNER_() {
  return getToken(SQLiteParser::INNER_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::CROSS_() {
  return getToken(SQLiteParser::CROSS_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::LEFT_() {
  return getToken(SQLiteParser::LEFT_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::RIGHT_() {
  return getToken(SQLiteParser::RIGHT_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::FULL_() {
  return getToken(SQLiteParser::FULL_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::OUTER_() {
  return getToken(SQLiteParser::OUTER_, 0);
}


size_t SQLiteParser::Join_operatorContext::getRuleIndex() const {
  return SQLiteParser::RuleJoin_operator;
}

void SQLiteParser::Join_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_operator(this);
}

void SQLiteParser::Join_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_operator(this);
}


std::any SQLiteParser::Join_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitJoin_operator(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Join_operatorContext* SQLiteParser::join_operator() {
  Join_operatorContext *_localctx = _tracker.createInstance<Join_operatorContext>(_ctx, getState());
  enterRule(_localctx, 96, SQLiteParser::RuleJoin_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1416);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::COMMA: {
        enterOuterAlt(_localctx, 1);
        setState(1403);
        match(SQLiteParser::COMMA);
        break;
      }

      case SQLiteParser::CROSS_:
      case SQLiteParser::FULL_:
      case SQLiteParser::INNER_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::RIGHT_: {
        enterOuterAlt(_localctx, 2);
        setState(1405);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::NATURAL_) {
          setState(1404);
          match(SQLiteParser::NATURAL_);
        }
        setState(1413);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SQLiteParser::FULL_:
          case SQLiteParser::LEFT_:
          case SQLiteParser::RIGHT_: {
            setState(1407);
            _la = _input->LA(1);
            if (!(((((_la - 78) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 78)) & 1125899907891201) != 0))) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(1409);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SQLiteParser::OUTER_) {
              setState(1408);
              match(SQLiteParser::OUTER_);
            }
            break;
          }

          case SQLiteParser::INNER_: {
            setState(1411);
            match(SQLiteParser::INNER_);
            break;
          }

          case SQLiteParser::CROSS_: {
            setState(1412);
            match(SQLiteParser::CROSS_);
            break;
          }

          case SQLiteParser::JOIN_: {
            break;
          }

        default:
          break;
        }
        setState(1415);
        match(SQLiteParser::JOIN_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_constraintContext ------------------------------------------------------------------

SQLiteParser::Join_constraintContext::Join_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Join_constraintContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::USING_() {
  return getToken(SQLiteParser::USING_, 0);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Join_constraintContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Join_constraintContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Join_constraintContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Join_constraintContext::getRuleIndex() const {
  return SQLiteParser::RuleJoin_constraint;
}

void SQLiteParser::Join_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_constraint(this);
}

void SQLiteParser::Join_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_constraint(this);
}


std::any SQLiteParser::Join_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitJoin_constraint(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Join_constraintContext* SQLiteParser::join_constraint() {
  Join_constraintContext *_localctx = _tracker.createInstance<Join_constraintContext>(_ctx, getState());
  enterRule(_localctx, 98, SQLiteParser::RuleJoin_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1432);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::ON_: {
        enterOuterAlt(_localctx, 1);
        setState(1418);
        match(SQLiteParser::ON_);
        setState(1419);
        expr(0);
        break;
      }

      case SQLiteParser::USING_: {
        enterOuterAlt(_localctx, 2);
        setState(1420);
        match(SQLiteParser::USING_);
        setState(1421);
        match(SQLiteParser::OPEN_PAR);
        setState(1422);
        column_name();
        setState(1427);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1423);
          match(SQLiteParser::COMMA);
          setState(1424);
          column_name();
          setState(1429);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1430);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_operatorContext ------------------------------------------------------------------

SQLiteParser::Compound_operatorContext::Compound_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::UNION_() {
  return getToken(SQLiteParser::UNION_, 0);
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::INTERSECT_() {
  return getToken(SQLiteParser::INTERSECT_, 0);
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::EXCEPT_() {
  return getToken(SQLiteParser::EXCEPT_, 0);
}


size_t SQLiteParser::Compound_operatorContext::getRuleIndex() const {
  return SQLiteParser::RuleCompound_operator;
}

void SQLiteParser::Compound_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_operator(this);
}

void SQLiteParser::Compound_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_operator(this);
}


std::any SQLiteParser::Compound_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCompound_operator(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Compound_operatorContext* SQLiteParser::compound_operator() {
  Compound_operatorContext *_localctx = _tracker.createInstance<Compound_operatorContext>(_ctx, getState());
  enterRule(_localctx, 100, SQLiteParser::RuleCompound_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1440);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::UNION_: {
        enterOuterAlt(_localctx, 1);
        setState(1434);
        match(SQLiteParser::UNION_);
        setState(1436);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ALL_) {
          setState(1435);
          match(SQLiteParser::ALL_);
        }
        break;
      }

      case SQLiteParser::INTERSECT_: {
        enterOuterAlt(_localctx, 2);
        setState(1438);
        match(SQLiteParser::INTERSECT_);
        break;
      }

      case SQLiteParser::EXCEPT_: {
        enterOuterAlt(_localctx, 3);
        setState(1439);
        match(SQLiteParser::EXCEPT_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_stmtContext ------------------------------------------------------------------

SQLiteParser::Update_stmtContext::Update_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Update_stmtContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmtContext::ASSIGN() {
  return getTokens(SQLiteParser::ASSIGN);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::ASSIGN(size_t i) {
  return getToken(SQLiteParser::ASSIGN, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Update_stmtContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Update_stmtContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Update_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Update_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Column_name_listContext *> SQLiteParser::Update_stmtContext::column_name_list() {
  return getRuleContexts<SQLiteParser::Column_name_listContext>();
}

SQLiteParser::Column_name_listContext* SQLiteParser::Update_stmtContext::column_name_list(size_t i) {
  return getRuleContext<SQLiteParser::Column_name_listContext>(i);
}

SQLiteParser::With_clauseContext* SQLiteParser::Update_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Update_stmtContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Update_stmtContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Update_stmtContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

SQLiteParser::Join_clauseContext* SQLiteParser::Update_stmtContext::join_clause() {
  return getRuleContext<SQLiteParser::Join_clauseContext>(0);
}


size_t SQLiteParser::Update_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleUpdate_stmt;
}

void SQLiteParser::Update_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_stmt(this);
}

void SQLiteParser::Update_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_stmt(this);
}


std::any SQLiteParser::Update_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUpdate_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Update_stmtContext* SQLiteParser::update_stmt() {
  Update_stmtContext *_localctx = _tracker.createInstance<Update_stmtContext>(_ctx, getState());
  enterRule(_localctx, 102, SQLiteParser::RuleUpdate_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1443);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1442);
      with_clause();
    }
    setState(1445);
    match(SQLiteParser::UPDATE_);
    setState(1448);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx)) {
    case 1: {
      setState(1446);
      match(SQLiteParser::OR_);
      setState(1447);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::ABORT_ || ((((_la - 74) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 74)) & 38280596832649729) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1450);
    qualified_table_name();
    setState(1451);
    match(SQLiteParser::SET_);
    setState(1454);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::MATERIALIZED_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::ROWID_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::STRICT_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::RANK_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::TIES_:
      case SQLiteParser::OTHERS_:
      case SQLiteParser::DO_:
      case SQLiteParser::NOTHING_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::STRING_LITERAL: {
        setState(1452);
        column_name();
        break;
      }

      case SQLiteParser::OPEN_PAR: {
        setState(1453);
        column_name_list();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1456);
    match(SQLiteParser::ASSIGN);
    setState(1457);
    expr(0);
    setState(1468);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1458);
      match(SQLiteParser::COMMA);
      setState(1461);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::ABORT_:
        case SQLiteParser::ACTION_:
        case SQLiteParser::ADD_:
        case SQLiteParser::AFTER_:
        case SQLiteParser::ALL_:
        case SQLiteParser::ALTER_:
        case SQLiteParser::ANALYZE_:
        case SQLiteParser::AND_:
        case SQLiteParser::AS_:
        case SQLiteParser::ASC_:
        case SQLiteParser::ATTACH_:
        case SQLiteParser::AUTOINCREMENT_:
        case SQLiteParser::BEFORE_:
        case SQLiteParser::BEGIN_:
        case SQLiteParser::BETWEEN_:
        case SQLiteParser::BY_:
        case SQLiteParser::CASCADE_:
        case SQLiteParser::CASE_:
        case SQLiteParser::CAST_:
        case SQLiteParser::CHECK_:
        case SQLiteParser::COLLATE_:
        case SQLiteParser::COLUMN_:
        case SQLiteParser::COMMIT_:
        case SQLiteParser::CONFLICT_:
        case SQLiteParser::CONSTRAINT_:
        case SQLiteParser::CREATE_:
        case SQLiteParser::CROSS_:
        case SQLiteParser::CURRENT_DATE_:
        case SQLiteParser::CURRENT_TIME_:
        case SQLiteParser::CURRENT_TIMESTAMP_:
        case SQLiteParser::DATABASE_:
        case SQLiteParser::DEFAULT_:
        case SQLiteParser::DEFERRABLE_:
        case SQLiteParser::DEFERRED_:
        case SQLiteParser::DELETE_:
        case SQLiteParser::DESC_:
        case SQLiteParser::DETACH_:
        case SQLiteParser::DISTINCT_:
        case SQLiteParser::DROP_:
        case SQLiteParser::EACH_:
        case SQLiteParser::ELSE_:
        case SQLiteParser::END_:
        case SQLiteParser::ESCAPE_:
        case SQLiteParser::EXCEPT_:
        case SQLiteParser::EXCLUSIVE_:
        case SQLiteParser::EXISTS_:
        case SQLiteParser::EXPLAIN_:
        case SQLiteParser::FAIL_:
        case SQLiteParser::FOR_:
        case SQLiteParser::FOREIGN_:
        case SQLiteParser::FROM_:
        case SQLiteParser::FULL_:
        case SQLiteParser::GLOB_:
        case SQLiteParser::GROUP_:
        case SQLiteParser::HAVING_:
        case SQLiteParser::IF_:
        case SQLiteParser::IGNORE_:
        case SQLiteParser::IMMEDIATE_:
        case SQLiteParser::IN_:
        case SQLiteParser::INDEX_:
        case SQLiteParser::INDEXED_:
        case SQLiteParser::INITIALLY_:
        case SQLiteParser::INNER_:
        case SQLiteParser::INSERT_:
        case SQLiteParser::INSTEAD_:
        case SQLiteParser::INTERSECT_:
        case SQLiteParser::INTO_:
        case SQLiteParser::IS_:
        case SQLiteParser::ISNULL_:
        case SQLiteParser::JOIN_:
        case SQLiteParser::KEY_:
        case SQLiteParser::LEFT_:
        case SQLiteParser::LIKE_:
        case SQLiteParser::LIMIT_:
        case SQLiteParser::MATCH_:
        case SQLiteParser::MATERIALIZED_:
        case SQLiteParser::NATURAL_:
        case SQLiteParser::NO_:
        case SQLiteParser::NOT_:
        case SQLiteParser::NOTNULL_:
        case SQLiteParser::NULL_:
        case SQLiteParser::OF_:
        case SQLiteParser::OFFSET_:
        case SQLiteParser::ON_:
        case SQLiteParser::OR_:
        case SQLiteParser::ORDER_:
        case SQLiteParser::OUTER_:
        case SQLiteParser::PLAN_:
        case SQLiteParser::PRAGMA_:
        case SQLiteParser::PRIMARY_:
        case SQLiteParser::QUERY_:
        case SQLiteParser::RAISE_:
        case SQLiteParser::RECURSIVE_:
        case SQLiteParser::REFERENCES_:
        case SQLiteParser::REGEXP_:
        case SQLiteParser::REINDEX_:
        case SQLiteParser::RELEASE_:
        case SQLiteParser::RENAME_:
        case SQLiteParser::REPLACE_:
        case SQLiteParser::RESTRICT_:
        case SQLiteParser::RETURNING_:
        case SQLiteParser::RIGHT_:
        case SQLiteParser::ROLLBACK_:
        case SQLiteParser::ROW_:
        case SQLiteParser::ROWS_:
        case SQLiteParser::ROWID_:
        case SQLiteParser::SAVEPOINT_:
        case SQLiteParser::SELECT_:
        case SQLiteParser::SET_:
        case SQLiteParser::STRICT_:
        case SQLiteParser::TABLE_:
        case SQLiteParser::TEMP_:
        case SQLiteParser::TEMPORARY_:
        case SQLiteParser::THEN_:
        case SQLiteParser::TO_:
        case SQLiteParser::TRANSACTION_:
        case SQLiteParser::TRIGGER_:
        case SQLiteParser::UNION_:
        case SQLiteParser::UNIQUE_:
        case SQLiteParser::UPDATE_:
        case SQLiteParser::USING_:
        case SQLiteParser::VACUUM_:
        case SQLiteParser::VALUES_:
        case SQLiteParser::VIEW_:
        case SQLiteParser::VIRTUAL_:
        case SQLiteParser::WHEN_:
        case SQLiteParser::WHERE_:
        case SQLiteParser::WITH_:
        case SQLiteParser::WITHOUT_:
        case SQLiteParser::OVER_:
        case SQLiteParser::PARTITION_:
        case SQLiteParser::RANGE_:
        case SQLiteParser::PRECEDING_:
        case SQLiteParser::UNBOUNDED_:
        case SQLiteParser::CURRENT_:
        case SQLiteParser::FOLLOWING_:
        case SQLiteParser::RANK_:
        case SQLiteParser::GENERATED_:
        case SQLiteParser::ALWAYS_:
        case SQLiteParser::STORED_:
        case SQLiteParser::TRUE_:
        case SQLiteParser::FALSE_:
        case SQLiteParser::WINDOW_:
        case SQLiteParser::NULLS_:
        case SQLiteParser::FIRST_:
        case SQLiteParser::LAST_:
        case SQLiteParser::FILTER_:
        case SQLiteParser::GROUPS_:
        case SQLiteParser::EXCLUDE_:
        case SQLiteParser::TIES_:
        case SQLiteParser::OTHERS_:
        case SQLiteParser::DO_:
        case SQLiteParser::NOTHING_:
        case SQLiteParser::IDENTIFIER:
        case SQLiteParser::STRING_LITERAL: {
          setState(1459);
          column_name();
          break;
        }

        case SQLiteParser::OPEN_PAR: {
          setState(1460);
          column_name_list();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1463);
      match(SQLiteParser::ASSIGN);
      setState(1464);
      expr(0);
      setState(1470);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1483);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FROM_) {
      setState(1471);
      match(SQLiteParser::FROM_);
      setState(1481);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
      case 1: {
        setState(1472);
        table_or_subquery();
        setState(1477);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1473);
          match(SQLiteParser::COMMA);
          setState(1474);
          table_or_subquery();
          setState(1479);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(1480);
        join_clause();
        break;
      }

      default:
        break;
      }
    }
    setState(1487);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(1485);
      match(SQLiteParser::WHERE_);
      setState(1486);
      expr(0);
    }
    setState(1490);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(1489);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_name_listContext ------------------------------------------------------------------

SQLiteParser::Column_name_listContext::Column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Column_name_listContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Column_name_listContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Column_name_listContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Column_name_listContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Column_name_listContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Column_name_listContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Column_name_listContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_name_list;
}

void SQLiteParser::Column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name_list(this);
}

void SQLiteParser::Column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name_list(this);
}


std::any SQLiteParser::Column_name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_name_list(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_name_listContext* SQLiteParser::column_name_list() {
  Column_name_listContext *_localctx = _tracker.createInstance<Column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 104, SQLiteParser::RuleColumn_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1492);
    match(SQLiteParser::OPEN_PAR);
    setState(1493);
    column_name();
    setState(1498);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1494);
      match(SQLiteParser::COMMA);
      setState(1495);
      column_name();
      setState(1500);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1501);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_stmt_limitedContext ------------------------------------------------------------------

SQLiteParser::Update_stmt_limitedContext::Update_stmt_limitedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Update_stmt_limitedContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmt_limitedContext::ASSIGN() {
  return getTokens(SQLiteParser::ASSIGN);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::ASSIGN(size_t i) {
  return getToken(SQLiteParser::ASSIGN, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Update_stmt_limitedContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Update_stmt_limitedContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Update_stmt_limitedContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Update_stmt_limitedContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Column_name_listContext *> SQLiteParser::Update_stmt_limitedContext::column_name_list() {
  return getRuleContexts<SQLiteParser::Column_name_listContext>();
}

SQLiteParser::Column_name_listContext* SQLiteParser::Update_stmt_limitedContext::column_name_list(size_t i) {
  return getRuleContext<SQLiteParser::Column_name_listContext>(i);
}

SQLiteParser::With_clauseContext* SQLiteParser::Update_stmt_limitedContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmt_limitedContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Update_stmt_limitedContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

SQLiteParser::Order_clauseContext* SQLiteParser::Update_stmt_limitedContext::order_clause() {
  return getRuleContext<SQLiteParser::Order_clauseContext>(0);
}

SQLiteParser::Limit_clauseContext* SQLiteParser::Update_stmt_limitedContext::limit_clause() {
  return getRuleContext<SQLiteParser::Limit_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Update_stmt_limitedContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Update_stmt_limitedContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

SQLiteParser::Join_clauseContext* SQLiteParser::Update_stmt_limitedContext::join_clause() {
  return getRuleContext<SQLiteParser::Join_clauseContext>(0);
}


size_t SQLiteParser::Update_stmt_limitedContext::getRuleIndex() const {
  return SQLiteParser::RuleUpdate_stmt_limited;
}

void SQLiteParser::Update_stmt_limitedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_stmt_limited(this);
}

void SQLiteParser::Update_stmt_limitedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_stmt_limited(this);
}


std::any SQLiteParser::Update_stmt_limitedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUpdate_stmt_limited(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Update_stmt_limitedContext* SQLiteParser::update_stmt_limited() {
  Update_stmt_limitedContext *_localctx = _tracker.createInstance<Update_stmt_limitedContext>(_ctx, getState());
  enterRule(_localctx, 106, SQLiteParser::RuleUpdate_stmt_limited);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1504);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1503);
      with_clause();
    }
    setState(1506);
    match(SQLiteParser::UPDATE_);
    setState(1509);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx)) {
    case 1: {
      setState(1507);
      match(SQLiteParser::OR_);
      setState(1508);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::ABORT_ || ((((_la - 74) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 74)) & 38280596832649729) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1511);
    qualified_table_name();
    setState(1512);
    match(SQLiteParser::SET_);
    setState(1515);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::MATERIALIZED_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::ROWID_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::STRICT_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::RANK_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::TIES_:
      case SQLiteParser::OTHERS_:
      case SQLiteParser::DO_:
      case SQLiteParser::NOTHING_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::STRING_LITERAL: {
        setState(1513);
        column_name();
        break;
      }

      case SQLiteParser::OPEN_PAR: {
        setState(1514);
        column_name_list();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1517);
    match(SQLiteParser::ASSIGN);
    setState(1518);
    expr(0);
    setState(1529);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1519);
      match(SQLiteParser::COMMA);
      setState(1522);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::ABORT_:
        case SQLiteParser::ACTION_:
        case SQLiteParser::ADD_:
        case SQLiteParser::AFTER_:
        case SQLiteParser::ALL_:
        case SQLiteParser::ALTER_:
        case SQLiteParser::ANALYZE_:
        case SQLiteParser::AND_:
        case SQLiteParser::AS_:
        case SQLiteParser::ASC_:
        case SQLiteParser::ATTACH_:
        case SQLiteParser::AUTOINCREMENT_:
        case SQLiteParser::BEFORE_:
        case SQLiteParser::BEGIN_:
        case SQLiteParser::BETWEEN_:
        case SQLiteParser::BY_:
        case SQLiteParser::CASCADE_:
        case SQLiteParser::CASE_:
        case SQLiteParser::CAST_:
        case SQLiteParser::CHECK_:
        case SQLiteParser::COLLATE_:
        case SQLiteParser::COLUMN_:
        case SQLiteParser::COMMIT_:
        case SQLiteParser::CONFLICT_:
        case SQLiteParser::CONSTRAINT_:
        case SQLiteParser::CREATE_:
        case SQLiteParser::CROSS_:
        case SQLiteParser::CURRENT_DATE_:
        case SQLiteParser::CURRENT_TIME_:
        case SQLiteParser::CURRENT_TIMESTAMP_:
        case SQLiteParser::DATABASE_:
        case SQLiteParser::DEFAULT_:
        case SQLiteParser::DEFERRABLE_:
        case SQLiteParser::DEFERRED_:
        case SQLiteParser::DELETE_:
        case SQLiteParser::DESC_:
        case SQLiteParser::DETACH_:
        case SQLiteParser::DISTINCT_:
        case SQLiteParser::DROP_:
        case SQLiteParser::EACH_:
        case SQLiteParser::ELSE_:
        case SQLiteParser::END_:
        case SQLiteParser::ESCAPE_:
        case SQLiteParser::EXCEPT_:
        case SQLiteParser::EXCLUSIVE_:
        case SQLiteParser::EXISTS_:
        case SQLiteParser::EXPLAIN_:
        case SQLiteParser::FAIL_:
        case SQLiteParser::FOR_:
        case SQLiteParser::FOREIGN_:
        case SQLiteParser::FROM_:
        case SQLiteParser::FULL_:
        case SQLiteParser::GLOB_:
        case SQLiteParser::GROUP_:
        case SQLiteParser::HAVING_:
        case SQLiteParser::IF_:
        case SQLiteParser::IGNORE_:
        case SQLiteParser::IMMEDIATE_:
        case SQLiteParser::IN_:
        case SQLiteParser::INDEX_:
        case SQLiteParser::INDEXED_:
        case SQLiteParser::INITIALLY_:
        case SQLiteParser::INNER_:
        case SQLiteParser::INSERT_:
        case SQLiteParser::INSTEAD_:
        case SQLiteParser::INTERSECT_:
        case SQLiteParser::INTO_:
        case SQLiteParser::IS_:
        case SQLiteParser::ISNULL_:
        case SQLiteParser::JOIN_:
        case SQLiteParser::KEY_:
        case SQLiteParser::LEFT_:
        case SQLiteParser::LIKE_:
        case SQLiteParser::LIMIT_:
        case SQLiteParser::MATCH_:
        case SQLiteParser::MATERIALIZED_:
        case SQLiteParser::NATURAL_:
        case SQLiteParser::NO_:
        case SQLiteParser::NOT_:
        case SQLiteParser::NOTNULL_:
        case SQLiteParser::NULL_:
        case SQLiteParser::OF_:
        case SQLiteParser::OFFSET_:
        case SQLiteParser::ON_:
        case SQLiteParser::OR_:
        case SQLiteParser::ORDER_:
        case SQLiteParser::OUTER_:
        case SQLiteParser::PLAN_:
        case SQLiteParser::PRAGMA_:
        case SQLiteParser::PRIMARY_:
        case SQLiteParser::QUERY_:
        case SQLiteParser::RAISE_:
        case SQLiteParser::RECURSIVE_:
        case SQLiteParser::REFERENCES_:
        case SQLiteParser::REGEXP_:
        case SQLiteParser::REINDEX_:
        case SQLiteParser::RELEASE_:
        case SQLiteParser::RENAME_:
        case SQLiteParser::REPLACE_:
        case SQLiteParser::RESTRICT_:
        case SQLiteParser::RETURNING_:
        case SQLiteParser::RIGHT_:
        case SQLiteParser::ROLLBACK_:
        case SQLiteParser::ROW_:
        case SQLiteParser::ROWS_:
        case SQLiteParser::ROWID_:
        case SQLiteParser::SAVEPOINT_:
        case SQLiteParser::SELECT_:
        case SQLiteParser::SET_:
        case SQLiteParser::STRICT_:
        case SQLiteParser::TABLE_:
        case SQLiteParser::TEMP_:
        case SQLiteParser::TEMPORARY_:
        case SQLiteParser::THEN_:
        case SQLiteParser::TO_:
        case SQLiteParser::TRANSACTION_:
        case SQLiteParser::TRIGGER_:
        case SQLiteParser::UNION_:
        case SQLiteParser::UNIQUE_:
        case SQLiteParser::UPDATE_:
        case SQLiteParser::USING_:
        case SQLiteParser::VACUUM_:
        case SQLiteParser::VALUES_:
        case SQLiteParser::VIEW_:
        case SQLiteParser::VIRTUAL_:
        case SQLiteParser::WHEN_:
        case SQLiteParser::WHERE_:
        case SQLiteParser::WITH_:
        case SQLiteParser::WITHOUT_:
        case SQLiteParser::OVER_:
        case SQLiteParser::PARTITION_:
        case SQLiteParser::RANGE_:
        case SQLiteParser::PRECEDING_:
        case SQLiteParser::UNBOUNDED_:
        case SQLiteParser::CURRENT_:
        case SQLiteParser::FOLLOWING_:
        case SQLiteParser::RANK_:
        case SQLiteParser::GENERATED_:
        case SQLiteParser::ALWAYS_:
        case SQLiteParser::STORED_:
        case SQLiteParser::TRUE_:
        case SQLiteParser::FALSE_:
        case SQLiteParser::WINDOW_:
        case SQLiteParser::NULLS_:
        case SQLiteParser::FIRST_:
        case SQLiteParser::LAST_:
        case SQLiteParser::FILTER_:
        case SQLiteParser::GROUPS_:
        case SQLiteParser::EXCLUDE_:
        case SQLiteParser::TIES_:
        case SQLiteParser::OTHERS_:
        case SQLiteParser::DO_:
        case SQLiteParser::NOTHING_:
        case SQLiteParser::IDENTIFIER:
        case SQLiteParser::STRING_LITERAL: {
          setState(1520);
          column_name();
          break;
        }

        case SQLiteParser::OPEN_PAR: {
          setState(1521);
          column_name_list();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1524);
      match(SQLiteParser::ASSIGN);
      setState(1525);
      expr(0);
      setState(1531);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1544);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FROM_) {
      setState(1532);
      match(SQLiteParser::FROM_);
      setState(1542);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
      case 1: {
        setState(1533);
        table_or_subquery();
        setState(1538);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1534);
          match(SQLiteParser::COMMA);
          setState(1535);
          table_or_subquery();
          setState(1540);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(1541);
        join_clause();
        break;
      }

      default:
        break;
      }
    }
    setState(1548);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(1546);
      match(SQLiteParser::WHERE_);
      setState(1547);
      expr(0);
    }
    setState(1551);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(1550);
      returning_clause();
    }
    setState(1554);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1553);
      order_clause();
    }
    setState(1557);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(1556);
      limit_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qualified_table_nameContext ------------------------------------------------------------------

SQLiteParser::Qualified_table_nameContext::Qualified_table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Table_nameContext* SQLiteParser::Qualified_table_nameContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Qualified_table_nameContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::AliasContext* SQLiteParser::Qualified_table_nameContext::alias() {
  return getRuleContext<SQLiteParser::AliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::INDEXED_() {
  return getToken(SQLiteParser::INDEXED_, 0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Qualified_table_nameContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}


size_t SQLiteParser::Qualified_table_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleQualified_table_name;
}

void SQLiteParser::Qualified_table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualified_table_name(this);
}

void SQLiteParser::Qualified_table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualified_table_name(this);
}


std::any SQLiteParser::Qualified_table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitQualified_table_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::qualified_table_name() {
  Qualified_table_nameContext *_localctx = _tracker.createInstance<Qualified_table_nameContext>(_ctx, getState());
  enterRule(_localctx, 108, SQLiteParser::RuleQualified_table_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1562);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
    case 1: {
      setState(1559);
      schema_name();
      setState(1560);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1564);
    table_name();
    setState(1567);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::AS_) {
      setState(1565);
      match(SQLiteParser::AS_);
      setState(1566);
      alias();
    }
    setState(1574);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::INDEXED_: {
        setState(1569);
        match(SQLiteParser::INDEXED_);
        setState(1570);
        match(SQLiteParser::BY_);
        setState(1571);
        index_name();
        break;
      }

      case SQLiteParser::NOT_: {
        setState(1572);
        match(SQLiteParser::NOT_);
        setState(1573);
        match(SQLiteParser::INDEXED_);
        break;
      }

      case SQLiteParser::EOF:
      case SQLiteParser::SCOL:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::SET_:
      case SQLiteParser::WHERE_: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vacuum_stmtContext ------------------------------------------------------------------

SQLiteParser::Vacuum_stmtContext::Vacuum_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Vacuum_stmtContext::VACUUM_() {
  return getToken(SQLiteParser::VACUUM_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Vacuum_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Vacuum_stmtContext::INTO_() {
  return getToken(SQLiteParser::INTO_, 0);
}

SQLiteParser::FilenameContext* SQLiteParser::Vacuum_stmtContext::filename() {
  return getRuleContext<SQLiteParser::FilenameContext>(0);
}


size_t SQLiteParser::Vacuum_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleVacuum_stmt;
}

void SQLiteParser::Vacuum_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVacuum_stmt(this);
}

void SQLiteParser::Vacuum_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVacuum_stmt(this);
}


std::any SQLiteParser::Vacuum_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitVacuum_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Vacuum_stmtContext* SQLiteParser::vacuum_stmt() {
  Vacuum_stmtContext *_localctx = _tracker.createInstance<Vacuum_stmtContext>(_ctx, getState());
  enterRule(_localctx, 110, SQLiteParser::RuleVacuum_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1576);
    match(SQLiteParser::VACUUM_);
    setState(1578);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
    case 1: {
      setState(1577);
      schema_name();
      break;
    }

    default:
      break;
    }
    setState(1582);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::INTO_) {
      setState(1580);
      match(SQLiteParser::INTO_);
      setState(1581);
      filename();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Filter_clauseContext ------------------------------------------------------------------

SQLiteParser::Filter_clauseContext::Filter_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::FILTER_() {
  return getToken(SQLiteParser::FILTER_, 0);
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Filter_clauseContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}


size_t SQLiteParser::Filter_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleFilter_clause;
}

void SQLiteParser::Filter_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilter_clause(this);
}

void SQLiteParser::Filter_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilter_clause(this);
}


std::any SQLiteParser::Filter_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFilter_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::filter_clause() {
  Filter_clauseContext *_localctx = _tracker.createInstance<Filter_clauseContext>(_ctx, getState());
  enterRule(_localctx, 112, SQLiteParser::RuleFilter_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1584);
    match(SQLiteParser::FILTER_);
    setState(1585);
    match(SQLiteParser::OPEN_PAR);
    setState(1586);
    match(SQLiteParser::WHERE_);
    setState(1587);
    expr(0);
    setState(1588);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_defnContext ------------------------------------------------------------------

SQLiteParser::Window_defnContext::Window_defnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Window_defnContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::Base_window_nameContext* SQLiteParser::Window_defnContext::base_window_name() {
  return getRuleContext<SQLiteParser::Base_window_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Window_defnContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Window_defnContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

SQLiteParser::Order_clauseContext* SQLiteParser::Window_defnContext::order_clause() {
  return getRuleContext<SQLiteParser::Order_clauseContext>(0);
}

SQLiteParser::Frame_specContext* SQLiteParser::Window_defnContext::frame_spec() {
  return getRuleContext<SQLiteParser::Frame_specContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_defnContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Window_defnContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_defn;
}

void SQLiteParser::Window_defnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_defn(this);
}

void SQLiteParser::Window_defnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_defn(this);
}


std::any SQLiteParser::Window_defnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_defn(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_defnContext* SQLiteParser::window_defn() {
  Window_defnContext *_localctx = _tracker.createInstance<Window_defnContext>(_ctx, getState());
  enterRule(_localctx, 114, SQLiteParser::RuleWindow_defn);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1590);
    match(SQLiteParser::OPEN_PAR);
    setState(1592);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
    case 1: {
      setState(1591);
      base_window_name();
      break;
    }

    default:
      break;
    }
    setState(1604);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::PARTITION_) {
      setState(1594);
      match(SQLiteParser::PARTITION_);
      setState(1595);
      match(SQLiteParser::BY_);
      setState(1596);
      expr(0);
      setState(1601);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1597);
        match(SQLiteParser::COMMA);
        setState(1598);
        expr(0);
        setState(1603);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1607);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1606);
      order_clause();
    }
    setState(1610);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & 8796227239937) != 0)) {
      setState(1609);
      frame_spec();
    }
    setState(1612);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Over_clauseContext ------------------------------------------------------------------

SQLiteParser::Over_clauseContext::Over_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

SQLiteParser::Window_nameContext* SQLiteParser::Over_clauseContext::window_name() {
  return getRuleContext<SQLiteParser::Window_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::Base_window_nameContext* SQLiteParser::Over_clauseContext::base_window_name() {
  return getRuleContext<SQLiteParser::Base_window_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Over_clauseContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Over_clauseContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

SQLiteParser::Order_clauseContext* SQLiteParser::Over_clauseContext::order_clause() {
  return getRuleContext<SQLiteParser::Order_clauseContext>(0);
}

SQLiteParser::Frame_specContext* SQLiteParser::Over_clauseContext::frame_spec() {
  return getRuleContext<SQLiteParser::Frame_specContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Over_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Over_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleOver_clause;
}

void SQLiteParser::Over_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOver_clause(this);
}

void SQLiteParser::Over_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOver_clause(this);
}


std::any SQLiteParser::Over_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOver_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Over_clauseContext* SQLiteParser::over_clause() {
  Over_clauseContext *_localctx = _tracker.createInstance<Over_clauseContext>(_ctx, getState());
  enterRule(_localctx, 116, SQLiteParser::RuleOver_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1614);
    match(SQLiteParser::OVER_);
    setState(1639);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::MATERIALIZED_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::ROWID_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::STRICT_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::RANK_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::TIES_:
      case SQLiteParser::OTHERS_:
      case SQLiteParser::DO_:
      case SQLiteParser::NOTHING_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::STRING_LITERAL: {
        setState(1615);
        window_name();
        break;
      }

      case SQLiteParser::OPEN_PAR: {
        setState(1616);
        match(SQLiteParser::OPEN_PAR);
        setState(1618);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
        case 1: {
          setState(1617);
          base_window_name();
          break;
        }

        default:
          break;
        }
        setState(1630);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1620);
          match(SQLiteParser::PARTITION_);
          setState(1621);
          match(SQLiteParser::BY_);
          setState(1622);
          expr(0);
          setState(1627);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(1623);
            match(SQLiteParser::COMMA);
            setState(1624);
            expr(0);
            setState(1629);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(1633);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ORDER_) {
          setState(1632);
          order_clause();
        }
        setState(1636);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 131) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 131)) & 8796227239937) != 0)) {
          setState(1635);
          frame_spec();
        }
        setState(1638);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_specContext ------------------------------------------------------------------

SQLiteParser::Frame_specContext::Frame_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Frame_clauseContext* SQLiteParser::Frame_specContext::frame_clause() {
  return getRuleContext<SQLiteParser::Frame_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::EXCLUDE_() {
  return getToken(SQLiteParser::EXCLUDE_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::NO_() {
  return getToken(SQLiteParser::NO_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::OTHERS_() {
  return getToken(SQLiteParser::OTHERS_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::GROUP_() {
  return getToken(SQLiteParser::GROUP_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::TIES_() {
  return getToken(SQLiteParser::TIES_, 0);
}


size_t SQLiteParser::Frame_specContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_spec;
}

void SQLiteParser::Frame_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_spec(this);
}

void SQLiteParser::Frame_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_spec(this);
}


std::any SQLiteParser::Frame_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_spec(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_specContext* SQLiteParser::frame_spec() {
  Frame_specContext *_localctx = _tracker.createInstance<Frame_specContext>(_ctx, getState());
  enterRule(_localctx, 118, SQLiteParser::RuleFrame_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1641);
    frame_clause();
    setState(1651);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::EXCLUDE_) {
      setState(1642);
      match(SQLiteParser::EXCLUDE_);
      setState(1649);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::NO_: {
          setState(1643);
          match(SQLiteParser::NO_);
          setState(1644);
          match(SQLiteParser::OTHERS_);
          break;
        }

        case SQLiteParser::CURRENT_: {
          setState(1645);
          match(SQLiteParser::CURRENT_);
          setState(1646);
          match(SQLiteParser::ROW_);
          break;
        }

        case SQLiteParser::GROUP_: {
          setState(1647);
          match(SQLiteParser::GROUP_);
          break;
        }

        case SQLiteParser::TIES_: {
          setState(1648);
          match(SQLiteParser::TIES_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_clauseContext ------------------------------------------------------------------

SQLiteParser::Frame_clauseContext::Frame_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::RANGE_() {
  return getToken(SQLiteParser::RANGE_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::ROWS_() {
  return getToken(SQLiteParser::ROWS_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::GROUPS_() {
  return getToken(SQLiteParser::GROUPS_, 0);
}

SQLiteParser::Frame_singleContext* SQLiteParser::Frame_clauseContext::frame_single() {
  return getRuleContext<SQLiteParser::Frame_singleContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::BETWEEN_() {
  return getToken(SQLiteParser::BETWEEN_, 0);
}

SQLiteParser::Frame_leftContext* SQLiteParser::Frame_clauseContext::frame_left() {
  return getRuleContext<SQLiteParser::Frame_leftContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::AND_() {
  return getToken(SQLiteParser::AND_, 0);
}

SQLiteParser::Frame_rightContext* SQLiteParser::Frame_clauseContext::frame_right() {
  return getRuleContext<SQLiteParser::Frame_rightContext>(0);
}


size_t SQLiteParser::Frame_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_clause;
}

void SQLiteParser::Frame_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_clause(this);
}

void SQLiteParser::Frame_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_clause(this);
}


std::any SQLiteParser::Frame_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_clauseContext* SQLiteParser::frame_clause() {
  Frame_clauseContext *_localctx = _tracker.createInstance<Frame_clauseContext>(_ctx, getState());
  enterRule(_localctx, 120, SQLiteParser::RuleFrame_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1653);
    _la = _input->LA(1);
    if (!(((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & 8796227239937) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1660);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx)) {
    case 1: {
      setState(1654);
      frame_single();
      break;
    }

    case 2: {
      setState(1655);
      match(SQLiteParser::BETWEEN_);
      setState(1656);
      frame_left();
      setState(1657);
      match(SQLiteParser::AND_);
      setState(1658);
      frame_right();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_clauseContext ------------------------------------------------------------------

SQLiteParser::Order_clauseContext::Order_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Order_clauseContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

tree::TerminalNode* SQLiteParser::Order_clauseContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

std::vector<SQLiteParser::Ordering_termContext *> SQLiteParser::Order_clauseContext::ordering_term() {
  return getRuleContexts<SQLiteParser::Ordering_termContext>();
}

SQLiteParser::Ordering_termContext* SQLiteParser::Order_clauseContext::ordering_term(size_t i) {
  return getRuleContext<SQLiteParser::Ordering_termContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Order_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Order_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Order_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleOrder_clause;
}

void SQLiteParser::Order_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_clause(this);
}

void SQLiteParser::Order_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_clause(this);
}


std::any SQLiteParser::Order_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrder_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Order_clauseContext* SQLiteParser::order_clause() {
  Order_clauseContext *_localctx = _tracker.createInstance<Order_clauseContext>(_ctx, getState());
  enterRule(_localctx, 122, SQLiteParser::RuleOrder_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1662);
    match(SQLiteParser::ORDER_);
    setState(1663);
    match(SQLiteParser::BY_);
    setState(1664);
    ordering_term();
    setState(1669);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1665);
      match(SQLiteParser::COMMA);
      setState(1666);
      ordering_term();
      setState(1671);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Limit_clauseContext ------------------------------------------------------------------

SQLiteParser::Limit_clauseContext::Limit_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Limit_clauseContext::LIMIT_() {
  return getToken(SQLiteParser::LIMIT_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Limit_clauseContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Limit_clauseContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Limit_clauseContext::OFFSET_() {
  return getToken(SQLiteParser::OFFSET_, 0);
}

tree::TerminalNode* SQLiteParser::Limit_clauseContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}


size_t SQLiteParser::Limit_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleLimit_clause;
}

void SQLiteParser::Limit_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimit_clause(this);
}

void SQLiteParser::Limit_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimit_clause(this);
}


std::any SQLiteParser::Limit_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitLimit_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Limit_clauseContext* SQLiteParser::limit_clause() {
  Limit_clauseContext *_localctx = _tracker.createInstance<Limit_clauseContext>(_ctx, getState());
  enterRule(_localctx, 124, SQLiteParser::RuleLimit_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1672);
    match(SQLiteParser::LIMIT_);
    setState(1673);
    expr(0);
    setState(1676);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::COMMA || _la == SQLiteParser::OFFSET_) {
      setState(1674);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::COMMA || _la == SQLiteParser::OFFSET_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1675);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordering_termContext ------------------------------------------------------------------

SQLiteParser::Ordering_termContext::Ordering_termContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Ordering_termContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Ordering_termContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Asc_descContext* SQLiteParser::Ordering_termContext::asc_desc() {
  return getRuleContext<SQLiteParser::Asc_descContext>(0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::NULLS_() {
  return getToken(SQLiteParser::NULLS_, 0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::FIRST_() {
  return getToken(SQLiteParser::FIRST_, 0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::LAST_() {
  return getToken(SQLiteParser::LAST_, 0);
}


size_t SQLiteParser::Ordering_termContext::getRuleIndex() const {
  return SQLiteParser::RuleOrdering_term;
}

void SQLiteParser::Ordering_termContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrdering_term(this);
}

void SQLiteParser::Ordering_termContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrdering_term(this);
}


std::any SQLiteParser::Ordering_termContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrdering_term(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Ordering_termContext* SQLiteParser::ordering_term() {
  Ordering_termContext *_localctx = _tracker.createInstance<Ordering_termContext>(_ctx, getState());
  enterRule(_localctx, 126, SQLiteParser::RuleOrdering_term);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1678);
    expr(0);
    setState(1681);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::COLLATE_) {
      setState(1679);
      match(SQLiteParser::COLLATE_);
      setState(1680);
      collation_name();
    }
    setState(1684);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_) {
      setState(1683);
      asc_desc();
    }
    setState(1688);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::NULLS_) {
      setState(1686);
      match(SQLiteParser::NULLS_);
      setState(1687);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::FIRST_

      || _la == SQLiteParser::LAST_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Asc_descContext ------------------------------------------------------------------

SQLiteParser::Asc_descContext::Asc_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Asc_descContext::ASC_() {
  return getToken(SQLiteParser::ASC_, 0);
}

tree::TerminalNode* SQLiteParser::Asc_descContext::DESC_() {
  return getToken(SQLiteParser::DESC_, 0);
}


size_t SQLiteParser::Asc_descContext::getRuleIndex() const {
  return SQLiteParser::RuleAsc_desc;
}

void SQLiteParser::Asc_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsc_desc(this);
}

void SQLiteParser::Asc_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsc_desc(this);
}


std::any SQLiteParser::Asc_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAsc_desc(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Asc_descContext* SQLiteParser::asc_desc() {
  Asc_descContext *_localctx = _tracker.createInstance<Asc_descContext>(_ctx, getState());
  enterRule(_localctx, 128, SQLiteParser::RuleAsc_desc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1690);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_leftContext ------------------------------------------------------------------

SQLiteParser::Frame_leftContext::Frame_leftContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Frame_leftContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::FOLLOWING_() {
  return getToken(SQLiteParser::FOLLOWING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}


size_t SQLiteParser::Frame_leftContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_left;
}

void SQLiteParser::Frame_leftContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_left(this);
}

void SQLiteParser::Frame_leftContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_left(this);
}


std::any SQLiteParser::Frame_leftContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_left(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_leftContext* SQLiteParser::frame_left() {
  Frame_leftContext *_localctx = _tracker.createInstance<Frame_leftContext>(_ctx, getState());
  enterRule(_localctx, 130, SQLiteParser::RuleFrame_left);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1702);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1692);
      expr(0);
      setState(1693);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1695);
      expr(0);
      setState(1696);
      match(SQLiteParser::FOLLOWING_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1698);
      match(SQLiteParser::CURRENT_);
      setState(1699);
      match(SQLiteParser::ROW_);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1700);
      match(SQLiteParser::UNBOUNDED_);
      setState(1701);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_rightContext ------------------------------------------------------------------

SQLiteParser::Frame_rightContext::Frame_rightContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Frame_rightContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::FOLLOWING_() {
  return getToken(SQLiteParser::FOLLOWING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}


size_t SQLiteParser::Frame_rightContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_right;
}

void SQLiteParser::Frame_rightContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_right(this);
}

void SQLiteParser::Frame_rightContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_right(this);
}


std::any SQLiteParser::Frame_rightContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_right(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_rightContext* SQLiteParser::frame_right() {
  Frame_rightContext *_localctx = _tracker.createInstance<Frame_rightContext>(_ctx, getState());
  enterRule(_localctx, 132, SQLiteParser::RuleFrame_right);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1714);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 263, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1704);
      expr(0);
      setState(1705);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1707);
      expr(0);
      setState(1708);
      match(SQLiteParser::FOLLOWING_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1710);
      match(SQLiteParser::CURRENT_);
      setState(1711);
      match(SQLiteParser::ROW_);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1712);
      match(SQLiteParser::UNBOUNDED_);
      setState(1713);
      match(SQLiteParser::FOLLOWING_);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_singleContext ------------------------------------------------------------------

SQLiteParser::Frame_singleContext::Frame_singleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Frame_singleContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}


size_t SQLiteParser::Frame_singleContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_single;
}

void SQLiteParser::Frame_singleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_single(this);
}

void SQLiteParser::Frame_singleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_single(this);
}


std::any SQLiteParser::Frame_singleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_single(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_singleContext* SQLiteParser::frame_single() {
  Frame_singleContext *_localctx = _tracker.createInstance<Frame_singleContext>(_ctx, getState());
  enterRule(_localctx, 134, SQLiteParser::RuleFrame_single);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1723);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1716);
      expr(0);
      setState(1717);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1719);
      match(SQLiteParser::UNBOUNDED_);
      setState(1720);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1721);
      match(SQLiteParser::CURRENT_);
      setState(1722);
      match(SQLiteParser::ROW_);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Error_messageContext ------------------------------------------------------------------

SQLiteParser::Error_messageContext::Error_messageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Error_messageContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}


size_t SQLiteParser::Error_messageContext::getRuleIndex() const {
  return SQLiteParser::RuleError_message;
}

void SQLiteParser::Error_messageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterError_message(this);
}

void SQLiteParser::Error_messageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitError_message(this);
}


std::any SQLiteParser::Error_messageContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitError_message(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Error_messageContext* SQLiteParser::error_message() {
  Error_messageContext *_localctx = _tracker.createInstance<Error_messageContext>(_ctx, getState());
  enterRule(_localctx, 136, SQLiteParser::RuleError_message);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1725);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilenameContext ------------------------------------------------------------------

SQLiteParser::FilenameContext::FilenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::FilenameContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}


size_t SQLiteParser::FilenameContext::getRuleIndex() const {
  return SQLiteParser::RuleFilename;
}

void SQLiteParser::FilenameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilename(this);
}

void SQLiteParser::FilenameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilename(this);
}


std::any SQLiteParser::FilenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFilename(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::FilenameContext* SQLiteParser::filename() {
  FilenameContext *_localctx = _tracker.createInstance<FilenameContext>(_ctx, getState());
  enterRule(_localctx, 138, SQLiteParser::RuleFilename);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1727);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_argumentContext ------------------------------------------------------------------

SQLiteParser::Module_argumentContext::Module_argumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SQLiteParser::Module_argumentContext::OPEN_PAR() {
  return getTokens(SQLiteParser::OPEN_PAR);
}

tree::TerminalNode* SQLiteParser::Module_argumentContext::OPEN_PAR(size_t i) {
  return getToken(SQLiteParser::OPEN_PAR, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Module_argumentContext::CLOSE_PAR() {
  return getTokens(SQLiteParser::CLOSE_PAR);
}

tree::TerminalNode* SQLiteParser::Module_argumentContext::CLOSE_PAR(size_t i) {
  return getToken(SQLiteParser::CLOSE_PAR, i);
}

std::vector<SQLiteParser::Module_argumentContext *> SQLiteParser::Module_argumentContext::module_argument() {
  return getRuleContexts<SQLiteParser::Module_argumentContext>();
}

SQLiteParser::Module_argumentContext* SQLiteParser::Module_argumentContext::module_argument(size_t i) {
  return getRuleContext<SQLiteParser::Module_argumentContext>(i);
}


size_t SQLiteParser::Module_argumentContext::getRuleIndex() const {
  return SQLiteParser::RuleModule_argument;
}

void SQLiteParser::Module_argumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_argument(this);
}

void SQLiteParser::Module_argumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_argument(this);
}


std::any SQLiteParser::Module_argumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitModule_argument(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Module_argumentContext* SQLiteParser::module_argument() {
  Module_argumentContext *_localctx = _tracker.createInstance<Module_argumentContext>(_ctx, getState());
  enterRule(_localctx, 140, SQLiteParser::RuleModule_argument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1738); 
    _errHandler->sync(this);
    alt = 1 + 1;
    do {
      switch (alt) {
        case 1 + 1: {
              setState(1738);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case SQLiteParser::SCOL:
                case SQLiteParser::DOT:
                case SQLiteParser::COMMA:
                case SQLiteParser::ASSIGN:
                case SQLiteParser::STAR:
                case SQLiteParser::PLUS:
                case SQLiteParser::MINUS:
                case SQLiteParser::TILDE:
                case SQLiteParser::PIPE2:
                case SQLiteParser::DIV:
                case SQLiteParser::MOD:
                case SQLiteParser::LT2:
                case SQLiteParser::GT2:
                case SQLiteParser::AMP:
                case SQLiteParser::PIPE:
                case SQLiteParser::LT:
                case SQLiteParser::LT_EQ:
                case SQLiteParser::GT:
                case SQLiteParser::GT_EQ:
                case SQLiteParser::EQ:
                case SQLiteParser::NOT_EQ1:
                case SQLiteParser::NOT_EQ2:
                case SQLiteParser::JPTR:
                case SQLiteParser::JPTR2:
                case SQLiteParser::ABORT_:
                case SQLiteParser::ACTION_:
                case SQLiteParser::ADD_:
                case SQLiteParser::AFTER_:
                case SQLiteParser::ALL_:
                case SQLiteParser::ALTER_:
                case SQLiteParser::ANALYZE_:
                case SQLiteParser::AND_:
                case SQLiteParser::AS_:
                case SQLiteParser::ASC_:
                case SQLiteParser::ATTACH_:
                case SQLiteParser::AUTOINCREMENT_:
                case SQLiteParser::BEFORE_:
                case SQLiteParser::BEGIN_:
                case SQLiteParser::BETWEEN_:
                case SQLiteParser::BY_:
                case SQLiteParser::CASCADE_:
                case SQLiteParser::CASE_:
                case SQLiteParser::CAST_:
                case SQLiteParser::CHECK_:
                case SQLiteParser::COLLATE_:
                case SQLiteParser::COLUMN_:
                case SQLiteParser::COMMIT_:
                case SQLiteParser::CONFLICT_:
                case SQLiteParser::CONSTRAINT_:
                case SQLiteParser::CREATE_:
                case SQLiteParser::CROSS_:
                case SQLiteParser::CURRENT_DATE_:
                case SQLiteParser::CURRENT_TIME_:
                case SQLiteParser::CURRENT_TIMESTAMP_:
                case SQLiteParser::DATABASE_:
                case SQLiteParser::DEFAULT_:
                case SQLiteParser::DEFERRABLE_:
                case SQLiteParser::DEFERRED_:
                case SQLiteParser::DELETE_:
                case SQLiteParser::DESC_:
                case SQLiteParser::DETACH_:
                case SQLiteParser::DISTINCT_:
                case SQLiteParser::DROP_:
                case SQLiteParser::EACH_:
                case SQLiteParser::ELSE_:
                case SQLiteParser::END_:
                case SQLiteParser::ESCAPE_:
                case SQLiteParser::EXCEPT_:
                case SQLiteParser::EXCLUSIVE_:
                case SQLiteParser::EXISTS_:
                case SQLiteParser::EXPLAIN_:
                case SQLiteParser::FAIL_:
                case SQLiteParser::FOR_:
                case SQLiteParser::FOREIGN_:
                case SQLiteParser::FROM_:
                case SQLiteParser::FULL_:
                case SQLiteParser::GLOB_:
                case SQLiteParser::GROUP_:
                case SQLiteParser::HAVING_:
                case SQLiteParser::IF_:
                case SQLiteParser::IGNORE_:
                case SQLiteParser::IMMEDIATE_:
                case SQLiteParser::IN_:
                case SQLiteParser::INDEX_:
                case SQLiteParser::INDEXED_:
                case SQLiteParser::INITIALLY_:
                case SQLiteParser::INNER_:
                case SQLiteParser::INSERT_:
                case SQLiteParser::INSTEAD_:
                case SQLiteParser::INTERSECT_:
                case SQLiteParser::INTO_:
                case SQLiteParser::IS_:
                case SQLiteParser::ISNULL_:
                case SQLiteParser::JOIN_:
                case SQLiteParser::KEY_:
                case SQLiteParser::LEFT_:
                case SQLiteParser::LIKE_:
                case SQLiteParser::LIMIT_:
                case SQLiteParser::MATCH_:
                case SQLiteParser::MATERIALIZED_:
                case SQLiteParser::NATURAL_:
                case SQLiteParser::NO_:
                case SQLiteParser::NOT_:
                case SQLiteParser::NOTNULL_:
                case SQLiteParser::NULL_:
                case SQLiteParser::OF_:
                case SQLiteParser::OFFSET_:
                case SQLiteParser::ON_:
                case SQLiteParser::OR_:
                case SQLiteParser::ORDER_:
                case SQLiteParser::OUTER_:
                case SQLiteParser::PLAN_:
                case SQLiteParser::PRAGMA_:
                case SQLiteParser::PRIMARY_:
                case SQLiteParser::QUERY_:
                case SQLiteParser::RAISE_:
                case SQLiteParser::RECURSIVE_:
                case SQLiteParser::REFERENCES_:
                case SQLiteParser::REGEXP_:
                case SQLiteParser::REINDEX_:
                case SQLiteParser::RELEASE_:
                case SQLiteParser::RENAME_:
                case SQLiteParser::REPLACE_:
                case SQLiteParser::RESTRICT_:
                case SQLiteParser::RETURNING_:
                case SQLiteParser::RIGHT_:
                case SQLiteParser::ROLLBACK_:
                case SQLiteParser::ROW_:
                case SQLiteParser::ROWS_:
                case SQLiteParser::ROWID_:
                case SQLiteParser::SAVEPOINT_:
                case SQLiteParser::SELECT_:
                case SQLiteParser::SET_:
                case SQLiteParser::STRICT_:
                case SQLiteParser::TABLE_:
                case SQLiteParser::TEMP_:
                case SQLiteParser::TEMPORARY_:
                case SQLiteParser::THEN_:
                case SQLiteParser::TO_:
                case SQLiteParser::TRANSACTION_:
                case SQLiteParser::TRIGGER_:
                case SQLiteParser::UNION_:
                case SQLiteParser::UNIQUE_:
                case SQLiteParser::UPDATE_:
                case SQLiteParser::USING_:
                case SQLiteParser::VACUUM_:
                case SQLiteParser::VALUES_:
                case SQLiteParser::VIEW_:
                case SQLiteParser::VIRTUAL_:
                case SQLiteParser::WHEN_:
                case SQLiteParser::WHERE_:
                case SQLiteParser::WITH_:
                case SQLiteParser::WITHOUT_:
                case SQLiteParser::OVER_:
                case SQLiteParser::PARTITION_:
                case SQLiteParser::RANGE_:
                case SQLiteParser::PRECEDING_:
                case SQLiteParser::UNBOUNDED_:
                case SQLiteParser::CURRENT_:
                case SQLiteParser::FOLLOWING_:
                case SQLiteParser::RANK_:
                case SQLiteParser::GENERATED_:
                case SQLiteParser::ALWAYS_:
                case SQLiteParser::STORED_:
                case SQLiteParser::TRUE_:
                case SQLiteParser::FALSE_:
                case SQLiteParser::WINDOW_:
                case SQLiteParser::NULLS_:
                case SQLiteParser::FIRST_:
                case SQLiteParser::LAST_:
                case SQLiteParser::FILTER_:
                case SQLiteParser::GROUPS_:
                case SQLiteParser::EXCLUDE_:
                case SQLiteParser::TIES_:
                case SQLiteParser::OTHERS_:
                case SQLiteParser::DO_:
                case SQLiteParser::NOTHING_:
                case SQLiteParser::IDENTIFIER:
                case SQLiteParser::NUMERIC_LITERAL:
                case SQLiteParser::BIND_PARAMETER:
                case SQLiteParser::STRING_LITERAL:
                case SQLiteParser::BLOB_LITERAL:
                case SQLiteParser::SINGLE_LINE_COMMENT:
                case SQLiteParser::MULTILINE_COMMENT:
                case SQLiteParser::SPACES:
                case SQLiteParser::UNEXPECTED_CHAR: {
                  setState(1729);
                  _la = _input->LA(1);
                  if (_la == 0 || _la == Token::EOF || (_la == SQLiteParser::OPEN_PAR

                  || _la == SQLiteParser::CLOSE_PAR)) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                  break;
                }

                case SQLiteParser::OPEN_PAR: {
                  setState(1730);
                  match(SQLiteParser::OPEN_PAR);
                  setState(1734);
                  _errHandler->sync(this);
                  _la = _input->LA(1);
                  while ((((_la & ~ 0x3fULL) == 0) &&
                    ((1ULL << _la) & -18) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
                    ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
                    ((1ULL << (_la - 128)) & 2305843009213693951) != 0)) {
                    setState(1731);
                    module_argument();
                    setState(1736);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                  }
                  setState(1737);
                  match(SQLiteParser::CLOSE_PAR);
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1740); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 267, _ctx);
    } while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

SQLiteParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::KeywordContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ACTION_() {
  return getToken(SQLiteParser::ACTION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ADD_() {
  return getToken(SQLiteParser::ADD_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AFTER_() {
  return getToken(SQLiteParser::AFTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ALTER_() {
  return getToken(SQLiteParser::ALTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ANALYZE_() {
  return getToken(SQLiteParser::ANALYZE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AND_() {
  return getToken(SQLiteParser::AND_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ASC_() {
  return getToken(SQLiteParser::ASC_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ATTACH_() {
  return getToken(SQLiteParser::ATTACH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AUTOINCREMENT_() {
  return getToken(SQLiteParser::AUTOINCREMENT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BEFORE_() {
  return getToken(SQLiteParser::BEFORE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BEGIN_() {
  return getToken(SQLiteParser::BEGIN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BETWEEN_() {
  return getToken(SQLiteParser::BETWEEN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CASCADE_() {
  return getToken(SQLiteParser::CASCADE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CASE_() {
  return getToken(SQLiteParser::CASE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CAST_() {
  return getToken(SQLiteParser::CAST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CHECK_() {
  return getToken(SQLiteParser::CHECK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::COLUMN_() {
  return getToken(SQLiteParser::COLUMN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::COMMIT_() {
  return getToken(SQLiteParser::COMMIT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CONFLICT_() {
  return getToken(SQLiteParser::CONFLICT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CONSTRAINT_() {
  return getToken(SQLiteParser::CONSTRAINT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CROSS_() {
  return getToken(SQLiteParser::CROSS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_DATE_() {
  return getToken(SQLiteParser::CURRENT_DATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_TIME_() {
  return getToken(SQLiteParser::CURRENT_TIME_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_TIMESTAMP_() {
  return getToken(SQLiteParser::CURRENT_TIMESTAMP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DATABASE_() {
  return getToken(SQLiteParser::DATABASE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DEFAULT_() {
  return getToken(SQLiteParser::DEFAULT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DEFERRABLE_() {
  return getToken(SQLiteParser::DEFERRABLE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DEFERRED_() {
  return getToken(SQLiteParser::DEFERRED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DESC_() {
  return getToken(SQLiteParser::DESC_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DETACH_() {
  return getToken(SQLiteParser::DETACH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DROP_() {
  return getToken(SQLiteParser::DROP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EACH_() {
  return getToken(SQLiteParser::EACH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ELSE_() {
  return getToken(SQLiteParser::ELSE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ESCAPE_() {
  return getToken(SQLiteParser::ESCAPE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXCEPT_() {
  return getToken(SQLiteParser::EXCEPT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXCLUSIVE_() {
  return getToken(SQLiteParser::EXCLUSIVE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXPLAIN_() {
  return getToken(SQLiteParser::EXPLAIN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FOR_() {
  return getToken(SQLiteParser::FOR_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FOREIGN_() {
  return getToken(SQLiteParser::FOREIGN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FULL_() {
  return getToken(SQLiteParser::FULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GLOB_() {
  return getToken(SQLiteParser::GLOB_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GROUP_() {
  return getToken(SQLiteParser::GROUP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::HAVING_() {
  return getToken(SQLiteParser::HAVING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IMMEDIATE_() {
  return getToken(SQLiteParser::IMMEDIATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IN_() {
  return getToken(SQLiteParser::IN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INDEX_() {
  return getToken(SQLiteParser::INDEX_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INDEXED_() {
  return getToken(SQLiteParser::INDEXED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INITIALLY_() {
  return getToken(SQLiteParser::INITIALLY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INNER_() {
  return getToken(SQLiteParser::INNER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INSERT_() {
  return getToken(SQLiteParser::INSERT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INSTEAD_() {
  return getToken(SQLiteParser::INSTEAD_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INTERSECT_() {
  return getToken(SQLiteParser::INTERSECT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INTO_() {
  return getToken(SQLiteParser::INTO_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IS_() {
  return getToken(SQLiteParser::IS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ISNULL_() {
  return getToken(SQLiteParser::ISNULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::JOIN_() {
  return getToken(SQLiteParser::JOIN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::KEY_() {
  return getToken(SQLiteParser::KEY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LEFT_() {
  return getToken(SQLiteParser::LEFT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LIKE_() {
  return getToken(SQLiteParser::LIKE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LIMIT_() {
  return getToken(SQLiteParser::LIMIT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::MATCH_() {
  return getToken(SQLiteParser::MATCH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::MATERIALIZED_() {
  return getToken(SQLiteParser::MATERIALIZED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NATURAL_() {
  return getToken(SQLiteParser::NATURAL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NO_() {
  return getToken(SQLiteParser::NO_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NOTNULL_() {
  return getToken(SQLiteParser::NOTNULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OF_() {
  return getToken(SQLiteParser::OF_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OFFSET_() {
  return getToken(SQLiteParser::OFFSET_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OUTER_() {
  return getToken(SQLiteParser::OUTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PLAN_() {
  return getToken(SQLiteParser::PLAN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PRAGMA_() {
  return getToken(SQLiteParser::PRAGMA_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PRIMARY_() {
  return getToken(SQLiteParser::PRIMARY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::QUERY_() {
  return getToken(SQLiteParser::QUERY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RAISE_() {
  return getToken(SQLiteParser::RAISE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RECURSIVE_() {
  return getToken(SQLiteParser::RECURSIVE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REFERENCES_() {
  return getToken(SQLiteParser::REFERENCES_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REGEXP_() {
  return getToken(SQLiteParser::REGEXP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REINDEX_() {
  return getToken(SQLiteParser::REINDEX_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RELEASE_() {
  return getToken(SQLiteParser::RELEASE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RENAME_() {
  return getToken(SQLiteParser::RENAME_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RESTRICT_() {
  return getToken(SQLiteParser::RESTRICT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RETURNING_() {
  return getToken(SQLiteParser::RETURNING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RIGHT_() {
  return getToken(SQLiteParser::RIGHT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROWS_() {
  return getToken(SQLiteParser::ROWS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROWID_() {
  return getToken(SQLiteParser::ROWID_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::SELECT_() {
  return getToken(SQLiteParser::SELECT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::STRICT_() {
  return getToken(SQLiteParser::STRICT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::THEN_() {
  return getToken(SQLiteParser::THEN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TO_() {
  return getToken(SQLiteParser::TO_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TRIGGER_() {
  return getToken(SQLiteParser::TRIGGER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UNION_() {
  return getToken(SQLiteParser::UNION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::USING_() {
  return getToken(SQLiteParser::USING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VACUUM_() {
  return getToken(SQLiteParser::VACUUM_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VALUES_() {
  return getToken(SQLiteParser::VALUES_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VIEW_() {
  return getToken(SQLiteParser::VIEW_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VIRTUAL_() {
  return getToken(SQLiteParser::VIRTUAL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WHEN_() {
  return getToken(SQLiteParser::WHEN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WITH_() {
  return getToken(SQLiteParser::WITH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WITHOUT_() {
  return getToken(SQLiteParser::WITHOUT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RANGE_() {
  return getToken(SQLiteParser::RANGE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FOLLOWING_() {
  return getToken(SQLiteParser::FOLLOWING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RANK_() {
  return getToken(SQLiteParser::RANK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GENERATED_() {
  return getToken(SQLiteParser::GENERATED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ALWAYS_() {
  return getToken(SQLiteParser::ALWAYS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::STORED_() {
  return getToken(SQLiteParser::STORED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TRUE_() {
  return getToken(SQLiteParser::TRUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FALSE_() {
  return getToken(SQLiteParser::FALSE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WINDOW_() {
  return getToken(SQLiteParser::WINDOW_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NULLS_() {
  return getToken(SQLiteParser::NULLS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FIRST_() {
  return getToken(SQLiteParser::FIRST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LAST_() {
  return getToken(SQLiteParser::LAST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FILTER_() {
  return getToken(SQLiteParser::FILTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GROUPS_() {
  return getToken(SQLiteParser::GROUPS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXCLUDE_() {
  return getToken(SQLiteParser::EXCLUDE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TIES_() {
  return getToken(SQLiteParser::TIES_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OTHERS_() {
  return getToken(SQLiteParser::OTHERS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DO_() {
  return getToken(SQLiteParser::DO_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NOTHING_() {
  return getToken(SQLiteParser::NOTHING_, 0);
}


size_t SQLiteParser::KeywordContext::getRuleIndex() const {
  return SQLiteParser::RuleKeyword;
}

void SQLiteParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void SQLiteParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}


std::any SQLiteParser::KeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitKeyword(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::KeywordContext* SQLiteParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 142, SQLiteParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1742);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -134217728) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4503599627370495) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameContext ------------------------------------------------------------------

SQLiteParser::NameContext::NameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::NameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::NameContext::getRuleIndex() const {
  return SQLiteParser::RuleName;
}

void SQLiteParser::NameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName(this);
}

void SQLiteParser::NameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName(this);
}


std::any SQLiteParser::NameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitName(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::NameContext* SQLiteParser::name() {
  NameContext *_localctx = _tracker.createInstance<NameContext>(_ctx, getState());
  enterRule(_localctx, 144, SQLiteParser::RuleName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1744);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_nameContext ------------------------------------------------------------------

SQLiteParser::Function_nameContext::Function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Function_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Function_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleFunction_name;
}

void SQLiteParser::Function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_name(this);
}

void SQLiteParser::Function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_name(this);
}


std::any SQLiteParser::Function_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFunction_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Function_nameContext* SQLiteParser::function_name() {
  Function_nameContext *_localctx = _tracker.createInstance<Function_nameContext>(_ctx, getState());
  enterRule(_localctx, 146, SQLiteParser::RuleFunction_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1746);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Schema_nameContext ------------------------------------------------------------------

SQLiteParser::Schema_nameContext::Schema_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Schema_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Schema_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleSchema_name;
}

void SQLiteParser::Schema_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchema_name(this);
}

void SQLiteParser::Schema_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchema_name(this);
}


std::any SQLiteParser::Schema_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSchema_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Schema_nameContext* SQLiteParser::schema_name() {
  Schema_nameContext *_localctx = _tracker.createInstance<Schema_nameContext>(_ctx, getState());
  enterRule(_localctx, 148, SQLiteParser::RuleSchema_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1748);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_nameContext ------------------------------------------------------------------

SQLiteParser::Table_nameContext::Table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_name;
}

void SQLiteParser::Table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_name(this);
}

void SQLiteParser::Table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_name(this);
}


std::any SQLiteParser::Table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_nameContext* SQLiteParser::table_name() {
  Table_nameContext *_localctx = _tracker.createInstance<Table_nameContext>(_ctx, getState());
  enterRule(_localctx, 150, SQLiteParser::RuleTable_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1750);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_or_index_nameContext ------------------------------------------------------------------

SQLiteParser::Table_or_index_nameContext::Table_or_index_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_or_index_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_or_index_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_or_index_name;
}

void SQLiteParser::Table_or_index_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_or_index_name(this);
}

void SQLiteParser::Table_or_index_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_or_index_name(this);
}


std::any SQLiteParser::Table_or_index_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_or_index_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_or_index_nameContext* SQLiteParser::table_or_index_name() {
  Table_or_index_nameContext *_localctx = _tracker.createInstance<Table_or_index_nameContext>(_ctx, getState());
  enterRule(_localctx, 152, SQLiteParser::RuleTable_or_index_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1752);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_nameContext ------------------------------------------------------------------

SQLiteParser::Column_nameContext::Column_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Column_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Column_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_name;
}

void SQLiteParser::Column_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name(this);
}

void SQLiteParser::Column_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name(this);
}


std::any SQLiteParser::Column_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_nameContext* SQLiteParser::column_name() {
  Column_nameContext *_localctx = _tracker.createInstance<Column_nameContext>(_ctx, getState());
  enterRule(_localctx, 154, SQLiteParser::RuleColumn_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1754);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_aliasContext ------------------------------------------------------------------

SQLiteParser::Column_aliasContext::Column_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Column_aliasContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Column_aliasContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_alias;
}

void SQLiteParser::Column_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_alias(this);
}

void SQLiteParser::Column_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_alias(this);
}


std::any SQLiteParser::Column_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_alias(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_aliasContext* SQLiteParser::column_alias() {
  Column_aliasContext *_localctx = _tracker.createInstance<Column_aliasContext>(_ctx, getState());
  enterRule(_localctx, 156, SQLiteParser::RuleColumn_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1756);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Collation_nameContext ------------------------------------------------------------------

SQLiteParser::Collation_nameContext::Collation_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Collation_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Collation_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleCollation_name;
}

void SQLiteParser::Collation_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollation_name(this);
}

void SQLiteParser::Collation_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollation_name(this);
}


std::any SQLiteParser::Collation_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCollation_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Collation_nameContext* SQLiteParser::collation_name() {
  Collation_nameContext *_localctx = _tracker.createInstance<Collation_nameContext>(_ctx, getState());
  enterRule(_localctx, 158, SQLiteParser::RuleCollation_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1758);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Foreign_tableContext ------------------------------------------------------------------

SQLiteParser::Foreign_tableContext::Foreign_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Foreign_tableContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Foreign_tableContext::getRuleIndex() const {
  return SQLiteParser::RuleForeign_table;
}

void SQLiteParser::Foreign_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForeign_table(this);
}

void SQLiteParser::Foreign_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForeign_table(this);
}


std::any SQLiteParser::Foreign_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitForeign_table(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Foreign_tableContext* SQLiteParser::foreign_table() {
  Foreign_tableContext *_localctx = _tracker.createInstance<Foreign_tableContext>(_ctx, getState());
  enterRule(_localctx, 160, SQLiteParser::RuleForeign_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1760);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_nameContext ------------------------------------------------------------------

SQLiteParser::Index_nameContext::Index_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Index_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Index_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleIndex_name;
}

void SQLiteParser::Index_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_name(this);
}

void SQLiteParser::Index_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_name(this);
}


std::any SQLiteParser::Index_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitIndex_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Index_nameContext* SQLiteParser::index_name() {
  Index_nameContext *_localctx = _tracker.createInstance<Index_nameContext>(_ctx, getState());
  enterRule(_localctx, 162, SQLiteParser::RuleIndex_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1762);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trigger_nameContext ------------------------------------------------------------------

SQLiteParser::Trigger_nameContext::Trigger_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Trigger_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Trigger_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTrigger_name;
}

void SQLiteParser::Trigger_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrigger_name(this);
}

void SQLiteParser::Trigger_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrigger_name(this);
}


std::any SQLiteParser::Trigger_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTrigger_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Trigger_nameContext* SQLiteParser::trigger_name() {
  Trigger_nameContext *_localctx = _tracker.createInstance<Trigger_nameContext>(_ctx, getState());
  enterRule(_localctx, 164, SQLiteParser::RuleTrigger_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1764);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- View_nameContext ------------------------------------------------------------------

SQLiteParser::View_nameContext::View_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::View_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::View_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleView_name;
}

void SQLiteParser::View_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterView_name(this);
}

void SQLiteParser::View_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitView_name(this);
}


std::any SQLiteParser::View_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitView_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::View_nameContext* SQLiteParser::view_name() {
  View_nameContext *_localctx = _tracker.createInstance<View_nameContext>(_ctx, getState());
  enterRule(_localctx, 166, SQLiteParser::RuleView_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1766);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_nameContext ------------------------------------------------------------------

SQLiteParser::Module_nameContext::Module_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Module_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Module_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleModule_name;
}

void SQLiteParser::Module_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_name(this);
}

void SQLiteParser::Module_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_name(this);
}


std::any SQLiteParser::Module_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitModule_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Module_nameContext* SQLiteParser::module_name() {
  Module_nameContext *_localctx = _tracker.createInstance<Module_nameContext>(_ctx, getState());
  enterRule(_localctx, 168, SQLiteParser::RuleModule_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1768);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_nameContext ------------------------------------------------------------------

SQLiteParser::Pragma_nameContext::Pragma_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Pragma_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Pragma_nameContext::getRuleIndex() const {
  return SQLiteParser::RulePragma_name;
}

void SQLiteParser::Pragma_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_name(this);
}

void SQLiteParser::Pragma_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_name(this);
}


std::any SQLiteParser::Pragma_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPragma_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Pragma_nameContext* SQLiteParser::pragma_name() {
  Pragma_nameContext *_localctx = _tracker.createInstance<Pragma_nameContext>(_ctx, getState());
  enterRule(_localctx, 170, SQLiteParser::RulePragma_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1770);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Savepoint_nameContext ------------------------------------------------------------------

SQLiteParser::Savepoint_nameContext::Savepoint_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Savepoint_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Savepoint_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleSavepoint_name;
}

void SQLiteParser::Savepoint_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepoint_name(this);
}

void SQLiteParser::Savepoint_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepoint_name(this);
}


std::any SQLiteParser::Savepoint_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSavepoint_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::savepoint_name() {
  Savepoint_nameContext *_localctx = _tracker.createInstance<Savepoint_nameContext>(_ctx, getState());
  enterRule(_localctx, 172, SQLiteParser::RuleSavepoint_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1772);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_aliasContext ------------------------------------------------------------------

SQLiteParser::Table_aliasContext::Table_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_aliasContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_aliasContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_alias;
}

void SQLiteParser::Table_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_alias(this);
}

void SQLiteParser::Table_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_alias(this);
}


std::any SQLiteParser::Table_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_alias(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_aliasContext* SQLiteParser::table_alias() {
  Table_aliasContext *_localctx = _tracker.createInstance<Table_aliasContext>(_ctx, getState());
  enterRule(_localctx, 174, SQLiteParser::RuleTable_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1774);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_nameContext ------------------------------------------------------------------

SQLiteParser::Window_nameContext::Window_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Window_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Window_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_name;
}

void SQLiteParser::Window_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_name(this);
}

void SQLiteParser::Window_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_name(this);
}


std::any SQLiteParser::Window_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_nameContext* SQLiteParser::window_name() {
  Window_nameContext *_localctx = _tracker.createInstance<Window_nameContext>(_ctx, getState());
  enterRule(_localctx, 176, SQLiteParser::RuleWindow_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1776);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AliasContext ------------------------------------------------------------------

SQLiteParser::AliasContext::AliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::AliasContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::AliasContext::getRuleIndex() const {
  return SQLiteParser::RuleAlias;
}

void SQLiteParser::AliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlias(this);
}

void SQLiteParser::AliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlias(this);
}


std::any SQLiteParser::AliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAlias(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::AliasContext* SQLiteParser::alias() {
  AliasContext *_localctx = _tracker.createInstance<AliasContext>(_ctx, getState());
  enterRule(_localctx, 178, SQLiteParser::RuleAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1778);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Base_window_nameContext ------------------------------------------------------------------

SQLiteParser::Base_window_nameContext::Base_window_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Base_window_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Base_window_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleBase_window_name;
}

void SQLiteParser::Base_window_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBase_window_name(this);
}

void SQLiteParser::Base_window_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBase_window_name(this);
}


std::any SQLiteParser::Base_window_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitBase_window_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Base_window_nameContext* SQLiteParser::base_window_name() {
  Base_window_nameContext *_localctx = _tracker.createInstance<Base_window_nameContext>(_ctx, getState());
  enterRule(_localctx, 180, SQLiteParser::RuleBase_window_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1780);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_function_nameContext ------------------------------------------------------------------

SQLiteParser::Table_function_nameContext::Table_function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_function_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_function_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_function_name;
}

void SQLiteParser::Table_function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_function_name(this);
}

void SQLiteParser::Table_function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_function_name(this);
}


std::any SQLiteParser::Table_function_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_function_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_function_nameContext* SQLiteParser::table_function_name() {
  Table_function_nameContext *_localctx = _tracker.createInstance<Table_function_nameContext>(_ctx, getState());
  enterRule(_localctx, 182, SQLiteParser::RuleTable_function_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1782);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Factored_select_stmtContext ------------------------------------------------------------------

SQLiteParser::Factored_select_stmtContext::Factored_select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_stmtContext* SQLiteParser::Factored_select_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Factored_select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleFactored_select_stmt;
}

void SQLiteParser::Factored_select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFactored_select_stmt(this);
}

void SQLiteParser::Factored_select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFactored_select_stmt(this);
}


std::any SQLiteParser::Factored_select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFactored_select_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Factored_select_stmtContext* SQLiteParser::factored_select_stmt() {
  Factored_select_stmtContext *_localctx = _tracker.createInstance<Factored_select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 184, SQLiteParser::RuleFactored_select_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1784);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_select_stmtContext ------------------------------------------------------------------

SQLiteParser::Simple_select_stmtContext::Simple_select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_coreContext* SQLiteParser::Simple_select_stmtContext::select_core() {
  return getRuleContext<SQLiteParser::Select_coreContext>(0);
}

SQLiteParser::With_clauseContext* SQLiteParser::Simple_select_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

SQLiteParser::Order_clauseContext* SQLiteParser::Simple_select_stmtContext::order_clause() {
  return getRuleContext<SQLiteParser::Order_clauseContext>(0);
}

SQLiteParser::Limit_clauseContext* SQLiteParser::Simple_select_stmtContext::limit_clause() {
  return getRuleContext<SQLiteParser::Limit_clauseContext>(0);
}


size_t SQLiteParser::Simple_select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSimple_select_stmt;
}

void SQLiteParser::Simple_select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_select_stmt(this);
}

void SQLiteParser::Simple_select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_select_stmt(this);
}


std::any SQLiteParser::Simple_select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSimple_select_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Simple_select_stmtContext* SQLiteParser::simple_select_stmt() {
  Simple_select_stmtContext *_localctx = _tracker.createInstance<Simple_select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 186, SQLiteParser::RuleSimple_select_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1787);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1786);
      with_clause();
    }
    setState(1789);
    select_core();
    setState(1791);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1790);
      order_clause();
    }
    setState(1794);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(1793);
      limit_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_select_stmtContext ------------------------------------------------------------------

SQLiteParser::Compound_select_stmtContext::Compound_select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Select_coreContext *> SQLiteParser::Compound_select_stmtContext::select_core() {
  return getRuleContexts<SQLiteParser::Select_coreContext>();
}

SQLiteParser::Select_coreContext* SQLiteParser::Compound_select_stmtContext::select_core(size_t i) {
  return getRuleContext<SQLiteParser::Select_coreContext>(i);
}

SQLiteParser::With_clauseContext* SQLiteParser::Compound_select_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

SQLiteParser::Order_clauseContext* SQLiteParser::Compound_select_stmtContext::order_clause() {
  return getRuleContext<SQLiteParser::Order_clauseContext>(0);
}

SQLiteParser::Limit_clauseContext* SQLiteParser::Compound_select_stmtContext::limit_clause() {
  return getRuleContext<SQLiteParser::Limit_clauseContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::UNION_() {
  return getTokens(SQLiteParser::UNION_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::UNION_(size_t i) {
  return getToken(SQLiteParser::UNION_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::INTERSECT_() {
  return getTokens(SQLiteParser::INTERSECT_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::INTERSECT_(size_t i) {
  return getToken(SQLiteParser::INTERSECT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::EXCEPT_() {
  return getTokens(SQLiteParser::EXCEPT_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::EXCEPT_(size_t i) {
  return getToken(SQLiteParser::EXCEPT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::ALL_() {
  return getTokens(SQLiteParser::ALL_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::ALL_(size_t i) {
  return getToken(SQLiteParser::ALL_, i);
}


size_t SQLiteParser::Compound_select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCompound_select_stmt;
}

void SQLiteParser::Compound_select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_select_stmt(this);
}

void SQLiteParser::Compound_select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_select_stmt(this);
}


std::any SQLiteParser::Compound_select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCompound_select_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Compound_select_stmtContext* SQLiteParser::compound_select_stmt() {
  Compound_select_stmtContext *_localctx = _tracker.createInstance<Compound_select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 188, SQLiteParser::RuleCompound_select_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1797);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1796);
      with_clause();
    }
    setState(1799);
    select_core();
    setState(1809); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1806);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::UNION_: {
          setState(1800);
          match(SQLiteParser::UNION_);
          setState(1802);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::ALL_) {
            setState(1801);
            match(SQLiteParser::ALL_);
          }
          break;
        }

        case SQLiteParser::INTERSECT_: {
          setState(1804);
          match(SQLiteParser::INTERSECT_);
          break;
        }

        case SQLiteParser::EXCEPT_: {
          setState(1805);
          match(SQLiteParser::EXCEPT_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1808);
      select_core();
      setState(1811); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SQLiteParser::EXCEPT_

    || _la == SQLiteParser::INTERSECT_ || _la == SQLiteParser::UNION_);
    setState(1814);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1813);
      order_clause();
    }
    setState(1817);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(1816);
      limit_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recursive_cteContext ------------------------------------------------------------------

SQLiteParser::Recursive_cteContext::Recursive_cteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Cte_table_nameContext* SQLiteParser::Recursive_cteContext::cte_table_name() {
  return getRuleContext<SQLiteParser::Cte_table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::Initial_selectContext* SQLiteParser::Recursive_cteContext::initial_select() {
  return getRuleContext<SQLiteParser::Initial_selectContext>(0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::UNION_() {
  return getToken(SQLiteParser::UNION_, 0);
}

SQLiteParser::Recursive_selectContext* SQLiteParser::Recursive_cteContext::recursive_select() {
  return getRuleContext<SQLiteParser::Recursive_selectContext>(0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}


size_t SQLiteParser::Recursive_cteContext::getRuleIndex() const {
  return SQLiteParser::RuleRecursive_cte;
}

void SQLiteParser::Recursive_cteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRecursive_cte(this);
}

void SQLiteParser::Recursive_cteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRecursive_cte(this);
}


std::any SQLiteParser::Recursive_cteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRecursive_cte(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Recursive_cteContext* SQLiteParser::recursive_cte() {
  Recursive_cteContext *_localctx = _tracker.createInstance<Recursive_cteContext>(_ctx, getState());
  enterRule(_localctx, 190, SQLiteParser::RuleRecursive_cte);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1819);
    cte_table_name();
    setState(1820);
    match(SQLiteParser::AS_);
    setState(1821);
    match(SQLiteParser::OPEN_PAR);
    setState(1822);
    initial_select();
    setState(1823);
    match(SQLiteParser::UNION_);
    setState(1825);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ALL_) {
      setState(1824);
      match(SQLiteParser::ALL_);
    }
    setState(1827);
    recursive_select();
    setState(1828);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_selectContext ------------------------------------------------------------------

SQLiteParser::Initial_selectContext::Initial_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_stmtContext* SQLiteParser::Initial_selectContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Initial_selectContext::getRuleIndex() const {
  return SQLiteParser::RuleInitial_select;
}

void SQLiteParser::Initial_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitial_select(this);
}

void SQLiteParser::Initial_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitial_select(this);
}


std::any SQLiteParser::Initial_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitInitial_select(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Initial_selectContext* SQLiteParser::initial_select() {
  Initial_selectContext *_localctx = _tracker.createInstance<Initial_selectContext>(_ctx, getState());
  enterRule(_localctx, 192, SQLiteParser::RuleInitial_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1830);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recursive_selectContext ------------------------------------------------------------------

SQLiteParser::Recursive_selectContext::Recursive_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_stmtContext* SQLiteParser::Recursive_selectContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Recursive_selectContext::getRuleIndex() const {
  return SQLiteParser::RuleRecursive_select;
}

void SQLiteParser::Recursive_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRecursive_select(this);
}

void SQLiteParser::Recursive_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRecursive_select(this);
}


std::any SQLiteParser::Recursive_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRecursive_select(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Recursive_selectContext* SQLiteParser::recursive_select() {
  Recursive_selectContext *_localctx = _tracker.createInstance<Recursive_selectContext>(_ctx, getState());
  enterRule(_localctx, 194, SQLiteParser::RuleRecursive_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1832);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_function_invocationContext ------------------------------------------------------------------

SQLiteParser::Simple_function_invocationContext::Simple_function_invocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Simple_funcContext* SQLiteParser::Simple_function_invocationContext::simple_func() {
  return getRuleContext<SQLiteParser::Simple_funcContext>(0);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Simple_function_invocationContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Simple_function_invocationContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Simple_function_invocationContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Simple_function_invocationContext::getRuleIndex() const {
  return SQLiteParser::RuleSimple_function_invocation;
}

void SQLiteParser::Simple_function_invocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_function_invocation(this);
}

void SQLiteParser::Simple_function_invocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_function_invocation(this);
}


std::any SQLiteParser::Simple_function_invocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSimple_function_invocation(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Simple_function_invocationContext* SQLiteParser::simple_function_invocation() {
  Simple_function_invocationContext *_localctx = _tracker.createInstance<Simple_function_invocationContext>(_ctx, getState());
  enterRule(_localctx, 196, SQLiteParser::RuleSimple_function_invocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1834);
    simple_func();
    setState(1835);
    match(SQLiteParser::OPEN_PAR);
    setState(1845);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR:
      case SQLiteParser::PLUS:
      case SQLiteParser::MINUS:
      case SQLiteParser::TILDE:
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::MATERIALIZED_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::ROWID_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::STRICT_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::RANK_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::TIES_:
      case SQLiteParser::OTHERS_:
      case SQLiteParser::DO_:
      case SQLiteParser::NOTHING_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::NUMERIC_LITERAL:
      case SQLiteParser::BIND_PARAMETER:
      case SQLiteParser::STRING_LITERAL:
      case SQLiteParser::BLOB_LITERAL: {
        setState(1836);
        expr(0);
        setState(1841);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1837);
          match(SQLiteParser::COMMA);
          setState(1838);
          expr(0);
          setState(1843);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SQLiteParser::STAR: {
        setState(1844);
        match(SQLiteParser::STAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1847);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_function_invocationContext ------------------------------------------------------------------

SQLiteParser::Aggregate_function_invocationContext::Aggregate_function_invocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Aggregate_funcContext* SQLiteParser::Aggregate_function_invocationContext::aggregate_func() {
  return getRuleContext<SQLiteParser::Aggregate_funcContext>(0);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Aggregate_function_invocationContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Aggregate_function_invocationContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::Aggregate_function_invocationContext::filter_clause() {
  return getRuleContext<SQLiteParser::Filter_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Aggregate_function_invocationContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::Order_clauseContext* SQLiteParser::Aggregate_function_invocationContext::order_clause() {
  return getRuleContext<SQLiteParser::Order_clauseContext>(0);
}


size_t SQLiteParser::Aggregate_function_invocationContext::getRuleIndex() const {
  return SQLiteParser::RuleAggregate_function_invocation;
}

void SQLiteParser::Aggregate_function_invocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregate_function_invocation(this);
}

void SQLiteParser::Aggregate_function_invocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregate_function_invocation(this);
}


std::any SQLiteParser::Aggregate_function_invocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAggregate_function_invocation(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Aggregate_function_invocationContext* SQLiteParser::aggregate_function_invocation() {
  Aggregate_function_invocationContext *_localctx = _tracker.createInstance<Aggregate_function_invocationContext>(_ctx, getState());
  enterRule(_localctx, 198, SQLiteParser::RuleAggregate_function_invocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1849);
    aggregate_func();
    setState(1850);
    match(SQLiteParser::OPEN_PAR);
    setState(1866);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR:
      case SQLiteParser::PLUS:
      case SQLiteParser::MINUS:
      case SQLiteParser::TILDE:
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::MATERIALIZED_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::ROWID_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::STRICT_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::RANK_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::TIES_:
      case SQLiteParser::OTHERS_:
      case SQLiteParser::DO_:
      case SQLiteParser::NOTHING_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::NUMERIC_LITERAL:
      case SQLiteParser::BIND_PARAMETER:
      case SQLiteParser::STRING_LITERAL:
      case SQLiteParser::BLOB_LITERAL: {
        setState(1852);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx)) {
        case 1: {
          setState(1851);
          match(SQLiteParser::DISTINCT_);
          break;
        }

        default:
          break;
        }
        setState(1854);
        expr(0);
        setState(1859);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1855);
          match(SQLiteParser::COMMA);
          setState(1856);
          expr(0);
          setState(1861);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1863);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ORDER_) {
          setState(1862);
          order_clause();
        }
        break;
      }

      case SQLiteParser::STAR: {
        setState(1865);
        match(SQLiteParser::STAR);
        break;
      }

      case SQLiteParser::CLOSE_PAR: {
        break;
      }

    default:
      break;
    }
    setState(1868);
    match(SQLiteParser::CLOSE_PAR);
    setState(1870);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FILTER_) {
      setState(1869);
      filter_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_function_invocationContext ------------------------------------------------------------------

SQLiteParser::Window_function_invocationContext::Window_function_invocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Window_funcContext* SQLiteParser::Window_function_invocationContext::window_func() {
  return getRuleContext<SQLiteParser::Window_funcContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

SQLiteParser::Window_defnContext* SQLiteParser::Window_function_invocationContext::window_defn() {
  return getRuleContext<SQLiteParser::Window_defnContext>(0);
}

SQLiteParser::Window_nameContext* SQLiteParser::Window_function_invocationContext::window_name() {
  return getRuleContext<SQLiteParser::Window_nameContext>(0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Window_function_invocationContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Window_function_invocationContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::Window_function_invocationContext::filter_clause() {
  return getRuleContext<SQLiteParser::Filter_clauseContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_function_invocationContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Window_function_invocationContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_function_invocation;
}

void SQLiteParser::Window_function_invocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_function_invocation(this);
}

void SQLiteParser::Window_function_invocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_function_invocation(this);
}


std::any SQLiteParser::Window_function_invocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_function_invocation(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_function_invocationContext* SQLiteParser::window_function_invocation() {
  Window_function_invocationContext *_localctx = _tracker.createInstance<Window_function_invocationContext>(_ctx, getState());
  enterRule(_localctx, 200, SQLiteParser::RuleWindow_function_invocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1872);
    window_func();
    setState(1873);
    match(SQLiteParser::OPEN_PAR);
    setState(1883);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR:
      case SQLiteParser::PLUS:
      case SQLiteParser::MINUS:
      case SQLiteParser::TILDE:
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::MATERIALIZED_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::ROWID_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::STRICT_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::RANK_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::TIES_:
      case SQLiteParser::OTHERS_:
      case SQLiteParser::DO_:
      case SQLiteParser::NOTHING_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::NUMERIC_LITERAL:
      case SQLiteParser::BIND_PARAMETER:
      case SQLiteParser::STRING_LITERAL:
      case SQLiteParser::BLOB_LITERAL: {
        setState(1874);
        expr(0);
        setState(1879);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1875);
          match(SQLiteParser::COMMA);
          setState(1876);
          expr(0);
          setState(1881);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SQLiteParser::STAR: {
        setState(1882);
        match(SQLiteParser::STAR);
        break;
      }

      case SQLiteParser::CLOSE_PAR: {
        break;
      }

    default:
      break;
    }
    setState(1885);
    match(SQLiteParser::CLOSE_PAR);
    setState(1887);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FILTER_) {
      setState(1886);
      filter_clause();
    }
    setState(1889);
    match(SQLiteParser::OVER_);
    setState(1892);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR: {
        setState(1890);
        window_defn();
        break;
      }

      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::MATERIALIZED_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::ROWID_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::STRICT_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::RANK_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::TIES_:
      case SQLiteParser::OTHERS_:
      case SQLiteParser::DO_:
      case SQLiteParser::NOTHING_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::STRING_LITERAL: {
        setState(1891);
        window_name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_funcContext ------------------------------------------------------------------

SQLiteParser::Simple_funcContext::Simple_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Simple_funcContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Simple_funcContext::getRuleIndex() const {
  return SQLiteParser::RuleSimple_func;
}

void SQLiteParser::Simple_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_func(this);
}

void SQLiteParser::Simple_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_func(this);
}


std::any SQLiteParser::Simple_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSimple_func(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Simple_funcContext* SQLiteParser::simple_func() {
  Simple_funcContext *_localctx = _tracker.createInstance<Simple_funcContext>(_ctx, getState());
  enterRule(_localctx, 202, SQLiteParser::RuleSimple_func);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1894);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_funcContext ------------------------------------------------------------------

SQLiteParser::Aggregate_funcContext::Aggregate_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Aggregate_funcContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Aggregate_funcContext::getRuleIndex() const {
  return SQLiteParser::RuleAggregate_func;
}

void SQLiteParser::Aggregate_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregate_func(this);
}

void SQLiteParser::Aggregate_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregate_func(this);
}


std::any SQLiteParser::Aggregate_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAggregate_func(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Aggregate_funcContext* SQLiteParser::aggregate_func() {
  Aggregate_funcContext *_localctx = _tracker.createInstance<Aggregate_funcContext>(_ctx, getState());
  enterRule(_localctx, 204, SQLiteParser::RuleAggregate_func);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1896);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_funcContext ------------------------------------------------------------------

SQLiteParser::Window_funcContext::Window_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Window_funcContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Window_funcContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_func;
}

void SQLiteParser::Window_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_func(this);
}

void SQLiteParser::Window_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_func(this);
}


std::any SQLiteParser::Window_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_func(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_funcContext* SQLiteParser::window_func() {
  Window_funcContext *_localctx = _tracker.createInstance<Window_funcContext>(_ctx, getState());
  enterRule(_localctx, 206, SQLiteParser::RuleWindow_func);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1898);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_nameContext ------------------------------------------------------------------

SQLiteParser::Any_nameContext::Any_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Any_nameContext::IDENTIFIER() {
  return getToken(SQLiteParser::IDENTIFIER, 0);
}

SQLiteParser::KeywordContext* SQLiteParser::Any_nameContext::keyword() {
  return getRuleContext<SQLiteParser::KeywordContext>(0);
}

tree::TerminalNode* SQLiteParser::Any_nameContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}


size_t SQLiteParser::Any_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleAny_name;
}

void SQLiteParser::Any_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAny_name(this);
}

void SQLiteParser::Any_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAny_name(this);
}


std::any SQLiteParser::Any_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAny_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Any_nameContext* SQLiteParser::any_name() {
  Any_nameContext *_localctx = _tracker.createInstance<Any_nameContext>(_ctx, getState());
  enterRule(_localctx, 208, SQLiteParser::RuleAny_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1903);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(1900);
        match(SQLiteParser::IDENTIFIER);
        break;
      }

      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::MATERIALIZED_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::ROWID_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::STRICT_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::RANK_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::TIES_:
      case SQLiteParser::OTHERS_:
      case SQLiteParser::DO_:
      case SQLiteParser::NOTHING_: {
        enterOuterAlt(_localctx, 2);
        setState(1901);
        keyword();
        break;
      }

      case SQLiteParser::STRING_LITERAL: {
        enterOuterAlt(_localctx, 3);
        setState(1902);
        match(SQLiteParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool SQLiteParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 32: return exprSempred(antlrcpp::downCast<ExprContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool SQLiteParser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 20);
    case 1: return precpred(_ctx, 19);
    case 2: return precpred(_ctx, 18);
    case 3: return precpred(_ctx, 17);
    case 4: return precpred(_ctx, 16);
    case 5: return precpred(_ctx, 15);
    case 6: return precpred(_ctx, 14);
    case 7: return precpred(_ctx, 13);
    case 8: return precpred(_ctx, 8);
    case 9: return precpred(_ctx, 7);
    case 10: return precpred(_ctx, 21);
    case 11: return precpred(_ctx, 12);
    case 12: return precpred(_ctx, 11);
    case 13: return precpred(_ctx, 10);

  default:
    break;
  }
  return true;
}

void SQLiteParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  sqliteparserParserInitialize();
#else
  ::antlr4::internal::call_once(sqliteparserParserOnceFlag, sqliteparserParserInitialize);
#endif
}
